<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="HeptagramV"><meta name="renderer" content="webkit"><meta name="copyright" content="HeptagramV"><meta name="keywords" content="七酱的布洛克"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Shader入门精要学习 · HeptagramV's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/web.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/headpic.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">HeptaV</div><div class="profile-signature">姑且算个游戏开发人</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">HeptagramV's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">Shader入门精要学习</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2022-04-29</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="学习"> 学习</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="Shader入门精要"><a href="#Shader入门精要" class="headerlink" title="Shader入门精要"></a>Shader入门精要</h1><h2 id="第二章-渲染流水线"><a href="#第二章-渲染流水线" class="headerlink" title="第二章 渲染流水线"></a>第二章 渲染流水线</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>流水线指每一个生产单位只专注处理某一个片段的工作,以提高工作效率及产量。</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220429180007039.png" alt="image-20220429180007039"></p>
<p>渲染流水线的工作任务在于由一个三维场景出发、生成&#x2F;渲染一张二维图像。即计算机要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。该工作由CPU和GPU共同完成。</p>
<p>一个渲染流程由<strong>应用阶段（Application Stage）、几何阶段（Geometry Stage）、光栅化阶段（Rasterizer Stage）</strong>构成；</p>
<p>其中应用阶段输出<strong>渲染图元</strong>，几何阶段输出<strong>屏幕空间的顶点信息</strong>，光栅化阶段<strong>产生像素并渲染最终图像</strong></p>
<h3 id="2-2-CPU和GPU之间的通信"><a href="#2-2-CPU和GPU之间的通信" class="headerlink" title="2.2 CPU和GPU之间的通信"></a>2.2 CPU和GPU之间的通信</h3><p>通信过程发生在在CPU进行的<strong>应用阶段</strong>：</p>
<ol>
<li><p>把数据加载到显存中</p>
</li>
<li><p>设置渲染状态</p>
</li>
<li><p>调用Draw Call</p>
</li>
</ol>
<h3 id="2-3-GPU流水线"><a href="#2-3-GPU流水线" class="headerlink" title="2.3 GPU流水线"></a>2.3 <strong>GPU流水线</strong></h3><ul>
<li>当GPU从CPU得到渲染命令后，就会进行一系列流水线操作，最终把图元绘制到屏幕上。该流水线操作即之前提到的<strong>几何阶段和光栅化阶段</strong>。</li>
<li>而几何阶段可分为顶点着色器-&gt;曲面细分着色器-&gt;几何着色器-&gt;裁剪-&gt;屏幕映射</li>
<li>光栅化阶段可分为三角形设置-&gt;三角形遍历-&gt;片元着色器-&gt;逐片元操作</li>
<li>最终输出屏幕图像。</li>
</ul>
<h3 id="2-4-术语解释及本章解惑"><a href="#2-4-术语解释及本章解惑" class="headerlink" title="2.4 术语解释及本章解惑"></a>2.4 术语解释及本章解惑</h3><p>在Unity中大部分功能被封装，我们只需要在一个Unity Shader设置一些输入、编写顶点着色器和片元着色器，设置一些状态就可以达到大部分常见的屏幕效果。</p>
<h4 id="2-4-1-什么是OpenGL-x2F-DirectX"><a href="#2-4-1-什么是OpenGL-x2F-DirectX" class="headerlink" title="2.4.1 什么是OpenGL&#x2F;DirectX"></a>2.4.1 什么是OpenGL&#x2F;DirectX</h4><ul>
<li>图像应用编程接口，用于渲染二维或三维图形，这些接口架起了上层应用程序和底层GPU的沟通桥梁。</li>
<li>我们运行在CPU上的应用程序通过调用它们的图形接口将渲染所需的数据(顶点数据、纹理数据、材质参数等)存储在显存中的特定区域，随后开发者通过图像编程接口发出Draw Call，它们被显卡驱动翻译成GPU能够理解的代码，进行绘制。</li>
<li>因为显卡驱动的存在，几乎所有的GPU都可以和OpenGL或DirectX合作，显卡驱动作为中介者和图像编程接口及GPU打交道，显卡制作商便必须提供支持两种接口的显卡驱动。</li>
</ul>
<h4 id="2-4-2-什么是HLSL、GLSL、Cg"><a href="#2-4-2-什么是HLSL、GLSL、Cg" class="headerlink" title="2.4.2 什么是HLSL、GLSL、Cg"></a>2.4.2 什么是HLSL、GLSL、Cg</h4><p>对于可编程的着色器阶段，我们可以使用一种特定的语言来编写程序，在可编程管线出现之前，开发者使用汇编语言编写着色器代码，而为了方便，出现了更高级的**着色语言(Shading Language)**，专门用来编写着色器。</p>
<p>DirectX的HLSL(High Level Shading Language)</p>
<ul>
<li>微软控制着色器的编译，因此支持HLSL的平台相对比较有限，几乎完全是微软产品，因为其他平台没有可以编译HLSL的编译器。</li>
</ul>
<p>OpenGL的GLSL(OpenGL Shading Language)</p>
<ul>
<li>具有跨平台性，可以在Windows,Linux,Mac和移动等多种平台工作，是由于OpenGL没有提供着色器编译器，而是由显卡驱动来完成着色器的编译工作。</li>
</ul>
<p>NVIDIA的Cg(C for Graphic)</p>
<ul>
<li>真正意义上的跨平台，它会根据平台的不同，编译成相应的中间语言。Cg由于和微软合作，导致Cg的语法和HLSL非常相像，缺点是无法完全发挥出OpenGL的最新特性。</li>
</ul>
<p>而在Unity里，我们可以选择”Cg&#x2F;HLSL”或者”GLSL”，但是Unity里的<strong>并不是真正意义上的对应的着色语言</strong>，尽管他们的语法几乎一样。</p>
<h4 id="2-4-3-什么是Draw-Call"><a href="#2-4-3-什么是Draw-Call" class="headerlink" title="2.4.3 什么是Draw Call"></a>2.4.3 什么是Draw Call</h4><p>CPU调用图像编程接口，如OpenGL中的glDrawElements命令或者DirectX中的DrawIndexedPrimitive命令，以命令GPU进行渲染的操作。</p>
<p><strong>CPU和GPU是如何实现并行工作的？</strong></p>
<ul>
<li>使用**命令缓冲区(Command Buffer)**，其包含了一个命令队列，由CPU向其中添加命令，而由GPU从中读取命令，添加和读取的命令相互独立，这使得CPU和GPU可以相互独立工作，Draw Call就是其中一种命令。</li>
</ul>
<p><strong>为什么Draw Call多了会影响帧率？</strong></p>
<ul>
<li>就像复制10000个1KB的文件用时会比复制1个1MB的文件长，每次复制动作的额外操作很多。</li>
<li>每次调用Draw Call时CPU也要完成很多工作，GPU的渲染能力很强，其渲染速度往往快于CPU提交命令的速度，若Draw Call的数量太多，CPU就会把大量时间花费在提交Draw Call上，造成CPU的过载。</li>
</ul>
<p><strong>如何减少Draw Call？</strong></p>
<ul>
<li>有很多方法，但是常用的是使用**批处理(Batching)**的方法。</li>
<li>把很多小的Draw Call合并成一个大的Draw Call，这就是批处理的思想。</li>
<li>我们需要在CPU的内存中合并网格，而合并的过程需要消耗时间，因此批处理适合静态物体，因为他们只需要合并一次。</li>
<li>在游戏开发中，为了减少Draw Call：<ul>
<li>我们应避免使用大量很小的网格，不可避免时，考虑是否可以合并他们。</li>
<li>避免使用过多的材质，尽量在不同的网格直接共用同一个材质。</li>
</ul>
</li>
</ul>
<h4 id="2-4-4-什么是固定管线渲染"><a href="#2-4-4-什么是固定管线渲染" class="headerlink" title="2.4.4 什么是固定管线渲染"></a>2.4.4 什么是固定管线渲染</h4><ul>
<li>**固定函数的流水线(Fixed-Function Pipeline)**，简称为固定管线，通常指在较旧的CPU上实现的渲染流水线。这种流水线只给开发者提供一些配置操作，开发者没有对流水线阶段的完全控制权。</li>
<li>我们用固定管线进行渲染，就像控制电路上的多个开关，我们可以选择打开或关闭开关，但是不能控制电路的排布。</li>
</ul>
<h3 id="2-5-Shader"><a href="#2-5-Shader" class="headerlink" title="2.5 Shader"></a>2.5 Shader</h3><p>Shader所在的阶段就是渲染流水线的一部分，更具体来说，Shader就是：</p>
<ul>
<li><strong>GPU流水线上一些可高度编程的阶段</strong>，而由着色器编译出来的最终代码是会在GPU上运行的；</li>
<li><strong>有一些特定类型的着色器</strong>，如顶点着色器、片元着色器等；</li>
<li><strong>依靠着色器我们可以控制流水线中的渲染细节</strong>，例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</li>
</ul>
<h2 id="第三章-Unity-Shader基础"><a href="#第三章-Unity-Shader基础" class="headerlink" title="第三章 Unity Shader基础"></a>第三章 Unity Shader基础</h2><h3 id="3-2-ShaderLab"><a href="#3-2-ShaderLab" class="headerlink" title="3.2 ShaderLab"></a>3.2 ShaderLab</h3><p>是一种专门为Unity Shader服务的语言。</p>
<p>一个Unity Shader的基础结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot;&#123;</span><br><span class="line">   Properties&#123;</span><br><span class="line">      //属性</span><br><span class="line">   &#125;</span><br><span class="line">   SubShader&#123;</span><br><span class="line">      //显卡A使用的子着色器</span><br><span class="line">   &#125;</span><br><span class="line">   SubShader&#123;</span><br><span class="line">      //显卡B使用的子着色器</span><br><span class="line">   &#125;</span><br><span class="line">   Fallback &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-Properties"><a href="#3-3-2-Properties" class="headerlink" title="3.3.2 Properties"></a>3.3.2 Properties</h4><p>​    Properties语义块中包含了一系列**属性(property)<strong>，这些属性将会出现在材质面板中，我们需要使用他们的</strong>名字(Name)<strong>来访问，</strong>显示的名称(display name)<strong>则是出现在材质面板上的名字，我们还需要为每个属性指定它的</strong>类型(PropertyType)**，除此之外，我们还要为每个属性制定一个默认值，第一次将其赋给某个材质时将显示默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">   Name(&quot;display name&quot;, PropertyType) = DefaultValue</span><br><span class="line">   Name(&quot;display name&quot;, PropertyType) = DefaultValue</span><br><span class="line">   //更多属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-SubShader"><a href="#3-3-3-SubShader" class="headerlink" title="3.3.3 SubShader"></a>3.3.3 SubShader</h4><p>​    每一个Unity Shader文件可以包含多个SubShader语义块，但最少要有一个。当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择第一个能够在目标平台上运行的SubShader。如果都不支持的话，Unity就会使用Fallback语义指定的Unity Shader，这样是为的在不同的显卡上使用不同的着色器。</p>
<p>SubShader语义块中包含的定义通常如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">   //可选的</span><br><span class="line">   [Tags]</span><br><span class="line">   </span><br><span class="line">   //可选的</span><br><span class="line">   [RenderSetup]</span><br><span class="line">   </span><br><span class="line">   pass&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   //Other Passes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubShader中定义了一系列Pass以及可选的**状态([RenderSetup])<strong>和</strong>标签([Tags])**设置。每个Pass定义了一次完整的渲染流程，但如果Pass的数目过多，往往会造成渲染性能的下降。</p>
<p>状态和标签同样可以在Pass声明；不同的是，SubShader中的一些标签设置是特定的，如果我们在SubShader进行了这些设置，那么将会用于所有的Pass。</p>
<p>ShaderLab提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态，例如是否开启混合&#x2F;深度测试等</p>
<p>​                                                                        <strong>常见的渲染状态设置选项</strong></p>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>设置指令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>Cull</td>
<td>Cull Back | Front | Off</td>
<td>设置剔除模式：剔除背面&#x2F;正面&#x2F;关闭剔除</td>
</tr>
<tr>
<td>ZTest</td>
<td>ZTest Less Greater | LEqual | GEqual | Equal | NotEqual | Always</td>
<td>设置深度测试时使用的函数</td>
</tr>
<tr>
<td>ZWrite</td>
<td>ZWrite On | Off</td>
<td>开启&#x2F;关闭深度写入</td>
</tr>
<tr>
<td>Blend</td>
<td>Blend SrcFactor DstFactor</td>
<td>开启并设置混合模式</td>
</tr>
</tbody></table>
<p>当在SubShader块中设置了上述渲染状态时，将会用到所有的Pass，可以在Pass语义块中单独进行上述设置。</p>
<p><strong>标签</strong></p>
<p>SubShader的<strong>标签(Tags)<strong>是一个</strong>键值对</strong>，他的Key和Value都是String，它们用来告诉Unity的渲染引擎：我希望怎样以及何时渲染这个对象。</p>
<p>标签的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; &quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Pass语义块</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    [Name]</span><br><span class="line">    [Tags]</span><br><span class="line">    [RenderSetup]</span><br><span class="line">    //Other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在Pass中定义该Pass的名称，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name &quot;MyPassName&quot;</span><br></pre></td></tr></table></figure>

<p>通过这个名称，我们可以使用ShaderLab的UsePass命令来直接使用其他Unity Shader中的Pass，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsePass &quot;MyShader/MYPASSNAME&quot;</span><br></pre></td></tr></table></figure>

<p>因为Unity内部会把所有Pass名称转换为大写，所以<strong>使用UsePass时必须使用大写形式的名字</strong></p>
<p>SubShader的状态设置同样适用于Pass，在Pass中还可以使用固定管线的着色器</p>
<p>Pass同样可以设置标签，但是不同于SubShader的标签，不过这些标签也是用于告诉渲染引擎我们希望怎样来渲染物体。</p>
<p><strong>Fallback</strong></p>
<p>紧跟在各个SubShader语义块之后的指令：告诉Unity，如果以上所有SubShader在这块显卡上都不能运行，那就使用这个最低级的Shader。</p>
<h4 id="3-4-1-表面着色器"><a href="#3-4-1-表面着色器" class="headerlink" title="3.4.1 表面着色器"></a>3.4.1 表面着色器</h4><p>表面着色器是Unity对顶点&#x2F;片元着色器的更高一层的抽象，它存在的价值在于Unity为我们处理了很多光照细节。</p>
<p>表面着色器被定义在SubShader语义块中的CGPROGRAM和ENDCG之间，使用Unity封装的Cg&#x2F;HLSL编写，因此原生的某些Cg&#x2F;HLSL函数将不能使用。</p>
<h4 id="3-4-2-顶点-x2F-片元着色器"><a href="#3-4-2-顶点-x2F-片元着色器" class="headerlink" title="3.4.2 顶点&#x2F;片元着色器"></a>3.4.2 顶点&#x2F;片元着色器</h4><p>顶点&#x2F;片元着色器的代码也需要定义在CGPROGRAM和ENDCG之间，但是它写在Pass语义块内而非SubShader内，因为我们需要自己定义每个Pass需要使用的Shader代码，我们可以控制渲染的实现细节。</p>
<h4 id="3-4-4-形式的选择"><a href="#3-4-4-形式的选择" class="headerlink" title="3.4.4 形式的选择"></a>3.4.4 形式的选择</h4><ul>
<li>除非你有非常明确的需求必须使用固定函数着色器，例如要在非常旧的设备上运行，否则请使用可编程管线的着色器，即表面着色器或顶点&#x2F;片元着色器。</li>
<li>如果你想和各种光源打交道，你可能更喜欢使用表面着色器，但需要小心它在移动平台的性能表现。</li>
<li>如果你需要使用的光照数目非常少，例如只有一个平行光，那么使用顶点&#x2F;片元着色器是一个更好的选择。</li>
<li>如果你有很多自定义的渲染效果，那么请选择顶点&#x2F;片元着色器。</li>
</ul>
<h2 id="第四章-数学"><a href="#第四章-数学" class="headerlink" title="第四章 数学"></a>第四章 数学</h2><p><strong>需要熟练掌握线性代数以及图形学基础相关知识</strong></p>
<h2 id="第五章-开始Unity-Shader"><a href="#第五章-开始Unity-Shader" class="headerlink" title="第五章 开始Unity Shader"></a>第五章 开始Unity Shader</h2><h3 id="5-2-一个最简单的顶点-x2F-片元着色器"><a href="#5-2-一个最简单的顶点-x2F-片元着色器" class="headerlink" title="5.2 一个最简单的顶点&#x2F;片元着色器"></a>5.2 一个最简单的顶点&#x2F;片元着色器</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Chapter5-SimpleShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>)<span class="comment">//声明一个Color类型的属性，对应白色</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Pass &#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			<span class="comment">//告诉Unity哪个函数包含顶点着色器/片元着色器的代码的编译指令，vert和frag是我们指定的函数名</span></span><br><span class="line"></span><br><span class="line">			fixed4 _Color;<span class="comment">//在Cg代码中，我们需要定义一个与属性名称和类型都匹配的变量</span></span><br><span class="line"></span><br><span class="line">			struct a2v &#123;</span><br><span class="line">			<span class="comment">//这些语义中获取的数据来自使用该材质的Mesh Render组件提供的；在每帧调用Draw Call的时候，Mesh Render会把他负责渲染的模型数据发送给Unity Shader</span></span><br><span class="line">				float4 vertex : POSITION;<span class="comment">//获取模型空间的顶点坐标</span></span><br><span class="line">				float3 normal: NORMAL;<span class="comment">//获取模型空间的法线方向</span></span><br><span class="line">				float4 texcoord: TEXCOORD0;<span class="comment">//获取模型的第一套纹理坐标</span></span><br><span class="line">			&#125;;</span><br><span class="line">			struct v2f &#123;<span class="comment">//该结构体用于在顶点和片元着色器之间通信</span></span><br><span class="line">				float4 pos : SV_POSITION;<span class="comment">//pos通过SV_POSITION语义包含了顶点在裁剪空间里的位置信息</span></span><br><span class="line">				fixed3 color : COLOR0;<span class="comment">//color存储了颜色信息</span></span><br><span class="line">			&#125;;</span><br><span class="line">			v2f vert(a2v v) &#123;<span class="comment">//声明输出结构</span></span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);<span class="comment">//在Unity5.6以后，UNITY_MATRIX_MVP运算的矩阵或者向量的mul方法，会转换成UnityObjectToClipPos方法。</span></span><br><span class="line">				o.color = v.normal * <span class="number">0.5</span> + fixed3(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>);<span class="comment">//v.normal包含了顶点的法线方向，其分量范围[-1.0,1.0]，而该语句将其映射到了[0.0,1.0],并存储到o.color中</span></span><br><span class="line">				<span class="keyword">return</span> o;<span class="comment">//将结构体v2f o中包含的位置以及颜色信息传递给了片元着色器</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//片元着色器的输入实际上是把顶点着色器的输出进行插值后的结果，因此v2f o得以输入到片元着色器中</span></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;<span class="comment">//没有输入，输出是一个fixed4类型的变量，SV_TARGET语义告诉渲染器，把用户的输出颜色存储到一个渲染目标中，这里将输入到默认的帧缓存中</span></span><br><span class="line">				fixed3 c = i.color;</span><br><span class="line">				c*=_Color.rgb;<span class="comment">//使用_Color属性来控制输出颜色</span></span><br><span class="line">				<span class="keyword">return</span> fixed4(c,<span class="number">1.00</span>);<span class="comment">//将插值后的i.color显示到屏幕上</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220428123503817.png" alt="ShaderLab属性类型和Cg变量类型的匹配关系"></p>
<h3 id="5-3-Unity提供的内置文件和变量"><a href="#5-3-Unity提供的内置文件和变量" class="headerlink" title="5.3 Unity提供的内置文件和变量"></a>5.3 Unity提供的内置文件和变量</h3><p>UnityCG.cginc 是最常接触的包含文件之一，提供了很多结构体和函数，详见文档</p>
<h3 id="5-4-Unity提供的Cg-x2F-HLSL语义"><a href="#5-4-Unity提供的Cg-x2F-HLSL语义" class="headerlink" title="5.4 Unity提供的Cg&#x2F;HLSL语义"></a>5.4 Unity提供的Cg&#x2F;HLSL语义</h3><p>语义可以让Shader知道从哪里读取数据，并把数据输出到哪里；</p>
<p>Unity对某些语义有一些特别规定的含义，例如输入结构体中，用TRXCOORD0来描述texcoord，Unity会识别TEXCOORD0，来赋予texcoord模型的<strong>第一组纹理坐标</strong>；</p>
<p>在DirectX10以后，新增了系统数值语义(system-value semantics)，以SV开头，在渲染流水线上有特殊的含义：如使用SV_POSITION来描述顶点着色器的输出变量pos，就表示pos包含了<strong>可用于光栅化的变换后的顶点坐标</strong>，用这些语义描述的变量不可以随便赋值，因为流水线需要使用他们来完成特定的目的；</p>
<p>为了让Shader有更好的跨平台性，对于这些有特殊含义的变量，最好使用SV开头的语义进行修饰，虽然在大多数平台他和正常语义等价，但是PS等某些平台上如果不使用SV开头的语义，则Shader无法正常工作。</p>
<h4 id="5-4-2-Unity支持的语义"><a href="#5-4-2-Unity支持的语义" class="headerlink" title="5.4.2 Unity支持的语义"></a>5.4.2 Unity支持的语义</h4><table>
<thead>
<tr>
<th>语义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>POSITION</td>
<td>模型空间中的顶点位置，通常是float4类型</td>
</tr>
<tr>
<td>NORMAL</td>
<td>顶点法线，通常是float3类型</td>
</tr>
<tr>
<td>TANGENT</td>
<td>顶点切线，通常是float4类型</td>
</tr>
<tr>
<td>TEXCOORD n</td>
<td>该顶点的纹理坐标，TEXCOORD0表示第一组坐标，以此类推，通常是float2或float4类型</td>
</tr>
<tr>
<td>COLOR</td>
<td>顶点颜色，通常是fixed4或float4类型</td>
</tr>
</tbody></table>
<p>​                                                      <strong>从应用阶段传递模型数据给顶点着色器时Unity支持的常用语义</strong></p>
<table>
<thead>
<tr>
<th>语义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SV_POSITION</td>
<td>裁剪空间中的顶点坐标，结构体中必须包含一个使用该语义修饰的变量</td>
</tr>
<tr>
<td>COLOR0</td>
<td>通常用于输出第一组顶点颜色，但非必须</td>
</tr>
<tr>
<td>COLOR1</td>
<td>通常用于输出第二组顶点颜色，但非必须</td>
</tr>
<tr>
<td>TEXCOORD0~TEXCOORD7</td>
<td>通常用于输出纹理坐标，但非必须</td>
</tr>
</tbody></table>
<p>​                                                       <strong>从顶点着色器传递数据给片元着色器时Unity使用的常用语义</strong></p>
<table>
<thead>
<tr>
<th>语义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SV_Target</td>
<td>输出值将会存储到渲染目标中</td>
</tr>
</tbody></table>
<p>​                                                                        <strong>片元着色器输出时Unity支持的常用语义</strong></p>
<h4 id="5-4-3-语义与变量类型"><a href="#5-4-3-语义与变量类型" class="headerlink" title="5.4.3 语义与变量类型"></a>5.4.3 语义与变量类型</h4><p>一个语义可以使用的寄存器只能处理4个float，因此定义矩阵类型如float3X4 float4X4就需要更多的空间，一种方法是，把这些矩阵拆分成单个float，每个变量存储矩阵中的一行数据。</p>
<h3 id="5-5-Debug"><a href="#5-5-Debug" class="headerlink" title="5.5 Debug"></a>5.5 Debug</h3><p>本节旨在给出对Unity Shader的调试方法：</p>
<h4 id="5-5-1使用假彩色图像"><a href="#5-5-1使用假彩色图像" class="headerlink" title="5.5.1使用假彩色图像"></a>5.5.1使用假彩色图像</h4><p>假彩色图像指的是用假彩色技术生成的一种图像，一张假彩色图像可以用于可视化一些数据；</p>
<p>主要思想是，<strong>把需要调试的变量映射到[0,1]之间，把它们作为颜色输出到屏幕上</strong>，然后通过屏幕上显示的像素颜色来判断这个值是否正确。</p>
<h4 id="5-5-2-Graphics-Debugger"><a href="#5-5-2-Graphics-Debugger" class="headerlink" title="5.5.2 Graphics Debugger"></a>5.5.2 Graphics Debugger</h4><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29523119/article/details/78409811?locationNum=5&amp;fps=1">https://blog.csdn.net/qq_29523119/article/details/78409811?locationNum=5&amp;fps=1</a></p>
<h4 id="5-5-3-帧调试器"><a href="#5-5-3-帧调试器" class="headerlink" title="5.5.3 帧调试器"></a>5.5.3 帧调试器</h4><p>在Window-&gt;Frame Debugger中可以打开帧调试器窗口</p>
<p>可以用于查看渲染该帧时进行的各种渲染事件</p>
<h3 id="5-6-渲染平台的差异"><a href="#5-6-渲染平台的差异" class="headerlink" title="5.6 渲染平台的差异"></a>5.6 渲染平台的差异</h3><h4 id="5-6-1-渲染纹理的坐标差异"><a href="#5-6-1-渲染纹理的坐标差异" class="headerlink" title="5.6.1 渲染纹理的坐标差异"></a>5.6.1 渲染纹理的坐标差异</h4><p>OpenGL和DirectX的屏幕空间坐标存在差异，虽然Unity大多数情况下可以在后台自动为我们解决，但是某些情况下，比如我们需要同时处理多张渲染图像并且开启了抗锯齿(例如需要同时处理屏幕图像和法线纹理)，这些图像在竖直方向的朝向就可能是不同的；</p>
<h4 id="5-6-2-Shader的语法差异"><a href="#5-6-2-Shader的语法差异" class="headerlink" title="5.6.2 Shader的语法差异"></a>5.6.2 Shader的语法差异</h4><p>DirectX 9&#x2F;11对Shader的语义更加严格；</p>
<h3 id="5-7-Shader整洁之道"><a href="#5-7-Shader整洁之道" class="headerlink" title="5.7 Shader整洁之道"></a>5.7 Shader整洁之道</h3><h4 id="5-7-1-变量精度"><a href="#5-7-1-变量精度" class="headerlink" title="5.7.1 变量精度"></a>5.7.1 变量精度</h4><p>基本建议：尽可能使用精度较低的类型，可以优化Shader的性能；</p>
<h4 id="5-7-2-规范语法"><a href="#5-7-2-规范语法" class="headerlink" title="5.7.2 规范语法"></a>5.7.2 规范语法</h4><h4 id="5-7-3-避免不必要的运算"><a href="#5-7-3-避免不必要的运算" class="headerlink" title="5.7.3 避免不必要的运算"></a>5.7.3 避免不必要的运算</h4><p>过多的运算会使需要的临时寄存器数目或指令数目超过了当前可支持的数目，通常可以通过指定更高等级的Shader Target来消除这些错误；</p>
<h4 id="5-7-4-慎用分支和循环语句"><a href="#5-7-4-慎用分支和循环语句" class="headerlink" title="5.7.4 慎用分支和循环语句"></a>5.7.4 慎用分支和循环语句</h4><p>GPU的实现和CPU不同，会降低GPU的并行处理操作，尽量把计算向上移动，例如将片元着色器的内容放到顶点着色器中，或者直接在CPU中预计算；</p>
<h4 id="5-7-5-不要除以0"><a href="#5-7-5-不要除以0" class="headerlink" title="5.7.5 不要除以0"></a>5.7.5 不要除以0</h4><h2 id="第六章-Unity中的基础光照"><a href="#第六章-Unity中的基础光照" class="headerlink" title="第六章 Unity中的基础光照"></a>第六章 Unity中的基础光照</h2><p>渲染的基础问题：如何决定一个像素的颜色？</p>
<p>宏观上来说，渲染包含了两大部分：决定一个像素的可见性，决定这个像素上的光照计算；而光照模型就是用于决定在一个像素上进行怎样的光照计算；</p>
<h3 id="6-2-标准光照模型"><a href="#6-2-标准光照模型" class="headerlink" title="6.2 标准光照模型"></a>6.2 标准光照模型</h3><p>又称Phong光照模型，他只关心直接光照，也就是直接从光源发射出来照射到物体表面后，经过物体表面的一次反射直接进入摄像机的光线；</p>
<p>他的基本方法是，把进入到摄像机内的光线分为四个部分，每个部分使用一种方法来计算它的贡献度：</p>
<ul>
<li><strong>自发光（emissive）</strong>部分，描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量（如果没有使用全局光照，自发光并不会真的照亮周围，只是他自己更亮了）</li>
<li><strong>高光反射（specular）</strong>部分，描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量</li>
<li><strong>漫反射（diffuse）</strong>部分,描述当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量（我们假设光线在所有方向平均分布）</li>
<li><strong>环境光（ambient）</strong>部分，描述其他所有的间接光照</li>
</ul>
<h4 id="6-2-1-环境光"><a href="#6-2-1-环境光" class="headerlink" title="6.2.1 环境光"></a>6.2.1 环境光</h4><p>在标准光照模型中，我们使用环境光来模拟间接光照，他通常是一个全局变量，即场景中的所有物体都使用这个环境光：<br>$$<br>C_a &#x3D; g_a<br>$$</p>
<h4 id="6-2-2-自发光"><a href="#6-2-2-自发光" class="headerlink" title="6.2.2 自发光"></a>6.2.2 自发光</h4><p>标准光照模型使用自发光计算没有反射直接进入摄像机的光线贡献度：<br>$$<br>C_e &#x3D; m_e<br>$$</p>
<p>通常在实时渲染中，自发光的表面并不会照亮周围的表面</p>
<h4 id="6-2-3-漫反射"><a href="#6-2-3-漫反射" class="headerlink" title="6.2.3 漫反射"></a>6.2.3 漫反射</h4><h5 id="兰伯特定律"><a href="#兰伯特定律" class="headerlink" title="兰伯特定律"></a>兰伯特定律</h5><p>漫反射光照符合<strong>兰伯特定律（Lambert’s law）</strong>：反射光线的强度与<strong>表面法线和光源方向之间夹角的余弦值</strong>成正比：<br>$$<br>C_d &#x3D; (C_l * m_d)max(0,\vec{n}·\vec{l})<br>$$<br>其中，n是表面法线，l是<strong>指向光源</strong>的单位矢量，m是材质的<strong>漫反射颜色</strong>，C<del>l</del>是<strong>光源颜色</strong>；需要注意的是，我们需要防止法线和光源方向点乘结果为负值，因此我们取最大值将其截取到0，这可以防止物体被从后面来的光源照亮（因为表面，是一个单面，后面会有别的面）</p>
<p><strong>值得注意的是，这里兰伯特反辐射公式是简化后了的版本，问就是节约性能，这里舍去了I&#x2F;r的平方</strong> </p>
<h4 id="6-2-4-高光反射"><a href="#6-2-4-高光反射" class="headerlink" title="6.2.4 高光反射"></a>6.2.4 高光反射</h4><p>这里的高光反射是一种经验模型，并不符合现实世界，它可用于计算沿着完全镜面反射的光线；</p>
<p>计算高光反射需要知道的信息比较多，如表面法线、视角方向、光源方向、反射方向，我们假设这些矢量都是单位矢量</p>
<p>在这四个矢量中，我们只需要知道三个，反射方向可以通过其他信息计算得到：<br>$$<br>\vec{r}&#x3D;2(\vec{n}·\vec{l})\vec{n}-\vec{l}<br>$$<br><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220429124507531.png" alt="image-20220429124507531"></p>
<p>这样，我们就可以利用Phong模型计算高光反射的部分：<br>$$<br>C_s&#x3D;(C_l*m_s)max(0,\vec{v}*\vec{r})^{m_g}<br>$$<br>其中，m<del>g</del>是材质的<strong>光泽度</strong>，又称<strong>反光度</strong>，它用于控制高光区域的“亮点”有多宽，m<del>g</del>越大，亮点就越小，m<del>s</del>是材质的高光反射颜色，C<del>l</del>是光源的颜色和强度；</p>
<p>而Blinn模型使用如下公式：<br>$$<br>C_s &#x3D; (C_l * m_s)max(0,\vec{n}*\vec{h})^{m_g}<br>$$<br>其中 向量h为向量v和l取平均后归一化得到的</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220517205042881.png" alt="image-20220517205042881"></p>
<p>而在摄像机和光源距离足够远的情况下，Blinn模型会快于Phong模型，因为此时v和l都可以看做不改变的定值，而此外的情况中Phong可能更快；</p>
<h4 id="6-2-5-逐像素还是逐顶点"><a href="#6-2-5-逐像素还是逐顶点" class="headerlink" title="6.2.5 逐像素还是逐顶点"></a>6.2.5 逐像素还是逐顶点</h4><p>逐像素光照</p>
<ul>
<li>在片元着色器中计算光照模型</li>
<li>以每个像素为基础得到他的法线，然后进行光照模型的计算，被称为Phong着色</li>
</ul>
<p>逐顶点光照</p>
<ul>
<li>在顶点着色器中计算光照模型</li>
<li>在每个顶点上计算光照，然后在渲染图元内部进行线性插值，最后输出成像素颜色</li>
<li>被称为高洛德着色</li>
</ul>
<p>因为顶点数目往往远小于像素数目，逐顶点光照的计算量便小于逐像素光照，但是逐顶点光照依赖线性插值，因此当光照模型中有<strong>非线性的计算</strong>（例如计算高光反射）时，逐顶点光照就会出现问题；</p>
<h3 id="6-3-Unity中的环境光和自发光"><a href="#6-3-Unity中的环境光和自发光" class="headerlink" title="6.3 Unity中的环境光和自发光"></a>6.3 Unity中的环境光和自发光</h3><p>环境光可以在Lighting面板中调节</p>
<p>自发光只需要在片元着色器输出最后的颜色之前，把材质的自发光颜色添加到输出颜色上即可</p>
<h3 id="6-4-实现漫反射光照模型"><a href="#6-4-实现漫反射光照模型" class="headerlink" title="6.4 实现漫反射光照模型"></a>6.4 实现漫反射光照模型</h3><h4 id="6-4-1-逐顶点光照"><a href="#6-4-1-逐顶点光照" class="headerlink" title="6.4.1 逐顶点光照"></a>6.4.1 逐顶点光照</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders/Chapter <span class="number">6</span>/Diffuse Vertex-Level&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Diffuse(&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="comment">//声明了一个Color类型的属性，并将其初始值设为白色</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<span class="comment">//LightMode标签用于定义Pass在Unity的光照流水线中的角色，定义正确的LightMode才能得到Unity内置的光照变量</span></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="comment">//为了使用unity内置的一些变量</span></span><br><span class="line">			fixed4 _Diffuse;<span class="comment">//为了使用Properties中声明的属性</span></span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				fixed3 color : COLOR;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123; <span class="comment">//逐顶点漫反射光照的关键部分，在顶点着色器中执行了漫反射部分的计算</span></span><br><span class="line">				v2f o;<span class="comment">//定义返回值o</span></span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);<span class="comment">//完成坐标变换</span></span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<span class="comment">//通过内置变量得到环境光部分</span></span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal,(float3x3)unity_WorldToObject));<span class="comment">//获得法线且将其转换到世界空间中，因为计算点积时需要在同一坐标系</span></span><br><span class="line">				<span class="comment">//我们首先得到模型空间到世界空间变换矩阵的逆矩阵_World2Object，然后通过调换它在mul函数中的位置，得到和转置矩阵相同的矩阵乘法，由于法线3x3,所以也截取他的3x3部分（参考4.7法线变换）</span></span><br><span class="line">				fixed3 worldLight = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<span class="comment">//在场景中只有一个光源且为平行光的时候，可以直接使用WorldSpaceLightPos0获得光源方向</span></span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal,worldLight));<span class="comment">//计算漫反射部分，saturate可以规范值在0~1之间</span></span><br><span class="line">				<span class="comment">//_LightColor0取得平行光的颜色，_Diffuse是我们开始时定义的Color类型的属性，并且默认值为白色</span></span><br><span class="line">				o.color = ambient + diffuse;<span class="comment">//将环境光和漫反射光相加，得到最终的光照结果</span></span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				<span class="keyword">return</span> fixed4(i.color,<span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-2-逐像素光照"><a href="#6-4-2-逐像素光照" class="headerlink" title="6.4.2 逐像素光照"></a>6.4.2 逐像素光照</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders/Chapter <span class="number">6</span>/Diffuse Pixel-Level&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Diffuse(&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="comment">//声明了一个Color类型的属性，并将其初始值设为白色</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<span class="comment">//LightMode标签用于定义Pass在Unity的光照流水线中的角色，定义正确的LightMode才能得到Unity内置的光照变量</span></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="comment">//为了使用unity内置的一些变量</span></span><br><span class="line">			fixed4 _Diffuse;<span class="comment">//为了使用Properties中声明的属性</span></span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				fixed3 worldNormal : TEXCOORD0;<span class="comment">//修改顶点着色器的输出，因为不需要输出颜色信息</span></span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123; <span class="comment">//顶点着色器不需要计算光照模型，只需要把世界空间下的法线传递给片元着色器即可，因此将颜色改为法线信息</span></span><br><span class="line">				v2f o;<span class="comment">//定义返回值o</span></span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);<span class="comment">//完成坐标变换</span></span><br><span class="line">				o.worldNormal = mul(v.normal,(float3x3)unity_WorldToObject);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<span class="comment">//获取环境条件</span></span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);<span class="comment">//获取世界空间下的法线</span></span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<span class="comment">//获取世界空间下的光照方向</span></span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal,worldLightDir));<span class="comment">//计算漫反射部分</span></span><br><span class="line">				fixed3 color = ambient + diffuse;</span><br><span class="line">				<span class="keyword">return</span> fixed4(color,<span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐像素光照可以得到更加平滑的光照效果</p>
<p>但是光照无法到达的领域，模型通常是全黑的，于是<strong>半兰伯特光照模型</strong>被提了出来</p>
<h4 id="6-4-3-半兰伯特模型"><a href="#6-4-3-半兰伯特模型" class="headerlink" title="6.4.3 半兰伯特模型"></a>6.4.3 半兰伯特模型</h4><p>我们之前使用的漫反射模型符合兰伯特定律，因此也被称为兰伯特光照模型；</p>
<p>V社在开发半条命时提出了一种新技术，被称为半兰伯特光照模型：<br>$$<br>C_d &#x3D; (C_l * m_d)(a(\vec{n}·\vec{l})+b)<br>$$<br>与兰伯特模型相比，半兰伯特光照模型没有使用max操作来防止点积为负，而是对其结果进行了一个a倍的缩放再加上一个b大小的偏移，<strong>绝大多数情况下，a和b的值均为0.5</strong>；</p>
<p>通过这样的方式，我们将点积的结果映射到[0,1]范围内，也就是说，对于模型的背光面，在原兰伯特光照模型中点积结果将映射到0，而对于半兰伯特模型，背光面也存在明暗变化，不同的点积结果会映射到不同的值上</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<span class="comment">//获取环境条件</span></span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);<span class="comment">//获取世界空间下的法线</span></span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<span class="comment">//获取世界空间下的光照方向</span></span><br><span class="line">				fixed halfLambert = <span class="built_in">dot</span>(worldNormal,worldLightDir)* <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * halfLambert;<span class="comment">//计算漫反射部分</span></span><br><span class="line">				fixed3 color = ambient + diffuse;</span><br><span class="line">				<span class="keyword">return</span> fixed4(color,<span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>修改逐像素着色中的片元着色器部分，使用半兰伯特公式，就得到了半兰伯特光照</p>
<h3 id="6-5-实现高光反射光照模型"><a href="#6-5-实现高光反射光照模型" class="headerlink" title="6.5 实现高光反射光照模型"></a>6.5 实现高光反射光照模型</h3><p>Cg提供了计算反射方向的函数：</p>
<p>reflect(i,n); i:入射方向，n:法线方向，可以是float float2 float3等类型，该函数返回反射方向</p>
<h4 id="6-5-1-逐顶点光照"><a href="#6-5-1-逐顶点光照" class="headerlink" title="6.5.1 逐顶点光照"></a>6.5.1 逐顶点光照</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders/Chapter <span class="number">6</span>/Specular Vertex-Level&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Diffuse(&quot;Diffuse&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		_Specular(&quot;Specular&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//用于控制材质的高光反射颜色</span></span><br><span class="line">		_Gloss(&quot;Gloss&quot;,Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span><span class="comment">//用于控制高光区域的大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags&#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">			fixed4 _Diffuse;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;<span class="comment">//为了使用Properties中声明的属性</span></span><br><span class="line"></span><br><span class="line">			struct a2v&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				fixed3 color : COLOR;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));<span class="comment">//获取世界空间下的法线</span></span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<span class="comment">//获取世界空间的光照方向</span></span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal,worldLightDir));</span><br><span class="line">				<span class="comment">//以上为漫反射部分</span></span><br><span class="line">				fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir,worldNormal));<span class="comment">//reflect函数的入射光要求是由光源指向交点处，因此我们给worldLightDir取反，获得反射方向</span></span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld,v.vertex).xyz);</span><br><span class="line">				<span class="comment">//我们通过_WorldSpaceCameraPos得到世界空间中的摄像机位置，再把顶点位置从模型空间变换到世界空间下，再通过和_WorldSpaceCameraPos相减即可得到世界空间下的视角方向</span></span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir,viewDir)),_Gloss);<span class="comment">//计算高光反射部分</span></span><br><span class="line">				o.color = ambient + diffuse + specular;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				<span class="keyword">return</span> fixed4(i.color,<span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为高光反射计算非线性，而计算光照再插值的过程线性，因此会出现较大的视觉问题，所以我们使用逐像素的方式来计算高光反射；</p>
<h4 id="6-5-2-逐像素光照"><a href="#6-5-2-逐像素光照" class="headerlink" title="6.5.2 逐像素光照"></a>6.5.2 逐像素光照</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders/Chapter <span class="number">6</span>/Specular Pixel-Level&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Diffuse(&quot;Diffuse&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		_Specular(&quot;Specular&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//用于控制材质的高光反射颜色</span></span><br><span class="line">		_Gloss(&quot;Gloss&quot;,Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span><span class="comment">//用于控制高光区域的大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags&#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">			fixed4 _Diffuse;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;<span class="comment">//为了使用Properties中声明的属性</span></span><br><span class="line"></span><br><span class="line">			struct a2v&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				fixed3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123;<span class="comment">//顶点着色器只需要计算世界空间下的法线方向和顶点坐标，并传递给片元着色器即可</span></span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.worldNormal = mul(v.normal,(float3x3)unity_WorldToObject);</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal,worldLightDir));</span><br><span class="line">				fixed3 reflectDir = <span class="built_in">normalize</span>(<span class="built_in">reflect</span>(-worldLightDir,worldNormal));</span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(saturate(<span class="built_in">dot</span>(reflectDir,viewDir)),_Gloss);</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时得到了更加平滑的高光效果，实现了一个完整的Phong光照模型</p>
<p>6.5.3 Blinn-Phong 光照模型</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders/Chapter <span class="number">6</span>/Specular BlinnPhong&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Diffuse(&quot;Diffuse&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		_Specular(&quot;Specular&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//用于控制材质的高光反射颜色</span></span><br><span class="line">		_Gloss(&quot;Gloss&quot;,Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span><span class="comment">//用于控制高光区域的大小</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags&#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">			fixed4 _Diffuse;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;<span class="comment">//为了使用Properties中声明的属性</span></span><br><span class="line"></span><br><span class="line">			struct a2v&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				fixed3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123;<span class="comment">//顶点着色器只需要计算世界空间下的法线方向和顶点坐标，并传递给片元着色器即可</span></span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.worldNormal = mul(v.normal,(float3x3)unity_WorldToObject);</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="built_in">dot</span>(worldNormal,worldLightDir));</span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">				fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);<span class="comment">//由光照方向和观察方向得到h向量</span></span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(worldNormal,halfDir)),_Gloss);<span class="comment">//更改为Blinn模型计算</span></span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Blinn光照模型的高光反射部分看起来更大更亮；在实际渲染中，绝大多数情况下我们都会选择该模型；</p>
<p>但是这两种模型都是经验模型；</p>
<h3 id="6-6-Unity内置函数"><a href="#6-6-Unity内置函数" class="headerlink" title="6.6 Unity内置函数"></a>6.6 Unity内置函数</h3><p>UnityCG.cginc里提供了一些内置函数：</p>
<table>
<thead>
<tr>
<th align="left">函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">float3 WorldSpaceViewDir(float4 v) <strong>√</strong></td>
<td>输入一个模型空间的顶点位置，返回世界空间中从该点到摄像机的观察方向（内部实现使用了下一个函数）</td>
</tr>
<tr>
<td align="left">float3 UnityWorldSpaceViewDir(float4 v) <strong>√</strong></td>
<td>输入一个世界空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td align="left">float3 ObjSpaceViewDir(float4 v)<strong>√</strong></td>
<td>输入一个模型空间中的顶点位置，返回模型空间中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td align="left">float3 WorldSpaceLightDir(float4 v)</td>
<td><strong>仅可用于前向渲染中</strong>，输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向，内部实现使用了下一个函数，没有归一化</td>
</tr>
<tr>
<td align="left">float3 UnityWorldSpaceLightDir(float4 v)</td>
<td><strong>仅可用于前向渲染中</strong>，输入一个世界空间中的顶点位置，返回世界空间中从该点到光源的光照方向，没有归一化</td>
</tr>
<tr>
<td align="left">float3 ObjSpaceLightDir(float4 v)</td>
<td><strong>仅可用于前向渲染中</strong>，输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向，没有归一化</td>
</tr>
<tr>
<td align="left">float3 UnityObjectToWorldNormal(float3 norm) <strong>√</strong></td>
<td>把法线方向从模型空间转换到世界空间中</td>
</tr>
<tr>
<td align="left">float3 UnityObjectToWorldDir(float3 dir) <strong>√</strong></td>
<td>把方向矢量从模型空间变换到世界空间中</td>
</tr>
<tr>
<td align="left">float3 UnityWorldToObjectDir(float3 dir) <strong>√</strong></td>
<td>把方向矢量从世界空间变换到模型空间中</td>
</tr>
</tbody></table>
<p>上述九个函数中，打对勾的五个已经掌握了内部实现，关于光照的函数只能用于前向渲染，这样才能让一些内置变量正确赋值；</p>
<p>这些函数都没有保证返回的是单位矢量，因此我们需要使用前将其归一化；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.worldNormal = mul(v.normal,(float3x3)unity_WorldToObject);<span class="comment">//使用矩阵计算世界空间下的法线方向</span></span><br><span class="line">o.worldNormal = UnityObjectToWorldNormal(v.normal);<span class="comment">//使用Unity提供的函数计算世界空间下的法线方向</span></span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<span class="comment">//使用世界空间中摄像机位置及物体位置计算视角方向</span></span><br><span class="line">fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));<span class="comment">//使用Unity提供的函数获得世界空间的摄像机视角方向</span></span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<span class="comment">//使用关键字获得第一个平行光的方向</span></span><br><span class="line">fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<span class="comment">//使用Unity提供的函数获得世界空间的光照方向</span></span><br></pre></td></tr></table></figure>

<p>关于光照的内置函数，Unity帮我们处理了不同种类光源的情况；</p>
<h2 id="第七章-基础纹理"><a href="#第七章-基础纹理" class="headerlink" title="第七章 基础纹理"></a>第七章 基础纹理</h2><p>使用<strong>纹理映射技术</strong>，我们可以把一张图贴在模型表面，逐纹素(与像素区分)的控制模型的颜色；</p>
<p>由于OpenGL和DirectX在二维空间中有坐标系差异，OpenGL里，原点位于左下角，而DirectX的原点位于左上角，Unity可以为我们处理这个差异问题，不过Unity使用的空间是符合OpenGL传统的；</p>
<p>顶点UV坐标（又称纹理映射坐标，u为横向坐标，v为纵向坐标）的范围通常被归一化到[0,1]内，但是<strong>纹理采样</strong>时使用的纹理坐标不一定在[0,1]范围内；此时，渲染引擎如何采样将关系到<strong>纹理的平铺模式</strong>；</p>
<p>本章着重讲述纹理采样的原理，实现的Shader不能直接应用，缺少阴影、光照衰减等效果（第九章会有完整实现）</p>
<h3 id="7-1-单张纹理"><a href="#7-1-单张纹理" class="headerlink" title="7.1 单张纹理"></a>7.1 单张纹理</h3><p>我们通常会使用一张纹理来代替物体的<strong>漫反射颜色</strong></p>
<h4 id="7-1-1-实践"><a href="#7-1-1-实践" class="headerlink" title="7.1.1 实践"></a>7.1.1 实践</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders/Chapter <span class="number">7</span>/Single Texture&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color(&quot;Color Tint&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//控制纹理的整体色调</span></span><br><span class="line">		_MainTex(&quot;Main Tex&quot;,<span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//声明了一个纹理，white是纹理的名字，花括号为其初始值</span></span><br><span class="line">		_Specular(&quot;Specular&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		_Gloss(&quot;Gloss&quot;,Range(<span class="number">8.0</span>,<span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;<span class="comment">//在Unity中，需要使用纹理名_ST的方式来声明某个纹理的属性，ST是缩放和平移的缩写, .xy存放的是缩放值，.zw存放的是平移值；</span></span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">			struct a2v&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 texcoord : TEXCOORD0;<span class="comment">//存放模型的第一组纹理坐标</span></span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">				float2 uv : TEXCOORD2;<span class="comment">//用于存储纹理变量</span></span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">				o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<span class="comment">//首先用缩放属性对顶点纹理坐标进行缩放，然后使用偏移属性对结果平移，来得到最终的纹理坐标</span></span><br><span class="line">				<span class="comment">//o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);//内置函数实现上述过程</span></span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">				<span class="comment">//计算了世界空间下的法线方向和光照方向</span></span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">				<span class="comment">//使用tex2D函数对纹理采样，第一个参数是需要采样的纹理，第二个参数是float2类型的纹理坐标，他将返回计算得到的纹素值，我们将其与颜色属性相乘来作为材质的反射率</span></span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<span class="comment">//将反射率与环境光照相乘得到环境光部分</span></span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(worldNormal,worldLightDir));</span><br><span class="line">				<span class="comment">//计算漫反射部分，albedo代替了之前声明的默认属性</span></span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">				fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(worldNormal,halfDir)),_Gloss);</span><br><span class="line">				<span class="comment">//计算高光反射部分</span></span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-1-2-纹理的属性"><a href="#7-1-2-纹理的属性" class="headerlink" title="7.1.2 纹理的属性"></a>7.1.2 纹理的属性</h4><p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220520103706559.png" alt="纹理属性面板"></p>
<p>Texture Type 纹理类型，<strong>合适的类型</strong>可以为Unity Shader传递正确的纹理</p>
<p>Wrap Mode 决定了当纹理坐标超过[0,1]范围后将会<strong>如何被平铺</strong>：</p>
<ul>
<li>Repeat模式：他的整数部分将会被舍弃，直接使用小数部分采样，这样的结果是纹理会不断重复</li>
<li>Clamp模式：会对纹理坐标截取到0和1，超过范围的部分将会截取到边界值，形成一个条形结构</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"><span class="comment">//首先用缩放属性对顶点纹理坐标进行缩放，然后使用偏移属性对结果平移，来得到最终的纹理坐标</span></span><br><span class="line"><span class="comment">//o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);//内置函数实现上述过程</span></span><br></pre></td></tr></table></figure>

<p>其中这一步变换是必要的</p>
<p>Filter Mode 决定了当纹理由于变换而产生拉伸时将会采用哪种滤波模式，它支持三种模式：Point,Bilinear,Trilinear，这三种情况滤波效果依次提升，但耗费的性能也依次增大，纹理滤波会影响<strong>放大或缩小纹理时得到的图片质量</strong>；</p>
<p>纹理缩小的过程更加复杂，此时原纹理中的多个像素将会对应一个目标像素，其复杂的原因在于我们需要处理抗锯齿；</p>
<p>一个最常使用的方法是<strong>多级渐远纹理(mipmapping)<strong>技术（mip是拉丁文的缩写，意思是“在一个小空间中有许多东西”），该技术将原纹理</strong>提前用滤波处理来得到很多更小的图像</strong>，形成了一个图像金字塔，每一层都是对上一层图像降采样的结果，这样在实时运行时就能快速得到结果像素，缺点就是<strong>需要额外的空间储存</strong>这些多级渐远纹理，在Unity中，我们将纹理类型选择Advanced，再勾选Generate Mip Maps即可开启；</p>
<p>在内部实现上，Point模式使用了<strong>最近邻(nearest neighbor)滤波</strong>，放大或缩小时，他的采样像素数目通常为1，因此会有一种像素风格的效果；Bilinear使用了线性滤波，对于每个目标像素，他会找到4个临近像素，然后对他们进行线性插值混合后得到像素，因此图像看起来被模糊了；Trilinear滤波几乎和Bilinear一样，但是他会在多级渐远纹理之间混合，即如果没有使用该技术，我们就无需打开Trilinear；</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220520111214812.png" alt="设置和展示"></p>
<p>纹理的最大尺寸和纹理模式：如果导入的纹理大小超过了Max Texture Size中的设置值，那么Unity将会把该纹理缩放为这个最大分辨率，导入的纹理可以是非正方形的，但长宽应该是2的幂，否则会占用更多的内存空间，GPU读取的速度也会下降；</p>
<p>Format决定了Unity内部使用哪种格式来存储纹理（如果将纹理类型设置成Advanced则这里会有更多可选），使用的纹理精度越高(如Truecolor)，占用内存越大，得到的效果也越好，最下方可以看到占用的内存空间，为了节约内存，我们应该对于不需要很高精度的纹理（如漫反射颜色的纹理）尽量使用压缩格式。</p>
<h2 id="7-2-凹凸映射"><a href="#7-2-凹凸映射" class="headerlink" title="7.2 凹凸映射"></a>7.2 凹凸映射</h2><p>凹凸映射的目的是使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节，这种方法<strong>不会真的改变模型的顶点位置</strong>；</p>
<p>两种方法实现：</p>
<ul>
<li>高度映射：使用一张高度纹理来模拟表面位移，然后得到一个修改后的法线值；</li>
<li>法线映射：使用一张法线纹理来直接存储表面法线；（凹凸映射和法线映射经常被当成相同的技术）</li>
</ul>
<h3 id="7-2-1-高度纹理"><a href="#7-2-1-高度纹理" class="headerlink" title="7.2.1  高度纹理"></a>7.2.1  高度纹理</h3><p>使用一张高度图来实现凹凸映射，高度图中存储的是强度值，表示模型表面局部的海拔高度，颜色越浅表明该位置越凸，好处是非常直观，缺点是计算复杂，实时计算时不能直接得到表面法线，而是需要由像素的灰度值计算而得；</p>
<p>高度图经常会和法线映射一起使用，用于给出表面凹凸的额外信息，也就是说，我们通常会使用法线映射来修改光照；</p>
<h3 id="7-2-2-法线纹理"><a href="#7-2-2-法线纹理" class="headerlink" title="7.2.2 法线纹理"></a>7.2.2 法线纹理</h3><p>法线纹理中存储的是表面的法线方向，由于法线方向的分量范围在[-1,1]，而像素的分量范围为[0,1]，因此需要一个映射来构建法<strong>线纹理图</strong>（那张图片的显示）：<br>$$<br>pixel &#x3D; (normal + 1)&#x2F;2<br>$$<br>因此我们在shader中对法线纹理采样之后，需要进行一次反映射处理来得到原来的法线方向：<br>$$<br>normal &#x3D; pixel*2-1<br>$$<br>但方向是相对于坐标空间来说的，那么， 法线纹理中存储的法线方向在哪个坐标空间中？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-934e15a89536b8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt="img"></p>
<p>​															左：模型空间下的法线纹理 右：切线空间下的法线纹理</p>
<p><strong>模型空间的法线纹理</strong></p>
<p>将修改后的模型空间中的表面法线存储在一张纹理中；</p>
<p>模型空间下的法线纹理看起来五颜六色，因为模型空间中，每个点存储的法线方向是各异的，对于(0,1,0)，映射到纹理中就变成了(0.5,1,0.5)浅绿色；</p>
<p><strong>切线空间的法线纹理</strong></p>
<p>对于模型的每个顶点，都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而z轴是顶点的法线方向（n），x轴是顶点的切线方向（t），而y轴可由法线和切线叉积而得，也被称为是副切线或副法线（b）；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-43322de5a6458f27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp" alt="img"></p>
<p>使用模型空间存储法线的优点：</p>
<ul>
<li>实现简单，更加直观，不需要模型原始的法线和切线信息，生成他非常简单；而如果要生成切线空间下的法线纹理，由于模型的切线一般是和UV方向相同，因此想要得到效果比较好的法线映射就要求纹理映射也是连续的；</li>
<li>在纹理坐标的缝合处和尖锐的边角部分，可见的突变（缝隙较少），即可以提供平滑的边界；</li>
</ul>
<p>使用切线空间存储的优点：</p>
<ul>
<li>自由度很高，模型空间下的法线纹理记录的是<strong>绝对法线信息</strong>，仅可用于创建它时的那个模型，应用到其他模型上效果就完全错误了，而切线空间下的法线纹理记录的是相对法线信息，这意味着，即便把该纹理应用到一个完全不同的网格上，也可以得到一个合理的结果；</li>
<li>可进行UV动画，比如，我们可以移动一个纹理的UV坐标来实现一个凹凸移动的效果，这种UV动画在水和岩浆这种类型的物体上会用到；</li>
<li>可以重用法线纹理。比如，一个砖块，我们仅使用一张法线纹理就可以用到所有的六个面；</li>
<li>可压缩，由于切线空间下的法线纹理中的法线的Z方向总是正方向，因此我们可以仅存储XY方向，而推导得到Z方向，而模型空间下的法线纹理由于每个方向都是可能的，因此必须存储三个方向的值，不可压缩；</li>
</ul>
<p>我们需要在计算光照模型中统一各个方向矢量所在的坐标空间。由于法线纹理中存储的法线是切线空间下的方向，因此我们通常有两种选择：</p>
<ul>
<li>在切线空间下进行光照计算，此时需要把光照方向、视角方向变换到切线空间下</li>
<li>在世界空间下进行光照计算，需要把采样得到的法线方向变换到世界空间下再和世界空间下的光照方向和视角方向进行计算；</li>
</ul>
<p>效率上来说，第一种方法优于第二种方法，因为我们可以在顶点着色器汇总就完成对光照方向和视角方向的变换，而第二种方法由于要先对法线纹理进行采样，所以变换过程必须在片元着色器中实现，这意味着我们需要在片元着色器中进行一次矩阵操作；</p>
<p>但从通用性角度来说，第二种方法要优于第一种方法，因为有时我们需要在世界空间下进行一些计算，例如在使用Cubemap进行环境映射时，我们需要使用世界空间下的反射方向对Cubemap进行采样，如果同时需要进行法线映射，我们就需要把法线方向变换到世界空间下；</p>
<h4 id="在切线空间下计算"><a href="#在切线空间下计算" class="headerlink" title="在切线空间下计算"></a>在切线空间下计算</h4><p>基本思路是在片元着色器中通过纹理采样得到切线空间下的法线，然后再与切线空间下的视角方向、光照方向等进行计算，得到最终的光照结果；为此，我们首先需要在顶点着色器中把视角方向和光照方向从模型空间变换到切线空间中，即我们需要知道从模型空间到切线空间的变换矩阵；这个变换矩阵的逆矩阵，即从切线空间到模型空间的矩阵是非常容易求得的，我们在顶点着色器中按切线(x)，副切线(y)，法线(z)的顺序按列排列即可得到（如果一个变换中仅存在平移和旋转变换，那么这个变换的逆矩阵就等于他的转置矩阵，而从切线空间到模型空间的变换符合）因此我们将该矩阵转置即其逆矩阵，即切线，副切线，法线按行排列即可得到；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In Tangent Space&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125; <span class="comment">//bump是Unity内置的法线纹理，当没有提供任何法线纹理时，bump就对应了模型自带的法线信息</span></span><br><span class="line">		_BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span> <span class="comment">//用于控制凹凸程度，为0时，意味着该法线纹理不会对光照产生任何影响</span></span><br><span class="line">		_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">			float4 _BumpMap_ST;</span><br><span class="line">			<span class="type">float</span> _BumpScale;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT; </span><br><span class="line">				<span class="comment">//使用TANGENT语义来描述float4类型的tangent变量，来把顶点的切线方向填充到该变量中，和法线方向不同，tangent是float4类型，因为需要w分量来决定切线空间中的第三个坐标轴副切线的方向性</span></span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float4 uv : TEXCOORD0;<span class="comment">//设置为float4类型来存储两张文理，xy分量存储了_MainTex的纹理坐标，zw分量存储了_BumpMap的纹理坐标</span></span><br><span class="line">				float3 lightDir: TEXCOORD1;</span><br><span class="line">				float3 viewDir : TEXCOORD2;<span class="comment">//添加两个变量来存储变换后的光照和视角方向</span></span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">				o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 计算副切线，因为切线和法线方向都垂直的方向有两个，w决定了我们使用哪个方向，因此使用w分量和切线，法线的叉积结果相乘</span></span><br><span class="line"><span class="comment">//				float3 binormal = cross( normalize(v.normal), normalize(v.tangent.xyz) ) * v.tangent.w;</span></span><br><span class="line"><span class="comment">//				// 构造一个矩阵，将向量从模型空间转换到切线空间</span></span><br><span class="line"><span class="comment">//				float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span></span><br><span class="line">				</span><br><span class="line">				TANGENT_SPACE_ROTATION;<span class="comment">//该内置宏可以直接计算得到rotation变换矩阵</span></span><br><span class="line">				</span><br><span class="line">				o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">				o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;<span class="comment">// 将光照方向和视角方向变换到切线空间</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;<span class="comment">//片元着色器只需要采样得到切线空间下的法线方向，再在切线空间下进行光照计算即可				</span></span><br><span class="line">				fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">				fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line">				</span><br><span class="line">				fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">				<span class="comment">//对法线纹理进行采样，tex2D函数对纹理采样，第一个参数是需要采样的纹理，第二个参数是float2类型的纹理坐标，他将返回计算得到的纹素值</span></span><br><span class="line">				fixed3 tangentNormal;</span><br><span class="line">				<span class="comment">// 如果在Unity里没有把该法线纹理的类型设置成Normal map,就要在代码中手动进行：</span></span><br><span class="line"><span class="comment">//				tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;//首先把其xy分量映射回法线方向，然后乘以_BumpScale来得到tangentNormal的xy分量</span></span><br><span class="line"><span class="comment">//				tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));//由于法线都是单位矢量，因此z分量可以由xy计算而得</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 如果已经标识过Normal map，上述方法就会错误，因为此时_BumpMap的rgb分量并不再是切线空间下法线方向的xyz值了，此时可以使用内置函数得到正确的法线方向；</span></span><br><span class="line">				tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">				tangentNormal.xy *= _BumpScale;</span><br><span class="line">				tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">				</span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));</span><br><span class="line"></span><br><span class="line">				fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="在世界空间下计算"><a href="#在世界空间下计算" class="headerlink" title="在世界空间下计算"></a>在世界空间下计算</h4><p>我们需要在片元着色器中把法线方向从切线空间变换到世界空间下，这种方法的基本思想是：在顶点着色器中计算从切线空间到世界空间的变换矩阵，并把它传递给片元着色器；最后再片元着色器中把法线纹理中的法线方向从切线空间变换到世界空间下即可，尽管这种方法需要更多的计算，但在需要使用Cubemap进行环境映射等情况下，我们就需要使用这种方法；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">7</span>/Normal Map In World Space&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">		_BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">			float4 _BumpMap_ST;</span><br><span class="line">			<span class="type">float</span> _BumpScale;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float4 uv : TEXCOORD0;</span><br><span class="line">				float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">				float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">				float4 TtoW2 : TEXCOORD3;</span><br><span class="line">				<span class="comment">//一个插值寄存器最多只能存储float4大小的变量，对于矩阵这样的变量，我们可以按行拆成多个变量再进行存储，TtoW0/TtoW1/TtoW2就是依次存储了切线空间到世界空间变换矩阵的每一行</span></span><br><span class="line">				<span class="comment">//实际上对于方向矢量的变换只需要使用3*3矩阵，但是为了充分利用插值寄存器的存储空间，我们把世界空间下的顶点位置存储在这些变量的w分量中；</span></span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">				o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line">				</span><br><span class="line">				float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">				fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">				fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">				fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Compute the matrix that transform directions from tangent space to world space</span></span><br><span class="line">				<span class="comment">// Put the world position in w component for optimization</span></span><br><span class="line">				o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">				o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">				o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<span class="comment">// 从w分量中构建世界空间下的坐标	</span></span><br><span class="line"></span><br><span class="line">				fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));<span class="comment">//使用内置函数得到世界空间下的光照和视角方向</span></span><br><span class="line">				</span><br><span class="line">				fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<span class="comment">//对法线纹理进行采样和解码</span></span><br><span class="line">				bump.xy *= _BumpScale;<span class="comment">//使用_BumpScale参数对其进行缩放</span></span><br><span class="line">				bump.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(bump.xy, bump.xy)));</span><br><span class="line">				</span><br><span class="line">				bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));<span class="comment">//使用存储的变换矩阵把法线变换到世界空间下</span></span><br><span class="line">				</span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line"></span><br><span class="line">				fixed3 halfDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, halfDir)), _Gloss);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-3-渐变纹理"><a href="#7-3-渐变纹理" class="headerlink" title="7.3 渐变纹理"></a>7.3 渐变纹理</h3><p>在开始，我们在渲染中使用纹理是为了定义一个物体的颜色，但后来人们发现，<strong>纹理其实可以用于存储任何表面属性</strong>；一种常见的用法就是使用渐变纹理来控制漫反射光照的结果，在之前计算漫反射光照时，我们都是使用表面法线和光照方向的点积结果与材质的反射率相乘来得到表面的漫反射光照，但有时，我们需要更加灵活地控制光照结果。这种技术在V社的《军团要塞 2》中提出，他们用这种技术来渲染游戏中具有插画风格的角色；</p>
<p>在现在很多卡通风格的渲染中都使用了一种基于冷到暖色调的着色技术，可以保证物体的轮廓线相比于之前使用的传统漫反射光照更加明显；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-6f50df6dfbe3f7cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<ul>
<li>在左边的图中使用紫色到浅黄色的渐变纹理；</li>
<li>中间为黑色逐渐向浅灰色靠拢，而中间的分界线部分微微发红，这种和《军团要塞2》中渲染人物使用的渐变纹理类似；</li>
<li>右侧的渐变纹理则通常被用于卡通风格的渲染，这种渐变纹理中的色调通常是突变的，即没有平滑过渡，来模拟卡通中的阴影色块。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shader Book/Ramp Texture&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color(&quot;Color Tint&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">//控制纹理的整体色调</span></span><br><span class="line">		_RampTex(&quot;Ramp Tex&quot;,<span class="number">2</span>D) = &quot;white&quot;&#123;&#125;<span class="comment">//声明了一个纹理，white是纹理的名字，花括号为其初始值</span></span><br><span class="line">		_Specular(&quot;Specular&quot;,Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		_Gloss(&quot;Gloss&quot;,Range(<span class="number">8.0</span>,<span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _RampTex;</span><br><span class="line">			float4 _RampTex_ST;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">			struct a2v&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">				float2 uv : TEXCOORD2;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v)&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.texcoord,_RampTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				</span><br><span class="line">				fixed halfLambert = <span class="number">0.5</span> * <span class="built_in">dot</span>(worldNormal,worldLightDir) + <span class="number">0.5</span>;<span class="comment">//计算半兰伯特部分</span></span><br><span class="line">				fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">				<span class="comment">//使用纹理对漫反射颜色进行采样，再把从渐变纹理采样得到的颜色和材质颜色相乘得到最终的漫反射颜色</span></span><br><span class="line">				<span class="comment">//tex2D函数对纹理采样，第一个参数是需要采样的纹理，第二个参数是float2类型的纹理坐标，他将返回计算得到的纹素值</span></span><br><span class="line"></span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * diffuseColor;<span class="comment">//_LightColor0.rgb为平行光的颜色,若没有该行则物体颜色不受场景平行光影响</span></span><br><span class="line"></span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">				fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)),_Gloss);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漫反射部分更改了采样方式，环境光不再计算反射率；</p>
<p>需要注意，渐变纹理的Wrap Mode需要设为Clamp，以防止对纹理进行采样时由于浮点数精度而造成的问题；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-98b07f1bb6eaee19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500/format/webp" alt="img"></p>
<h3 id="7-4-遮罩纹理"><a href="#7-4-遮罩纹理" class="headerlink" title="7.4 遮罩纹理"></a>7.4 遮罩纹理</h3><p>遮罩允许我们保护某些区域，使他们免于某些修改；例如在之前的实现中，我们都是把高光反射应用到模型表面的所有地方，即所有的像素都使用同样大小的高光强度和高光指数。但有时，我们希望模型表面某些区域的反光强烈一些，而某些区域弱一些；<strong>为了得到更加细腻的效果，我们就可以使用一张遮罩纹理来控制光照。</strong></p>
<p>另一种常见的应用是在制作地形材质时需要混合多张图片，例如表现草地的纹理、表现石子的纹理、表现裸露土地的纹理等， <strong>使用遮罩纹理可以控制如何混合这些纹理；</strong></p>
<p>使用遮罩纹理：</p>
<p>通过采样得到遮罩纹理的纹素值，然后使用其中某个或某几个通道的值（例如texel.r）来与某种表面属性相乘，这样，当该通道的值为0时，可以保护表面不受该属性的影响；</p>
<p><strong>使用遮罩纹理可以让美术人员在像素级别控制模型表面的各种性质</strong></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Mask Texture&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;<span class="keyword">while</span>&quot; &#123;&#125;</span><br><span class="line">		_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">		_BumpScale (&quot;Bump Scale&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_SpecularMask (&quot;Specular Mask&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//高光反射遮罩纹理</span></span><br><span class="line">		_SpecularScale (&quot;Specular Scale&quot;, Float) = <span class="number">1.0</span><span class="comment">//控制遮罩影响度的系数</span></span><br><span class="line">		_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="comment">//主纹理_MainTex,法线纹理_BumpMap和遮罩纹理_SpecularMask共同使用该纹理属性变量，这意味着我们在材质面板中修改朱文丽的平铺和偏移系数会同时影响3个纹理的采样</span></span><br><span class="line">			<span class="comment">//如果每个纹理都使用一个单独的属性变量，那么随着纹理数目的增加，顶点着色器中可以使用的插值寄存器会快速被占满；</span></span><br><span class="line">			<span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">			<span class="type">float</span> _BumpScale;</span><br><span class="line">			<span class="type">sampler2D</span> _SpecularMask;</span><br><span class="line">			<span class="type">float</span> _SpecularScale;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;</span><br><span class="line"></span><br><span class="line">			struct a2v&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			struct v2f&#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				float3 lightDir : TEXCOORD1;</span><br><span class="line">				float3 viewDir : TEXCOORD2;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">				o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line"></span><br><span class="line">				TANGENT_SPACE_ROTATION;</span><br><span class="line">				o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">				o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				fixed3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">				fixed3 tangentViewDir = <span class="built_in">normalize</span>(i.viewDir);</span><br><span class="line"></span><br><span class="line">				fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap,i.uv));</span><br><span class="line">				tangentNormal.xy *= _BumpScale;</span><br><span class="line">				tangentNormal.z = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - saturate(<span class="built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line"></span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<span class="comment">//环境光照部分</span></span><br><span class="line"></span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));<span class="comment">//漫反射光照部分</span></span><br><span class="line"></span><br><span class="line">				fixed3 halfDir = <span class="built_in">normalize</span>(tangentLightDir + tangentViewDir);</span><br><span class="line"></span><br><span class="line">				fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">				<span class="comment">//对遮罩纹理进行采样，由于本书中使用的遮罩纹理每个纹素的rgb分量都相同，表明了该点对应的高光反射强度，在这里选用r分量来计算掩码值</span></span><br><span class="line">				<span class="comment">//然后将得到的掩码值和——SpecularScale相乘，一起控制高光反射的强度</span></span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line">				<span class="comment">//最后共同计算高光反射部分</span></span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中使用的遮罩纹理有很多空间被浪费了——他的rgb分量存储的都是同一个值，在实际的游戏制作中，遮罩纹理已经不止限于保护某些区域使他们免于某些修改，而是可以存储任何我们希望<strong>逐像素控制的表面属性</strong>，比如我们可以把高光反射的强度存储在R通道，边缘光照的强度存储在G通道，高光反射的指数部分存储在B通道，最后把自发光强度存储在A通道；</p>
<p>比如在《DOTA2》中，开发人员为每个模型使用了四张纹理，一张用于定义模型颜色，一张用于定义表面法线，另外两张则都是遮罩纹理，这样，两张遮罩纹理提供了共8种额外的表面属性，这使得游戏中的人物材质自由度很强，可以支持很多的高级的模型属性；</p>
<h2 id="第八章-透明效果"><a href="#第八章-透明效果" class="headerlink" title="第八章 透明效果"></a>第八章 透明效果</h2><p>在实时渲染中要实现透明效果，通常会在渲染模型时控制它的<strong>透明通道</strong>；当开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值之外，它还有另一个属性——透明度，该值为1时像素完全不透明，为0时像素完全不会显示；</p>
<p>通常有两种方法实现透明效果：</p>
<ul>
<li><strong>透明度测试</strong>：这是一种极端的机制，只要一个片元的透明度不满足条件（通常是小于某个阈值），那么它对应的片元就会被舍弃，被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就按照普通的不透明物体来处理，进行深度测试及写入；因此他只有全透明和不透明两种极端的效果；</li>
<li><strong>透明度混合</strong>：它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲的颜色值进行混合，得到新的颜色；需要注意的是，透明度混合需要关闭深度写入（即将深度值更新到深度缓冲中），但是没有关闭深度测试（即渲染时比较当前深度值和深度缓冲中的深度值），这意味着当一个不透明物体出现在一个透明物体前，而我们先渲染了不透明物体，他仍然可以正常的遮挡住透明物体；同时这也说明，<strong>对于透明度混合，深度缓冲是只读的</strong>；</li>
</ul>
<h3 id="8-1-渲染顺序"><a href="#8-1-渲染顺序" class="headerlink" title="8.1 渲染顺序"></a>8.1 渲染顺序</h3><p>由于关闭了透明物体的深度写入，若A物体半透明，B物体不透明，且B在A后方，当先渲染A的时候无法修改深度缓冲，则B深度测试的结果是直接写入颜色缓冲，那么会直接覆盖A的颜色，B就出现在了A的前面；因此<strong>渲染顺序在关闭了深度写入后显得尤为重要</strong>；</p>
<p>因此，渲染引擎一般都会先对物体进行排序，再渲染，常用的方法是：</p>
<ol>
<li>先渲染所有不透明物体，并开启他们的深度测试和深度写入；</li>
<li>把半透明物体按他们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启他们的深度测试，但关闭深度写入；</li>
</ol>
<p>但是问题没有解决，若存在三个物体循环重叠的情况，那么将无法确定距离摄像机的远近：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-8495001095b7a8a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/404/format/webp" alt="img"></p>
<p>或者我们应该通过哪个深度对物体进行排序？红色点分别标明了网格上距离摄像机最近的点、最远的点以及网格中点：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-742d0b5d1f5b2dc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp" alt="img"></p>
<p>虽然存在这些情况，但是上述方式足够有效并且容易实现，因此大多数游戏引擎都使用了这种方法，为了减少错误的情况，我们可以尽可能让模型是凹面体，并且考虑将复杂的模型拆分成可以独立排序的子模型等；排序错误结果有时也不会非常糟糕，可以试着然透明通道更加柔和，使穿插看起来并不是那么明显；</p>
<h3 id="8-2-Unity-Shader的渲染顺序"><a href="#8-2-Unity-Shader的渲染顺序" class="headerlink" title="8.2 Unity Shader的渲染顺序"></a>8.2 Unity Shader的渲染顺序</h3><p>Unity为解决渲染顺序的问题，提供了<strong>渲染队列</strong>这一解决方案；我们可以使用SubShader的Queue标签来决定我们的模型将归于哪个渲染队列。Unity在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715112021624.png" alt="image-20220715112021624"></p>
<p>因此，如果我们想要通过透明度测试实现透明效果，代码中应该包含类似下方的代码：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">	Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &#125;</span><br><span class="line">	Pass&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想要通过透明度混合来实现透明效果：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">	Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &#125;</span><br><span class="line">	Pass &#123;</span><br><span class="line">		ZWrite Off</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，ZWrite Off 用于关闭深度写入，这里写在了Pass中，如果写在SubShader中，其下的所有Pass都会关闭深度写入；</p>
<h3 id="8-3-透明度测试"><a href="#8-3-透明度测试" class="headerlink" title="8.3 透明度测试"></a>8.3 透明度测试</h3><p>通常，我们会在片元着色器中使用clip函数来进行透明度测试:</p>
<p>void clip(float4 x); void clip(float3 x); void clip(float2 x); void clip(float1 x); void clip(float x);</p>
<p>参数：裁剪时使用的标量或矢量条件；</p>
<p>描述：如果给定参数的任何一个分量是负数，就会舍弃当前像素的输出颜色；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Alpha Test&quot;&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Cutoff (&quot;Alpha Cutoff&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.5</span></span><br><span class="line">		<span class="comment">//该参数用于决定我们调用clip进行透明度测试时使用的判断条件，其范围与纹理像素透明度范围相同</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Tags &#123;&quot;Queue&quot;=&quot;AlphaTest&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;TransparentCutout&quot;&#125;</span><br><span class="line">		<span class="comment">//Queue标签如上文所讲，RenderType标签可以让Unity把这个Shader归入到提前定义的组(TransparentCutout)中，以指明该Shader是一个使用了透明度测试的Shader；</span></span><br><span class="line">		<span class="comment">//IgnoreProjector设置为True，意味着这个Shader不会受到投影器(Projector)的影响</span></span><br><span class="line">		<span class="comment">//通常使用了透明度测试的Shader都应该在SubShader中设置这三个标签</span></span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			fixed _Cutoff;<span class="comment">//由于范围在[0,1]，可以使用fixed精度来存储</span></span><br><span class="line"></span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">				float2 uv : TEXCOORD2;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;<span class="comment">//最重要的透明度测试的代码在片元着色器中</span></span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">				</span><br><span class="line">				fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Alpha test</span></span><br><span class="line">				clip (texColor.a - _Cutoff);<span class="comment">//之前提到过的clip函数</span></span><br><span class="line">				<span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">//				if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span></span><br><span class="line"><span class="comment">//					discard;//discard指令可以剔除该片元</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//环境光照和漫反射光照部分，同之前</span></span><br><span class="line">				fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">	<span class="comment">//与之前的Diffuse和Specular不同，该默认的回调Shader不仅能够保证在我们编写的SubShader无法在当前显卡上工作时可以有合适的代替Shader,还可以保证使用透明度测试的物体可以正确的向其他物体投射阴影</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715145344645.png" alt="image-20220715145344645"></p>
<p>如图，透明度测试得到的效果很极端，只有透明和不透明，而且得到的透明效果在边缘往往参差不齐，有锯齿，这是因为在边界处纹理的透明度的变化精度问题，为了得到更加柔滑的透明度效果，就可以使用透明度混合；</p>
<h3 id="8-4-透明度混合"><a href="#8-4-透明度混合" class="headerlink" title="8.4 透明度混合"></a>8.4 透明度混合</h3><p>这种方法可以得到真正的半透明效果，它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色，但是透明度混合需要关闭深度写入，这使得我们需要非常小心物体的渲染顺序；</p>
<p>为了进行混合，我们需要使用Unity提供的混合命令——Blend。</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715153504861.png" alt="image-20220715153504861"></p>
<p>该节中我们使用 Blend SrcFactor DstFactor来进行混合，这个命令在设置混合因子的同时也开启的混合模式；</p>
<p>我们会把原颜色(该片元着色器产生的颜色)的混合因子SrcFactor设为SrcAlpha（源alpha的值），而目标颜色（已经存在于颜色缓冲中的颜色）的混合因子DstFactor设为OneMinusSrcAlpha(1 - source alpha)，这意味着，经过混合后新的颜色是(n-&gt;new，o-&gt;old)：<br>$$<br>DstColor_n &#x3D; SrcAlpha * SrcColor + (1 - SrcAlpha) * DstColor_o<br>$$</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/AlphaBlend&quot;&#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span><span class="comment">//替代原先的_Cutoff属性，用于在透明纹理的基础上控制整体的透明度；</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;<span class="comment">//同透明度测试</span></span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">			ZWrite Off<span class="comment">//关闭深度写入</span></span><br><span class="line">			Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">			<span class="comment">//开启混合模式，并设置原颜色(该片元着色器产生的颜色)的混合因子为SrcAlpha，目标颜色（已经存在于颜色缓冲中的颜色）的混合因子为OneMinusSrcAlpha，以得到正确的半透明效果</span></span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			fixed _AlphaScale;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">				float2 uv : TEXCOORD2;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">				</span><br><span class="line">				fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">				</span><br><span class="line">				fixed3 albedo = texColor.rgb * _Color.rgb;</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);<span class="comment">//设置了透明通道，只有Blend命令打开混合后，在这里设置才有意义，否则不会产生影响</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715162235258.png" alt="image-20220715162235258"></p>
<p>此时效果正常，但是关闭深度写入带来的问题仍然存在，当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格的时候，就会排序错误而产生错误的透明效果：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-752fa29869fc3272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/594/format/webp" alt="img"></p>
<p>这时，我们可以想办法重新利用深度写入，让模型可以像半透明物体一样淡入淡出；</p>
<h3 id="8-5-开启深度写入的半透明效果"><a href="#8-5-开启深度写入的半透明效果" class="headerlink" title="8.5 开启深度写入的半透明效果"></a>8.5 开启深度写入的半透明效果</h3><p>对于上节最后提到的问题，一种解决办法是<strong>使用两个Pass来渲染模型</strong>，第一个Pass开启深度写入，但不输出颜色，它的目的仅仅是为了把该模型的深度值写入深度缓冲中；第二个Pass进行正常的透明度混合，由于上一个Pass已经得到了逐像素的正确深度信息，该Pass就可以按照像素级别的深度排序结果进行透明渲染，而缺点就是多一个Pass会对性能造成影响；</p>
<p>使用这种办法，我们可以实现模型与他后面的背景混合的效果，但模型内部之间不会有任何真正的半透明效果；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Alpha Blending With ZWrite&quot;&#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_AlphaScale (&quot;Alpha Scale&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;<span class="comment">//该Pass只是为了把模型的深度信息写入深度缓冲中，从而剔除模型中被自身遮挡的片元</span></span><br><span class="line">			ZWrite On<span class="comment">//开启深度写入</span></span><br><span class="line">			ColorMask <span class="number">0</span><span class="comment">//该命令用于设置颜色通道的写掩码（write mask），他的语义为 ColorMask RGB | A | 0 | 其他任何R、G、B、A的组合，当其设为0时，意味着该Pass不写入任何颜色通道，即不会输出任何颜色</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			<span class="comment">//同8.4</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715164911127.png" alt="image-20220715164911127"></p>
<h3 id="8-6-ShaderLab的混合命令"><a href="#8-6-ShaderLab的混合命令" class="headerlink" title="8.6 ShaderLab的混合命令"></a>8.6 ShaderLab的混合命令</h3><p>混合命令还有其他用法，不仅可以用于透明度混合；</p>
<p>混合的原理：当片元着色器产生一个颜色的时候，可以选择与颜色缓存中的颜色进行混合，这样，混合就和两个操作数有关：<strong>源颜色</strong>和<strong>目标颜色</strong>。源颜色用S表示，指的是由片元着色器产生的颜色值，目标颜色用D表示，指的是从颜色缓冲中读取到的颜色值，对他们混合后得到的输出颜色用O表示，会重新写入颜色缓冲；（这些颜色都包含了RGBA四个通道而非仅有RGB）</p>
<p>在图形API中往往需要我们手动开启混合，比如OpenGL中glEnable(GL_BLEND)</p>
<h4 id="8-6-1-混合等式和参数"><a href="#8-6-1-混合等式和参数" class="headerlink" title="8.6.1 混合等式和参数"></a>8.6.1 混合等式和参数</h4><p>混合是一个逐片元的操作，而且不是可编程的，但是却高度可配置，我们可以设置混合时使用的运算操作、混合因子等来影响混合。</p>
<p>我们使用<strong>混合等式</strong>来计算S和D来得到输出颜色O，我们需要两个混合等式，一个用于混合RGB通道，一个用于混合A通道。当设置混合状态时，我们实际上设置的就是混合等式中的<strong>操作</strong>和<strong>因子</strong>；</p>
<p>默认情况下操作为加操作，在两个等式中每个等式有两个因子（一个用于和S相乘，一个用于和D相乘），因此一共需要4个因子；</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715173249223.png" alt="image-20220715173249223"></p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715173509967.png" alt="image-20220715173509967"></p>
<p>使用上面的指令设置时，RGB通道的混合因子和A通道的混合因子都是一样的，如果希望使用不同的参数混合A通道，可以使用</p>
<p>Blend SrcFactor DstFactor,SrcFactorA DstFactorA 指令</p>
<p>例如，如果我们想在混合后输出颜色的透明度值就是源颜色的透明度：</p>
<p>Blend SrcAlpha OneMinusSrcAlpha, One Zero</p>
<h4 id="8-6-2-混合操作"><a href="#8-6-2-混合操作" class="headerlink" title="8.6.2 混合操作"></a>8.6.2 混合操作</h4><p>上方的混合等式中，我们都是将混合因子计算的结果相加，我们也可以使用BlendOp BlendOperation命令，即<strong>混合操作命令</strong>：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715174311439.png" alt="image-20220715174311439"></p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715174325327.png" alt="image-20220715174325327"></p>
<p>混合操作命令通常和混合因子命令一起工作，不过使用Min或Max时，混合因子实际上不起作用；</p>
<h4 id="8-6-3-常见的混合类型"><a href="#8-6-3-常见的混合类型" class="headerlink" title="8.6.3 常见的混合类型"></a>8.6.3 常见的混合类型</h4><p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715174331741.png" alt="image-20220715174331741"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-5e87041b53eb6235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>没有设置操作时，默认为BlendOp Add；</p>
<h3 id="8-7-双面渲染的透明效果"><a href="#8-7-双面渲染的透明效果" class="headerlink" title="8.7 双面渲染的透明效果"></a>8.7 双面渲染的透明效果</h3><p>在之前实现的透明效果中，我们无法观察到正方体内部及其背面的形状，这是因为默认情况下渲染引擎剔除了物体背面的渲染图元，只渲染了物体的正面，如果我们想要得到双面渲染的结果，可以使用Cull指令来控制需要剔除哪个面的渲染图元：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cull Back | Front | Off</span><br></pre></td></tr></table></figure>

<ul>
<li>如果设置为Back，那么那些背对着摄像机的渲染图元就不会渲染，也是默认情况下的剔除状态；</li>
<li>如果为Front，朝向摄像机的不会渲染；</li>
<li>如果使用Off，则剔除功能会关闭，所有渲染图元都会渲染，需要渲染的图元数目会成倍增加，因此除非需要特殊效果，否则通常不会关闭剔除；</li>
</ul>
<p>对于透明度测试，只需添加一行代码即可实现双面渲染：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">	Tags  &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;</span><br><span class="line">	Cull Off<span class="comment">//关闭剔除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715175526495.png" alt="image-20220715175526495"></p>
<p>而对于透明度混合则复杂一些，因为关闭了深度写入，因此我们需要保证图元是从后往前渲染的，如果直接关闭剔除，我们就无法保证同一个物体的正面和背面图元的渲染顺序；</p>
<p>为此，我们将双面渲染的工作分成两个Pass，第一个Pass只渲染背面，第二个Pass只渲染正面，即可以保证背面总是在正面渲染之前渲染；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;<span class="comment">//该Pass只是为了把模型的深度信息写入深度缓冲中，从而剔除模型中被自身遮挡的片元</span></span><br><span class="line">    Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">    Cull Front</span><br><span class="line">    <span class="comment">//同8.4节</span></span><br><span class="line">&#125;</span><br><span class="line">Pass &#123;</span><br><span class="line">	Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">    Cull Back</span><br><span class="line">    <span class="comment">//同8.4节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220715181313998.png" alt="image-20220715181313998"></p>
<h2 id="第九章-更复杂的光照"><a href="#第九章-更复杂的光照" class="headerlink" title="第九章 更复杂的光照"></a>第九章 更复杂的光照</h2><p>在前文中，我们的场景中都仅有一个平行光光源，而实际上，我们会遇到更多更复杂的光源，同时我们需要得到阴影，本章将实现上述功能；</p>
<h3 id="9-1-Unity的渲染路径"><a href="#9-1-Unity的渲染路径" class="headerlink" title="9.1 Unity的渲染路径"></a>9.1 Unity的渲染路径</h3><p>在Unity里，<strong>渲染路径</strong>决定了光照是如何应用到Unity Shader的，如果要和光源打交道，我们需要为每个Pass指定它使用的渲染路径，这样才能得到光源和后处理的光照信息；也就是说，我们只有为Shader正确地选择和设置了需要的渲染路径，该Shader的光照计算才能被正确执行；</p>
<p>Unity支持多种渲染路径，在5.0之前主要有<strong>前向渲染路径</strong>，<strong>延迟渲染路径</strong>，<strong>顶点照明渲染路径</strong>三种；</p>
<p>而在Unity 5.0之后，顶点照明渲染路径被舍弃，同时新的延迟渲染路径替代了之前的延迟渲染路径；</p>
<p>大多数情况下，一个项目只使用一种渲染路径，可以在Other Setting里设置，默认选择的是前向渲染路径；但有时我们希望对不同摄像机渲染的物体使用不同的渲染路径，此时可以在摄像机的渲染路径设置中修改，来覆盖默认设置（即Use Player Settings）；不过当显卡不支持选择的渲染路径，就会自动使用低一级的渲染路径（延迟&gt;前向）；</p>
<p>完成设置后，我们就可以在Pass中使用<strong>LightMode标签</strong>指定该Pass使用的渲染路径：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220718121540732.png" alt="image-20220718121540732"></p>
<p>通俗来讲，指定渲染路径是我们和Unity的底层渲染引擎的一次重要的沟通，此时引擎会把光照属性按照该渲染路径的流程准备好备用，随后我们可以通过内置光照变量来访问这些属性，如果我们没有指定渲染路径，那么这些光照变量很可能不会被正确赋值；</p>
<h4 id="9-1-1-前向渲染路径"><a href="#9-1-1-前向渲染路径" class="headerlink" title="9.1.1 前向渲染路径"></a>9.1.1 前向渲染路径</h4><p>每进行一次完整的前向渲染，我们需要渲染该对象的渲染图元，并计算两个缓冲区的信息：一个是颜色缓冲区，一个是深度缓冲区。我们利用深度缓冲来决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。</p>
<p>前向渲染路径伪代码：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    <span class="keyword">for</span>(each primitive <span class="keyword">in</span> this model)&#123;</span><br><span class="line">        <span class="keyword">for</span>(each fragment covered by this primitive)&#123;</span><br><span class="line">            <span class="keyword">if</span>(failed <span class="keyword">in</span> depth test)&#123;</span><br><span class="line">                <span class="comment">//如果没有通过深度测试，说明该片元不可见</span></span><br><span class="line">                <span class="keyword">discard</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果该片元可见，就进行光照计算</span></span><br><span class="line">                float4 color = Shading(materialInfo,pos,normal,lightDir,viewDir);</span><br><span class="line">                <span class="comment">//更新帧缓冲</span></span><br><span class="line">                writeFrameBuffer(fragment, color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个逐像素光源，我们都需要进行上面一次完整的渲染流程，如果一个物体在多个逐像素光源的影响区域内，那么该物体就需要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在帧缓冲中把这些光照结果混合起来得到最终的颜色值。假设场景中有n个物体，每个物体受m个光源的影响，那么渲染整个场景一共需要n*m个Pass；因此渲染引擎通常会限制每个物体的逐像素光照的数目；</p>
<p>在Unity中，前向渲染路径有3种处理光照的方式：<strong>逐顶点处理</strong>、<strong>逐像素处理</strong>、<strong>球谐函数(Spherical Harmonics,SH)处理</strong>；而决定一个光源使用哪种处理模式取决于它的类型和渲染模式，<strong>光源类型</strong>指平行光、点光此类，而渲染模式指的是该光源是否为<strong>Important</strong>，如果我们设置为Important，意味着它将作为一个逐像素光源来处理；</p>
<p>在前向渲染中，当我们渲染一个物体时，Unity会根据场景中各个光源的设置以及这些光源对物体的影响程度(距离物体的远近，光照强度等)对这些光源进行一个<strong>重要度排序</strong>；其中一定数目的光源会按逐像素的方式处理，然后最多4个光源按逐顶点的方式处理，剩下的按SH处理：</p>
<ul>
<li>场景中最亮的平行光总是按逐像素处理；</li>
<li>渲染模式被设置成Not Important的光源，会按逐顶点或SH处理；</li>
<li>Important的光源逐像素处理；</li>
<li>若逐像素光源数量小于Quality Setting中的逐像素光源数量，会有更多的光源按照逐像素处理；</li>
</ul>
<p>前向渲染有Base Pass和Additional Pass两种Pass，即完成光照计算的地方：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-b9daa29decb2ae03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<ul>
<li>#pragma multi_compile_fwdbase&#x2F;fwdadd，这些编译指令保证Unity可以为相应类型的Pass生成所有需要的Shader变种，这些变种会处理不同条件下的渲染逻辑，例如是否使用光照贴图、当前处理哪种光源类型、是否开启了阴影等，同时Unity也会在背后声明相关的内置变量并传递到Shader中；因此这样设置也能确保我们能在相关Pass中得到一些正确的光照变量，例如光照衰减值等；</li>
<li>Base Pass中渲染的平行光默认是支持阴影的，而Additional Pass中渲染的光源在默认情况下是没有阴影效果的，但我们可以通过#pragma multi_compile_fwdadd_fullshadows代替原有指令来为点光和聚光灯开启阴影效果；</li>
<li>环境光和自发光也是在Base Pass中计算的，因为对于一个物体只需要计算一次；</li>
<li>在Additional Pass的渲染设置中，我们开启和设置了混合模式，这是因为我们希望每个Additional Pass可以与上一次的光照结果在帧缓存中进行叠加，从而最终得到有多个光照的渲染效果，通常情况下我们选择Blend One One；</li>
<li>对于前向渲染来说，一个Unity Shader通常会定义一个Base Pass（Base Pass也可以定义多次，例如需要双面渲染）以及一个Additional Pass，一个Base Pass仅会执行一次，而一个Additional Pass会根据影响该物体的其他逐像素光源的数目被多次调用；</li>
</ul>
<p>内置的光照变量和函数：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220718171852738.png" alt="image-20220718171852738"></p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220718172032168.png" alt="image-20220718172032168"></p>
<p>注：表中变量和函数并不完整</p>
<h4 id="9-1-2-顶点照明渲染路径"><a href="#9-1-2-顶点照明渲染路径" class="headerlink" title="9.1.2 顶点照明渲染路径"></a>9.1.2 顶点照明渲染路径</h4><p>顶点照明渲染路径是对硬件配置要求最少、运算性能最高，但得到效果最差的一种类型；不支持逐像素得到的效果，例如阴影、法线映射、高精度的高光反射等；<strong>在顶点照明渲染路径中实现的功能都可以在前向渲染路径中完成</strong>，</p>
<p>顶点照明渲染路径只是使用了逐顶点的方式计算光照；此时Unity只会填充那些，意味着我们不可以使用一些逐像素光照变量；</p>
<p>顶点照明渲染路径通常在一个Pass中就可以完成对物体的渲染，在这个Pass中会完成我们关心的所有光源对该物体的照明，并且按照逐顶点处理，这是Unity中最快速的渲染路径，并且具有最广泛的硬件支持；</p>
<p>在Unity中，我们可以在一个顶点照明的Pass中最多访问到8个逐顶点光源，如果影响该物体的光源数目小于8，数组中剩下的光源颜色会设置成黑色；</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220719150347996.png" alt="image-20220719150347996"></p>
<h4 id="9-1-3-延迟渲染路径"><a href="#9-1-3-延迟渲染路径" class="headerlink" title="9.1.3 延迟渲染路径"></a>9.1.3 延迟渲染路径</h4><p>前向渲染的问题是，当场景中包含大量实时光源时，前向渲染的性能会急速下降，对于重叠的多个光源，每执行一个Pass我们都需要重新渲染一遍物体，但很多计算实际上是重复的；</p>
<p>延迟渲染是一种更古老的渲染方法，因为前向渲染可能造成的瓶颈问题，近几年又流行起来；除了颜色缓冲和深度缓冲之外，延迟渲染会利用额外的缓冲区，<strong>这些缓冲区被统称为G(Geometry 几何学)缓冲</strong>，G缓冲区存储了我们所关心的表面（通常指离摄像机最近的表面）的其他信息，例如该表面的法线、位置、用于光照计算的材质属性等；</p>
<p>原理：</p>
<p>延迟渲染主要包含了两个Pass，在第一个Pass中，我们不进行光照计算，仅计算哪些片元可见，主要通过深度缓冲技术实现，如果片元可见，我们就把它的相关信息存储到G缓冲区中；然后在第二个Pass中，我们利用G缓冲区的片元信息(表面法线、视角方向、漫反射系数等)进行真正的光照计算：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Pass <span class="number">1</span>&#123;</span><br><span class="line">	<span class="comment">//第一个Pass不进行光照计算，只把光照计算需要的信息存储到G缓冲中</span></span><br><span class="line">	<span class="keyword">for</span>(each primitive <span class="keyword">in</span> this model)&#123;</span><br><span class="line">		<span class="keyword">for</span>(each fragment covered by this primitive)&#123;</span><br><span class="line">			<span class="keyword">if</span>(failed <span class="keyword">in</span> depth test)&#123;</span><br><span class="line">				<span class="comment">//如果没有通过深度测试，说明该片元不可见</span></span><br><span class="line">				<span class="keyword">discard</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//如果可见就把信息存储到G缓冲中</span></span><br><span class="line">				writeGBuffer(materialInfo, pos, normal);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pass <span class="number">2</span>&#123;</span><br><span class="line">    <span class="comment">//利用G缓冲中的信息进行光照计算</span></span><br><span class="line">    <span class="keyword">for</span>(each pixel <span class="keyword">in</span> the screen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(the pixel is valid)&#123;</span><br><span class="line">            <span class="comment">//如果该像素有效，则读取他G缓冲中的信息</span></span><br><span class="line">            readGBuffer(pixel, materialInfo, pos, normal);</span><br><span class="line">            <span class="comment">//根据读取到的信息进行光照计算</span></span><br><span class="line">            float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">            <span class="comment">//更新帧缓冲</span></span><br><span class="line">            writeFrameBuffer(pixel, color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即延迟渲染使用的Pass数目通常就是2个，和光源数目无关；延迟渲染的效率不依赖于场景的复杂度，而是和我们使用的屏幕空间的大小有关（第一个Pass需要保存场景信息），因为我们需要的信息都存储在缓冲区中，这些缓冲区可以理解为一张张2D图像，我们的计算实际上是在图像空间中进行的，而前向渲染中每一个重要灯光都会进行一次运算；</p>
<p>对于延迟渲染路径来说，它最适合场景中光源数目很多，如果使用前向渲染会造成性能瓶颈的情况下使用，而且<strong>每个光源都可以按逐像素的方式处理</strong>，但是也存在一些缺点：</p>
<ul>
<li>不支持真正的抗锯齿功能（MSAA是多重采样抗锯齿，而延迟渲染计算光照的时候使用的是G-Buffer而不是像素的几何信息）</li>
<li>不能处理半透明物体（因为没有办法记录透过半透明物体可见的物体还有当前物体本身的深度和法线）</li>
<li>对显卡有一定要求</li>
</ul>
<p>对于Unity，使用延迟渲染时，Unity需要我们提供两个Pass：</p>
<ol>
<li><p>一个Pass用于渲染G缓冲，在这个Pass中，我们会把物体的漫反射颜色、高光反射颜色、平滑度、法线、自发光和深度等信息渲染到屏幕空间的G缓冲区中，对于每个物体来说，这个Pass仅会执行一次；</p>
</li>
<li><p>第二个Pass用于计算真正的光照模型，这个Pass会使用上一个Pass中渲染的数据来计算最终的光照颜色，在存储到帧缓冲中；</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220719153955097.png" alt="image-20220719153955097"></p>
</li>
</ol>
<h4 id="9-1-4-渲染路径的选择"><a href="#9-1-4-渲染路径的选择" class="headerlink" title="9.1.4 渲染路径的选择"></a>9.1.4 渲染路径的选择</h4><p>我们需要根据游戏发布的目标平台来选择渲染路径，如果当前显卡不支持所选渲染路径，那么Unity会自动使用低一级的渲染路径；</p>
<p>本书中，我们主要使用前向渲染路径；</p>
<h3 id="9-2-Unity的光源类型"><a href="#9-2-Unity的光源类型" class="headerlink" title="9.2 Unity的光源类型"></a>9.2 Unity的光源类型</h3><p>由于面光源仅在烘焙时发挥作用，因此本节介绍如何处理点光源和聚光灯；</p>
<p>每种光源的几何定义不同，因此对应的光源属性也不同；</p>
<h4 id="9-2-1-光源类型有什么影响"><a href="#9-2-1-光源类型有什么影响" class="headerlink" title="9.2.1 光源类型有什么影响"></a>9.2.1 光源类型有什么影响</h4><p>首先可以考虑Shader中使用了光源的哪些属性，最常使用的有光源的位置、方向(到某点的方向)、颜色、强度以及衰减（到某点的衰减），这些属性和他们的几何定义息息相关；</p>
<ul>
<li>平行光<br>几何定义最简单，可以照亮的范围没有限制；<br>没有一个唯一的位置，他的几何属性只有方向，而且平行光到场景中所有点的方向都一样，而且没有衰减的概念；</li>
<li>点光源<br>照亮空间有限，由空间中的一个球体定义，表示由一个点发出的向所有方向延伸的光；<br>对于方向属性，由光源的位置减去某点的位置得到方向，同时是会随距离衰减的；</li>
<li>聚光灯<br>照亮空间有限，有空间中一块锥形区域定义；聚光灯可以用于表示由一个特定位置出发、向特定方向延伸的光。<br>方向属性同点光源，衰减值可由函数定义，较点光源衰减公式更为复杂，同时需要判断点是否在锥体范围内；</li>
</ul>
<h4 id="9-2-2-在前向渲染中处理不同的光源类型"><a href="#9-2-2-在前向渲染中处理不同的光源类型" class="headerlink" title="9.2.2 在前向渲染中处理不同的光源类型"></a>9.2.2 在前向渲染中处理不同的光源类型</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_LightMatrix0&#x27; with &#x27;unity_WorldToLight&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Forward Rendering&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;<span class="comment">//Base Pass 在此Pass中计算环境光和最重要的平行光</span></span><br><span class="line">		      <span class="comment">//当存在多个平行光时，Unity会选择最亮的平行光传递给Base Pass逐像素处理，其他平行光会逐顶点或者在Additional Pass中逐像素处理</span></span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//前向渲染需要添加该声明</span></span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdbase	</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Diffuse;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<span class="comment">//Base Pass逐像素处理的一定是平行光，_WorldSpaceLightPos0来得到平行光的方向</span></span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				</span><br><span class="line">			 	fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));<span class="comment">//_LightColor0是颜色和强度相乘后的结果</span></span><br><span class="line"></span><br><span class="line">			 	fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">			 	fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">			 	fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">				fixed atten = <span class="number">1.0</span>;<span class="comment">//平行光没有衰减，因此使衰减值为1.0</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		Pass &#123;<span class="comment">//Additional Pass 处理其他逐像素光源</span></span><br><span class="line">			  <span class="comment">//光照处理和Base Pass基本相同，去掉了环境光，自发光，逐顶点光照和SH光照的部分，并添加了对不同类型光源的支持；</span></span><br><span class="line"></span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			Blend One One<span class="comment">//防止覆盖掉之前的渲染结果</span></span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//同Base Pass</span></span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Diffuse;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				<span class="comment">//由于处理的类型可能是平行光，点光源或聚光灯，颜色和强度可继续使用_LightColor0来得到，但位置，方向和衰减属性需要根据光源类型分别计算；</span></span><br><span class="line">				<span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">				<span class="comment">//#ifdef 判断是否定义了平行光</span></span><br><span class="line">					fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<span class="comment">//如果是平行光则可以直接得到</span></span><br><span class="line">				<span class="meta">#else</span></span><br><span class="line">					fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);<span class="comment">//如果是点光或者聚光灯，就需要用这个位置减去世界空间下的顶点位置</span></span><br><span class="line">				<span class="meta">#endif</span></span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">				</span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">				fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">				fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//计算不同光源的衰减</span></span><br><span class="line">				<span class="meta">#ifdef USING_DIRECTIONAL_LIGHT</span></span><br><span class="line">					fixed atten = <span class="number">1.0</span>;</span><br><span class="line">				<span class="meta">#else</span></span><br><span class="line">					<span class="meta">#if defined (POINT)</span></span><br><span class="line">					<span class="comment">//点光的情况</span></span><br><span class="line">				        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>)).xyz;</span><br><span class="line">				        fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">				    <span class="meta">#elif defined (SPOT)</span></span><br><span class="line">					<span class="comment">//聚光灯的情况</span></span><br><span class="line">				        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="number">1</span>));</span><br><span class="line">				        fixed atten = (lightCoord.z &gt; <span class="number">0</span>) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + <span class="number">0.5</span>).w * tex2D(_LightTextureB0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">				    <span class="meta">#else</span></span><br><span class="line">				        fixed atten = <span class="number">1.0</span>;</span><br><span class="line">				    <span class="meta">#endif</span></span><br><span class="line">				<span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> fixed4((diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于四个（设置数量内）的点光源，渲染的顺序按照他们的重要度进行排序，重要度与<strong>光源强度，颜色和距离物体的远近</strong>有关</p>
<p>如果逐像素光源的数目很多，物体的Additional Pass就会被调用多次，我们可以设置光源为Not Important来禁止他逐像素处理（前提是数量范围内，否则默认就已经不会逐像素处理）</p>
<h3 id="9-3-Unity的光照衰减"><a href="#9-3-Unity的光照衰减" class="headerlink" title="9.3 Unity的光照衰减"></a>9.3 Unity的光照衰减</h3><p>Unity使用一张纹理作为查找表来在片元着色器中计算逐像素光照的衰减，<strong>好处是不依赖于数学公式的复杂性</strong>，只要使用一个参数值去纹理中采样即可，同时也存在弊端：</p>
<ul>
<li>需要预处理得到采样纹理，而且纹理的大小也会影响衰减的精度；</li>
<li>不直观，不方便，一旦把数据存储到查找表中，就无法使用其他数学公式计算衰减</li>
</ul>
<p>但是这种方法一定程度上提升了性能，而且大部分情况下效果良好，因此Unity默认使用这种<strong>纹理查找</strong>的方式计算逐像素的点光和聚光的衰减；</p>
<h4 id="9-3-1-用于光照衰减的纹理"><a href="#9-3-1-用于光照衰减的纹理" class="headerlink" title="9.3.1 用于光照衰减的纹理"></a>9.3.1 用于光照衰减的纹理</h4><p>Unity在内部使用一张名为_LightTexture0的纹理来计算光照衰减(如果使用了cookie，那么衰减查找纹理是 _LightTextureB0)，(0,0)表明了与光源位置重合的点的衰减值，而(1,1)表明了在光源空间中所关心的距离最远的点的衰减；</p>
<p>而为了对纹理采样得到给定点到该光源的衰减值，我们首先需要知道该点在光源空间中的位置，通过_LightMatrix0变换矩阵得到，只需要把该矩阵和世界空间中的顶点坐标相乘即可得到：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 lightCoord = mul(_LightMatrix0, float4(i.worldPosition, <span class="number">1</span>)).xyz;</span><br></pre></td></tr></table></figure>

<p>然后使用这个坐标的模的平方对衰减纹理采样得到衰减值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed atten = tex2D(_LightTexture0, <span class="built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure>

<p>我们使用dot得到距离的平方来采样，没有使用距离是因为这种方法可以<strong>避免开方操作</strong>，然后我们使用宏UNITY_ATTEN_CHANNEL来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值；</p>
<h4 id="9-3-2-使用数学公式计算衰减"><a href="#9-3-2-使用数学公式计算衰减" class="headerlink" title="9.3.2 使用数学公式计算衰减"></a>9.3.2 使用数学公式计算衰减</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(_WorldSpaceLightPos0.xyz - i.worldPosition.xyz);</span><br><span class="line">atten = <span class="number">1.0</span> / <span class="built_in">distance</span>;</span><br></pre></td></tr></table></figure>

<p>这种使用公式的方式计算了光源的线性衰减；</p>
<p>但是由于我们无法在Shader中通过内置变量得到光源的范围、聚光灯的朝向和张开角度等信息，因此效果并不合适；如果利用脚本传递相关信息，代码的灵活性又很低，因此此种方式不太实用；</p>
<h3 id="9-4-Unity的阴影"><a href="#9-4-Unity的阴影" class="headerlink" title="9.4 Unity的阴影"></a>9.4 Unity的阴影</h3><p>本节介绍如何在Unity中让一个物体向其他物体投射阴影以及让一个物体接收来自其他物体的阴影；</p>
<h4 id="9-4-1-阴影是如何实现的"><a href="#9-4-1-阴影是如何实现的" class="headerlink" title="9.4.1 阴影是如何实现的"></a>9.4.1 阴影是如何实现的</h4><p>阴影区域的产生是因为光线无法到达这些区域；</p>
<p>在实时渲染中，最常使用的是一种名为<strong>Shadow Map</strong>的技术，它会首先把摄像机的位置放在与光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方，而Unity使用的就是这种技术；</p>
<p>在前向渲染路径中，如果场景中最重要的平行光开启了阴影，Unity就会为该光源计算它的阴影映射纹理；这张阴影映射纹理本质上也是一张深度图，它记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置(深度信息)；</p>
<p>在计算阴影映射纹理时，有两种方法判定距离它最近的表面位置：</p>
<ol>
<li>先把摄像机放置到光源的位置上，然后按正常的渲染流程，即调用Base Pass和Additional Pass来更新深度信息，得到阴影映射纹理，但这种方法会对性能造成一定的浪费，因为实际上仅需要深度信息，但是这两个Pass涉及复杂的光照模型计算；</li>
<li>使用一个额外的Pass来专门更新光源的阴影映射纹理，这个Pass就是<strong>LightMode</strong>标签被设置为<strong>ShadowCaster</strong>的Pass，这个Pass的渲染目标不就是帧缓存，而是阴影映射纹理(或深度纹理)，Unity首先把摄像机放置到光源的位置上，然后调用该Pass，通过对顶点变换后得到光源空间下的位置，并据此来输出深度信息到阴影映射纹理中；<br>因此，当开启了光源的阴影效果后，底层渲染引擎首先会在当前渲染物体的Unity Shader中找到LightMode为ShadowCaster的Pass，如果没有，它就会在Fallback指定的Unity Shader中继续寻找，如果仍然没有找到，该物体就无法向其他物体投射阴影；当找到之后，Unity会使用该Pass来更新光源的阴影映射纹理；</li>
</ol>
<p>在传统的阴影映射纹理的实现中，我们会在正常渲染的Pass中把顶点位置变换到光源空间下，以得到它在光源空间中的三维位置信息；然后我们使用xy分量对阴影映射纹理进行采样，得到阴影映射纹理中该位置的深度信息，如果该深度值小于该顶点的深度值(通常由z分量得到)，那么说明该点位于阴影中。</p>
<p>但在Unity5中，使用了不同于这种传统的阴影采样技术，即<strong>屏幕空间的阴影映射技术</strong>；屏幕空间的阴影映射原本是延迟渲染中产生阴影的方法。Unity首先会通过调用LightMode为ShadowCaster的Pass来得到可投射阴影的光源的阴影映射纹理以及摄像机的深度纹理，然后通过二者得到屏幕空间的阴影图，如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，就说明该表面虽然是可见的，但是却处于该光源的阴影中，通过这样的方式，阴影图就包含了屏幕空间中所有有阴影的区域；如果我们想要一个物体接收来自其他物体的阴影，只需要在Shader中对阴影图进行采样；由于阴影图是屏幕空间下的，因此，我们首先需要把表面坐标从模型空间变换到屏幕空间中，然后使用这个坐标对阴影图进行采样即可。</p>
<p>总结：</p>
<ul>
<li>需要一个物体接收来自其他物体的阴影：在Shader中对阴影映射纹理(包括屏幕空间的阴影图)进行采样，把采样结果和最后的光照结果相乘来产生阴影效果；</li>
<li>需要一个物体向其他物体投射阴影：把该物体加入到光源的阴影映射纹理的计算中，从而让其他物体在对阴影映射纹理采样时可以得到该物体的相关信息；</li>
</ul>
<h4 id="9-4-2-不透明物体的阴影"><a href="#9-4-2-不透明物体的阴影" class="headerlink" title="9.4.2 不透明物体的阴影"></a>9.4.2 不透明物体的阴影</h4><p>在Unity中，打开<strong>cast shadows</strong>的物体会加入到光源阴影映射纹理的计算中，这个过程如上文所示，通过为该物体执行LightMode为ShadowCaster的Pass来实现；而打开Receive Shadows的物体则会计算接收来自其他物体的阴影；</p>
<p>对于没有更改Shader的物体，同样可以投射阴影，这是因为他定义了Fallback “Specular”，虽然Specular本身也没有包含ShadowCaster的Pass，但是他条用了VertexLit，它会继续回调，并最终回调到内置的VertexLit，而其中包含了这样的Pass：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">	Name &quot;ShadowCaster&quot;</span><br><span class="line">	Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line">	</span><br><span class="line">	CGPROGRAM</span><br><span class="line">	#pragma vertex vert</span><br><span class="line">	#pragma fragment frag</span><br><span class="line">	#pragma multi_compile_shadowcaster</span><br><span class="line">	#include &quot;UnityCG.cginc&quot;</span><br><span class="line">	</span><br><span class="line">	struct v2f&#123;</span><br><span class="line">		V2F_SHADOW_CASTER;</span><br><span class="line">	&#125;；</span><br><span class="line">	v2f vert(appdata_base v)&#123;</span><br><span class="line">		v2f o;</span><br><span class="line">		TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">		return o;</span><br><span class="line">	&#125;</span><br><span class="line">	float4 frag(v2f i):SV_Target&#123;</span><br><span class="line">		SHADOW_CASTER_FRAGMENT(i);</span><br><span class="line">	&#125;</span><br><span class="line">	ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，Fallback中调用Diffuse也会回调到这样一个Pass，当然我们可以不依赖Fallback，自己定义Pass，可以更灵活的控制阴影的产生，但由于这个Pass的功能通常是可以在多个Unity Shader间通用的，因此直接Fallback是一个更加方便的用法；</p>
<p>对于接收阴影：</p>
<p>SHADOW_COORDS、TRANSFER_SHADOW和SHADOW_ATTENUATION三个内置宏帮助我们计算光源的阴影；</p>
<p>在前向渲染中：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">9</span>/Shadow&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Diffuse (&quot;Diffuse&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_Gloss (&quot;Gloss&quot;, Range(<span class="number">8.0</span>, <span class="number">256</span>)) = <span class="number">20</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			<span class="comment">// Pass for ambient light &amp; first pixel light (directional light)</span></span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Apparently need to add this declaration </span></span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdbase	</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Need these files to get built-in macros</span></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			<span class="comment">//该新加入的内置文件引入了计算阴影所用的宏</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Diffuse;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			<span class="type">float</span> _Gloss;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldNormal : TEXCOORD0;</span><br><span class="line">				float3 worldPos : TEXCOORD1;</span><br><span class="line">				SHADOW_COORDS(<span class="number">2</span>)<span class="comment">//该内置宏声明了一个用于对阴影纹理采样的坐标，这个宏的参数需要是下一个可用的插值寄存器的索引值，该例子中是2，因为使用了TEXCOORD0和TEXCOORD1，这意味着阴影纹理坐标将占用第三个插值寄存器TEXCOORD3</span></span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">			 	v2f o;</span><br><span class="line">			 	o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			 	</span><br><span class="line">			 	o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line">			 	o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">			 	</span><br><span class="line">			 	<span class="comment">// Pass shadow coordinates to pixel shader</span></span><br><span class="line">			 	TRANSFER_SHADOW(o);<span class="comment">//这个内置宏用于在顶点着色器中计算上一步中声明的阴影纹理坐标</span></span><br><span class="line">			 	</span><br><span class="line">			 	<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(_WorldSpaceLightPos0.xyz);</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">			 	fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">			 	fixed3 viewDir = <span class="built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">			 	fixed3 halfDir = <span class="built_in">normalize</span>(worldLightDir + viewDir);</span><br><span class="line">			 	fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, halfDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">				fixed atten = <span class="number">1.0</span>;</span><br><span class="line">				</span><br><span class="line">				fixed shadow = SHADOW_ATTENUATION(i);<span class="comment">//该内置宏用于在片元着色器中计算阴影值</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten * shadow, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		Pass &#123;</span><br><span class="line">			<span class="comment">// Pass for other pixel lights，同9.2.2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Specular&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>宏SHADOW_COORDS实际上就是声明了一个名为_ShadowCoord的阴影纹理坐标变量；</li>
<li>TRANSFER_SHADOW的实现会根据平台不同而有所差异，如果当前平台可以使用屏幕空间的阴影映射技术（通过判断是否定义了UNITY_NO_SCREENSPACE_SHADOWS来得到），TRANSFER_SHADOW会调用内置的ComputeScreenPos函数来计算_ShadowCoord；如果不支持，就会使用传统的阴影映射技术；<br>该宏会把顶点做包从模型空间变换到光源空间后存储到 _ShadowCoord中；</li>
<li>最后，SHADOW_ATTENUATION负责使用_ShadowCoord对相关的纹理进行采样，得到阴影信息；</li>
</ul>
<p>当关闭了阴影之后，这些宏没有任何作用，SHADOW_ATTENUATION会直接等同于数值1；</p>
<p>这些宏会使用上下文变量来进行相关计算，例如TRANSFER_SHADOW会使用v.vertex或a.pos来计算坐标，因此为了能够让这些宏正确工作，我们需要保证自定义的变量名和这些宏中使用的变量名相匹配，a2v结构体的顶点坐标变量名必须是vertex，顶点着色器输入结构体a2v必须命名为v，v2f中的顶点位置变量必须命名为pos；</p>
<p>该例中，我们仅更改了Base Pass中的代码，使其可以得到阴影效果，但是没有更改Additional Pass，大体上两者处理过程相同；</p>
<h4 id="9-4-4-统一管理光照衰减和阴影"><a href="#9-4-4-统一管理光照衰减和阴影" class="headerlink" title="9.4.4 统一管理光照衰减和阴影"></a>9.4.4 统一管理光照衰减和阴影</h4><p>光照衰减和阴影对物体最终的渲染结果的影响本质上是相同的——我们都是把光照衰减因子和阴影值及光照结果相乘得到最终的渲染结果；</p>
<p>因此，我们可以使用UNITY_LIGHT_ATTENUATION宏来同时计算两个信息：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其余部分同9.4.2代码</span></span><br><span class="line">fixed4 frag(v2f i) : SV_Target&#123;</span><br><span class="line">	...</span><br><span class="line">	UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> UNITY_LIGHT_ATTENUATION是Unity内置的用于计算光照衰减和阴影的宏，他接受三个参数，他会将光照衰减和阴影值相乘后的结果存储到第一个参数中（我们没有在代码中声明第一个参数atten，因为该宏会帮我们声明这个变量），它的第二个参数是结构体v2f，这个参数会传递给SHADOW_ATTENUATION用来计算阴影值，而第三个参数是世界空间的坐标，用于计算光源空间下的坐标，再对光照衰减纹理采样来得到光照衰减；</p>
<p>Unity针对不同光源类型、是否启用cookie等不同情况声明了多个版本的UNITY_LIGHT_ATTENUATION，保证了我们通过简单的代码可以得到正确结果；</p>
<p><strong>由于使用了该宏，我们不需要在Base Pass里单独处理阴影，也不需要在Additional Pass中判断光源类型来处理光源衰减；</strong></p>
<h4 id="9-4-5-透明度物体的阴影"><a href="#9-4-5-透明度物体的阴影" class="headerlink" title="9.4.5 透明度物体的阴影"></a>9.4.5 透明度物体的阴影</h4><p>对大多数不透明物体来说，设置Fallback就可以得到正确的阴影，但对于透明物体来说，我们需要小心处理它的阴影，透明物体的实现通常会使用透明度测试或透明度混合，我们需要小心设置这些物体的Fallback；</p>
<p>透明度测试的处理比较简单，但是如果我们仍然直接使用之前的回调，则不会得到正确的阴影，因为透明度测试中，我们需要舍弃某些片元，蛋阴影投射纹理中没有这样的操作，但是Unity准备了内置的Shader，我们可以设置回调为Transparent&#x2F;Cutout&#x2F;VertexLit，它在ShadowCaster Pass中计算了透明度测试，但是他使用了名为_Cutoff的属性进行透明度测试，因此我们必须提供 _Cutoff属性(正如之前写过的)；</p>
<p>对于透明度混合的物体，我们无法使用上述方式，半透明物体不会参与深度图和阴影映射纹理的运算，也就是说他们不会向其他物体投射阴影，同样也不会接受来自其他物体的阴影；</p>
<p>由于透明度混合需要关闭深度写入，由此带来的问题也影响了阴影的生成，如果需要正确的阴影，<strong>需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染</strong>，这会让阴影处理非常复杂，性能也十分消耗，因此Unity不会为内置的半透明Shader产生阴影；我们可以使用Fallback设置为不透明物体使用的Unity Shader来强制为半透明物体生成阴影；</p>
<h3 id="9-5-标准Unity-Shader"><a href="#9-5-标准Unity-Shader" class="headerlink" title="9.5 标准Unity Shader"></a>9.5 标准Unity Shader</h3><p>使用了Phong光照模型的标准光照着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Common/Bumped Diffuse&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line"></span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">			float4 _BumpMap_ST;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float4 uv : TEXCOORD0;</span><br><span class="line">				float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">				float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">				float4 TtoW2 : TEXCOORD3;</span><br><span class="line">				SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">				o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line">				</span><br><span class="line">				float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">				fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">				fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">				fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">				</span><br><span class="line">				o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">				o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">				o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">				</span><br><span class="line">				TRANSFER_SHADOW(o);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">				fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">				</span><br><span class="line">				fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">				bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">				</span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">			</span><br><span class="line">			 	fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">				</span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse * atten, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			Blend One One</span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdadd</span></span><br><span class="line">			<span class="comment">// Use the line below to add shadows for point and spot lights</span></span><br><span class="line"><span class="comment">//			#pragma multi_compile_fwdadd_fullshadows</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">			float4 _BumpMap_ST;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float4 uv : TEXCOORD0;</span><br><span class="line">				float4 TtoW0 : TEXCOORD1;  </span><br><span class="line">				float4 TtoW1 : TEXCOORD2;  </span><br><span class="line">				float4 TtoW2 : TEXCOORD3;</span><br><span class="line">				SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">				o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line">				</span><br><span class="line">				float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">				fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">				fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">				fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">				</span><br><span class="line">				o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">				o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">				o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">				</span><br><span class="line">				TRANSFER_SHADOW(o);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">				fixed3 lightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">				</span><br><span class="line">				fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));</span><br><span class="line">				bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));</span><br><span class="line">				</span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;</span><br><span class="line">				</span><br><span class="line">			 	fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(bump, lightDir));</span><br><span class="line">				</span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, worldPos);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(diffuse * atten, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第十章-高级纹理"><a href="#第十章-高级纹理" class="headerlink" title="第十章 高级纹理"></a>第十章 高级纹理</h2><h3 id="10-1-立方体纹理"><a href="#10-1-立方体纹理" class="headerlink" title="10.1 立方体纹理"></a>10.1 立方体纹理</h3><p>在图形学中，<strong>立方体纹理</strong>(cubemap)是<strong>环境映射</strong>(Environment Mapping)的一种实现方法，环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层金属一样反射出周围的环境。</p>
<p>和之前见到的纹理不同，立方体纹理一共包含了6张图像，这些图像对应了一个立方体的6个面，立方体纹理的名称也由此而来；立方体的每个面表示沿着世界空间下的轴向观察所得的图像；</p>
<p>和之前使用二维纹理不同，对立方体纹理采样需要我们提供一个三维的纹理坐标，这个三维纹理坐标表示了我们在世界空间下的一个3D方向。这个方向矢量从立方体的中心出发，当它向外部延伸时就会和立方体的6个纹理之一发生相交，而采样得到的结果就是由该交点计算而来的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-1c4bed9e48d5b8ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300/format/webp" alt="img"></p>
<p>立方体纹理的好处在于，他的实现简单快速，而且得到的效果也比较好；但他的缺点是当场景中引入了新的物体，光源或者物体移动时，我们就需要重新生成立方体纹理；除此之外，立方体纹理也仅可以反射环境，但不能反射使用了该立方体纹理的物体本身；这是因为立方体纹理不能模拟多次反射的结果，例如两个金属球互相反射的情况；因此我们应该<strong>尽量对凸面体而不要对凹面体使用立方体纹理</strong>；（因为凹面体会反射自身）</p>
<p>立方体纹理在实时渲染中有很多应用，最常见的是用于天空盒子以及环境映射；</p>
<h4 id="10-1-1-天空盒子"><a href="#10-1-1-天空盒子" class="headerlink" title="10.1.1 天空盒子"></a>10.1.1 天空盒子</h4><p>**天空盒子(skybox)**，是游戏中用于模拟背景的一种方法；当我们在场景中使用了天空盒子时，整个场景就被包围在一个立方体内，这个立方体的每个面使用的技术就是立方体纹理映射技术；</p>
<p>在Unity中，只需要创建一个Skybox材质，再把它赋给场景设置即可，该材质需要六张纹理，此外还有三个属性：</p>
<ul>
<li>Tint Color 用于控制该材质的整体颜色</li>
<li>Exposure 用于调整天空盒的亮度</li>
<li>Rotation 用于调整天空盒子沿+y轴方向的旋转角度</li>
</ul>
<p>在Unity中，天空盒是在所有不透明物体之后渲染的，而其背后使用的网格是一个立方体或一个细分后的球体；</p>
<h4 id="10-1-2-创建用于环境映射的立方体纹理"><a href="#10-1-2-创建用于环境映射的立方体纹理" class="headerlink" title="10.1.2 创建用于环境映射的立方体纹理"></a>10.1.2 创建用于环境映射的立方体纹理</h4><p>除了天空盒，立方体纹理最常见的用处是用于环境映射；通过这种方法，我们可以模拟出金属质感的材质；</p>
<p>在Unity 5中，创建用于环境映射的立方体纹理的方法有三种：</p>
<ol>
<li>直接由一些特殊布局的纹理创建；</li>
<li>手动创建一个Cubemap资源，再把六张图赋给它；</li>
<li>由脚本生成；</li>
</ol>
<p>第一种方法中，我们需要提供一张具有特殊布局的纹理，例如类似立方体展开图的交叉布局、全景布局等；然后我们只需要在Unity中把该纹理的Texture Type设置为Cubemap即可；<strong>在PBR中，我们通常会使用一张HDR图像来生成高质量的Cubemap</strong>；（详见18章）</p>
<p>第二种方法需要我们创建一个Cubemap，然后把六张纹理拖拽到他的面板中</p>
<p>前两种方法都需要我们提前准备好立方体纹理的图像，它们得到的立方体纹理往往是被场景中的物体所共用的；但在理想情况下，我们希望根据物体在场景中位置的不同，生成它们各自不同的立方体纹理，这时，我们就可以在Unity中使用脚本来创建；这是利用Unity提供的Camera.RenderToCubemap函数来实现的，该函数可以把从任意位置观察到的场景图像存储到6张图像中，从而创建出对应的立方体纹理；</p>
<p>相关代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RenderCubemapWizard</span> : <span class="title">ScriptableWizard</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Transform renderFromPosition;</span><br><span class="line">	<span class="keyword">public</span> Cubemap cubemap;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnWizardUpdate</span> ()</span> &#123;</span><br><span class="line">		helpString = <span class="string">&quot;Select transform to render from and cubemap to render into&quot;</span>;</span><br><span class="line">		isValid = (renderFromPosition != <span class="literal">null</span>) &amp;&amp; (cubemap != <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnWizardCreate</span>()</span>&#123;</span><br><span class="line">		GameObject go = <span class="keyword">new</span> GameObject(<span class="string">&quot;CubemapCamera&quot;</span>);</span><br><span class="line">		go.AddComponent&lt;Camera&gt;();</span><br><span class="line">		go.transform.position = renderFromPosition.position;<span class="comment">//在由用户指定(renderFromPosition)位置处动态创建一个摄像机</span></span><br><span class="line">		go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);<span class="comment">//用该函数把从当前位置观察到的图像渲染到用户指定的立方体纹理cubemap中</span></span><br><span class="line">		DestroyImmediate(go);<span class="comment">//销毁临时摄像机</span></span><br><span class="line">	&#125;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;GameObject/Render into Cubemap&quot;</span>)</span>]<span class="comment">//添加了菜单栏条目在GameObject下</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RenderCubemap</span> ()</span> &#123;</span><br><span class="line">		ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(</span><br><span class="line">			<span class="string">&quot;Render cubemap&quot;</span>, <span class="string">&quot;Render!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于该代码需要添加菜单栏条目，因此我们需要把它放在Editor文件夹下才能正确执行；</p>
<p>我们就可以使用该代码在任意位置生成Cubemap；</p>
<p><strong>准备好了需要的立方体纹理后，我们就可以对物体使用环境映射技术，而最常见的环境映射就是反射和折射；</strong></p>
<h4 id="10-1-3-反射"><a href="#10-1-3-反射" class="headerlink" title="10.1.3 反射"></a>10.1.3 反射</h4><p>模拟反射效果，只需要通过入射光线的方向和表面法线方向来计算反射方向，再利用反射方向对立方体纹理采样即可；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Reflection&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_ReflectColor (&quot;Reflection Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="comment">//用于控制反射颜色</span></span><br><span class="line">		_ReflectAmount (&quot;Reflect Amount&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span><span class="comment">//用于控制材质的反射程度</span></span><br><span class="line">		_Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<span class="comment">//模拟反射的环境映射纹理</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			fixed4 _ReflectColor;</span><br><span class="line">			fixed _ReflectAmount;</span><br><span class="line">			samplerCUBE _Cubemap;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float3 worldPos : TEXCOORD0;</span><br><span class="line">				fixed3 worldNormal : TEXCOORD1;</span><br><span class="line">				fixed3 worldViewDir : TEXCOORD2;</span><br><span class="line">				fixed3 worldRefl : TEXCOORD3;</span><br><span class="line">				SHADOW_COORDS(<span class="number">4</span>)</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				</span><br><span class="line">				o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line">				</span><br><span class="line">				o.worldRefl = <span class="built_in">reflect</span>(-o.worldViewDir, o.worldNormal);</span><br><span class="line">				<span class="comment">//使用reflect函数计算该顶点处的反射方向，reflect函数的入射光要求是由光源指向交点处，因此我们给worldLightDir取反</span></span><br><span class="line">				</span><br><span class="line">				TRANSFER_SHADOW(o);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));		</span><br><span class="line">				fixed3 worldViewDir = <span class="built_in">normalize</span>(i.worldViewDir);		</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">				</span><br><span class="line">				fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;<span class="comment">//使用texCUBE函数对立方体纹理采样</span></span><br><span class="line">				</span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line">				</span><br><span class="line">				fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;<span class="comment">//使用lerp混合漫反射颜色和反射颜色，lerp(a,b,c) = a * (1 - c) + b * c;</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(color, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Reflective/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在例中选择在顶点着色器中计算反射方向，如果在片元着色器中计算可以得到更细腻的效果，但是差别可以忽略不计，为了性能考虑，我们选择在顶点着色器中计算反射方向；</p>
<h4 id="10-1-4-折射"><a href="#10-1-4-折射" class="headerlink" title="10.1.4 折射"></a>10.1.4 折射</h4><p>折射的物理原理比反射复杂一些，当给定入射角时，我们可以使用**斯涅耳定律(Snell’s Law)**来计算反射角,当光从介质1沿着和表面法线夹角为θ1的方向斜射入介质2时，我们可以使用如下公式计算折射光线与法线的夹角θ2：<br>$$<br>n1 sinθ1 &#x3D; n2sinθ2<br>$$<br>其中n1和n2分别是两个介质的折射率</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-853921198fef2b5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp" alt="img"></p>
<p>通常来说，当得到折射方向后我们就会直接使用它来对立方体纹理进行采样，但是其实这不符合物理规律，因为对于一个透明物体来说，需要经过两次折射(进入和射出的时候)，但是实时渲染中模拟两次折射比较复杂，而仅模拟一次的视觉效果可以接受，因此我们通常仅模拟一次折射；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _RefractRatio 我们使用该属性得到不同介质的透射比</span></span><br><span class="line">o.worldRefr = <span class="built_in">refract</span>(-<span class="built_in">normalize</span>(o.worldViewDir), <span class="built_in">normalize</span>(o.worldNormal), _RefractRatio);</span><br><span class="line"><span class="comment">// 使用refract函数来计算折射方向，它的第一个参数即为入射光线的方向，它必须是归一化后的矢量；第二个参数是表面法线，法线方向同样需要是归一化之后的；</span></span><br><span class="line"><span class="comment">// 第三个参数是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值；它的返回值就是计算而得的折射方向，它的模则等于入射光线的模</span></span><br></pre></td></tr></table></figure>

<h4 id="10-1-5-菲涅耳反射"><a href="#10-1-5-菲涅耳反射" class="headerlink" title="10.1.5 菲涅耳反射"></a>10.1.5 菲涅耳反射</h4><p>在实时渲染中，我们经常会使用<strong>菲涅耳反射(Fresnel reflection)<strong>，来根据视角方向控制反射程度；通俗的讲，菲涅耳反射描述了一种光学现象，即当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射。被反射的光和入射光之间存在一定的比率关系(例如低头看脚边的水面时可以看到水低，而看远处的水面则看不见，即菲涅耳效果)，这个比率关系可以通过菲涅耳等式进行计算，这是</strong>基于物理的渲染中非常重要的一项高光反射计算因子</strong>；</p>
<p>计算菲涅耳反射需要使用菲涅耳等式，真实世界的菲涅耳等式是非常复杂的，但是在实时渲染中，我们使用一些近似公式来计算，其中一个著名的近似公式就是<strong>Schlick菲涅耳近似等式</strong>：<br>$$<br>F_s(v,n) &#x3D; F_0 +(1-F_0)(1-v*n)^5<br>$$<br>其中F0是一个反射系数，用于控制菲涅耳反射的强度，v是视角方向，n是表面法线；</p>
<p>另一个应用比较广泛的等式是<strong>Empricial菲涅耳近似等式</strong>：<br>$$<br>F_e(v,n) &#x3D; max(0,min(1,bias+scale*(1-v*n)^p)<br>$$<br>其中bias、scale和p是控制项；</p>
<p>使用上面的菲涅耳近似等式，我们可以在边界处模拟反射光强和折射光强&#x2F;漫反射光强之间的变化；在许多车漆、水面等材质的渲染中，我们经常使用菲涅耳反射来模拟更加真实的反射效果；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fixed fresnel = _FresnelScale + (<span class="number">1</span> - _FresnelScale) * <span class="built_in">pow</span>(<span class="number">1</span> - <span class="built_in">dot</span>(worldViewDir, worldNormal), <span class="number">5</span>);</span><br><span class="line"><span class="comment">//使用了Schlick菲涅耳近似等式计算fresnel变量,_FresnelScale是声明的调整属性</span></span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldNormal, worldLightDir));</span><br><span class="line">fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line"><span class="comment">//用计算得到的fresnel来作为lerp函数的混合因子，saturate将数值规范到0~1区间</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-渲染纹理"><a href="#10-2-渲染纹理" class="headerlink" title="10.2 渲染纹理"></a>10.2 渲染纹理</h3><p>在之前的学习中，摄像机的渲染结果会输出到颜色缓冲中，并显示到我们的屏幕上；</p>
<p>现代的GPU允许我们把整个三维场景渲染到一个中间缓冲中，即**渲染目标纹理(Render Target Texture RTT)<strong>，而不是传统的帧缓冲或后备缓冲；与之相关的是</strong>多重渲染目标(Multiple Render Target MRT)**，这种技术是GPU允许我们把场景同时渲染到多个渲染目标纹理中，而不再需要为每个渲染目标纹理单独渲染完整的场景。延迟渲染就是使用多重渲染目标的一个应用；</p>
<p>Unity为渲染目标纹理定义了一种专门的纹理类型——**渲染纹理(Render Texture)**。在Unity中使用渲染纹理通常有两种方式：</p>
<ol>
<li>在Project目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样该摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上；</li>
<li>在屏幕后处理时使用GrabPass命令或OnRenderImage函数来获取当前屏幕图像，Unity会把这个屏幕图像放到一张和屏幕分辨率等同的渲染纹理中，下面我们可以在自定义的Pass中把它们当成普通的纹理来处理，从而实现各种屏幕特效；</li>
</ol>
<h4 id="10-2-1-镜子效果"><a href="#10-2-1-镜子效果" class="headerlink" title="10.2.1 镜子效果"></a>10.2.1 镜子效果</h4><p>镜子的实现原理，它使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上即可；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Mirror&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//输入纹理，对应了由镜子摄像机渲染得到的渲染纹理</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uv = v.texcoord;</span><br><span class="line">				</span><br><span class="line">				o.uv.x = <span class="number">1</span> - o.uv.x; <span class="comment">//翻转了x分量的纹理坐标</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				<span class="keyword">return</span> tex2D(_MainTex, i.uv); <span class="comment">//在片元着色器中对渲染纹理进行采样和输出</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"> 	FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Unity中，我们创建渲染纹理与摄像机绑定，对镜子平面使用该着色器，并将创建的渲染纹理输入即能得到效果；</p>
<h4 id="10-2-2-玻璃效果"><a href="#10-2-2-玻璃效果" class="headerlink" title="10.2.2 玻璃效果*"></a>10.2.2 玻璃效果*</h4><p>在Unity中，我们还可以在Unity Shader中使用一种特殊的Pass来完成获取屏幕图像的目的，这就是GrabPass；当我们在GrabPass后，Unity会把当前屏幕的图像会旨在一张纹理中，以便我们在后续的Pass中访问它。</p>
<p>我们通常会使用GrabPass来实现诸如玻璃等透明材质的模拟，与使用简单的透明混合不同，该Pass可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合；</p>
<p>在使用GrabPass的时候，需要<strong>小心物体的渲染队列设置</strong>，GrabPass通常用于渲染透明物体，尽管代码里不包含混合，但是我们往往仍然需要把物体的渲染队列设置成透明队列，才可以保证当渲染该物体时，不透明物体都已经被绘制在屏幕上；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-e67e2f100cf5bd22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp" alt="img"></p>
<p>要实现这种效果，我们首先使用一张法线纹理来修改模型的法线信息，然后通过一个Cubemap来模拟玻璃的反射，在模拟折射时是用来GrabPass获取玻璃后面的屏幕图像，并使用切线空间下的法线对屏幕纹理坐标偏移后，再对屏幕图像进行采样来模拟近似的折射效果；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">10</span>/Glass Refraction&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//玻璃的材质纹理</span></span><br><span class="line">		_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;<span class="comment">//玻璃的法线纹理</span></span><br><span class="line">		_Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<span class="comment">//用于模拟反射的环境纹理</span></span><br><span class="line">		_Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span><span class="comment">//用于控制模拟折射时图像的扭曲程度</span></span><br><span class="line">		_RefractAmount (&quot;Refract Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">1.0</span><span class="comment">//用于控制折射程度</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">		<span class="comment">//看似矛盾，实际上服务于不同的需求，Transparent可以确保物体渲染时，其他不透明物体已经渲染了；而设置RenderType是为了使用着色器替换时，该物体可以在需要时被正确渲染；</span></span><br><span class="line"></span><br><span class="line">		GrabPass &#123; &quot;_RefractionTex&quot; &#125;<span class="comment">//通过GrabPass定义了一个抓取屏幕图像的Pass，该定义字符串内部的名称决定了抓取得到的图像存入的纹理；</span></span><br><span class="line">		</span><br><span class="line">		Pass &#123;		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">			float4 _BumpMap_ST;</span><br><span class="line">			samplerCUBE _Cubemap;</span><br><span class="line">			<span class="type">float</span> _Distortion;</span><br><span class="line">			fixed _RefractAmount;</span><br><span class="line">			<span class="type">sampler2D</span> _RefractionTex;<span class="comment">//对应了使用GrabPass时指定的纹理名称</span></span><br><span class="line">			float4 _RefractionTex_TexelSize;</span><br><span class="line">			<span class="comment">//可以让我们得到该纹理的纹素大小，例如一个大小为256*512的纹理，他的纹素大小为（1/256,1/512），我们需要再对屏幕图像的采样坐标进行偏移时使用该变量</span></span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT; </span><br><span class="line">				float2 texcoord: TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float4 scrPos : TEXCOORD0;</span><br><span class="line">				float4 uv : TEXCOORD1;</span><br><span class="line">				float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">			    float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">			    float4 TtoW2 : TEXCOORD4; </span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert (a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.scrPos = ComputeGrabScreenPos(o.pos); <span class="comment">//进行顶点坐标变换后，调用内置函数来得到抓取的屏幕图像的采样坐标</span></span><br><span class="line">				</span><br><span class="line">				o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">				o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">				</span><br><span class="line">				float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">				fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">				fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">				fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">				</span><br><span class="line">				o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">                  <span class="comment">//存储切线空间到世界空间的变换矩阵</span></span><br><span class="line">				o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">				o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  </span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag (v2f i) : SV_Target &#123;		</span><br><span class="line">				float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">				fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line">				</span><br><span class="line">				fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<span class="comment">//获得切线空间下的法线信息</span></span><br><span class="line">				</span><br><span class="line">				float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;</span><br><span class="line">				<span class="comment">//对屏幕图像的采样坐标进行偏移，模拟折射效果，_Distortion值越大，偏移量越大，玻璃背后物体变形程度越大</span></span><br><span class="line">				<span class="comment">//这里使用切线空间下的法线方向来进行位移，是因为该空间下的法线可以反映顶点局部空间下的法线方向</span></span><br><span class="line">				i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;<span class="comment">//对scrPos透视除法得到真正的屏幕坐标</span></span><br><span class="line"></span><br><span class="line">				fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;<span class="comment">//使用上述坐标对抓取的屏幕图像进行采样，得到模拟的折射颜色</span></span><br><span class="line">				</span><br><span class="line">				bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));<span class="comment">//变换法线方向到世界空间下</span></span><br><span class="line">				fixed3 reflDir = <span class="built_in">reflect</span>(-worldViewDir, bump);</span><br><span class="line">				fixed4 texColor = tex2D(_MainTex, i.uv.xy);<span class="comment">//用反射方向对Cubemap进行采样</span></span><br><span class="line">				fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;<span class="comment">//把结果和主纹理颜色相乘后得到反射颜色</span></span><br><span class="line">				</span><br><span class="line">				fixed3 finalColor = reflCol * (<span class="number">1</span> - _RefractAmount) + refrCol * _RefractAmount;<span class="comment">//使用反射和折射颜色混合得到最终的输出颜色</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在实现中，我们在GrabPass中使用一个字符串指明了被抓取的屏幕图像会存储在哪个名称的纹理中，实际上GrabPass有两种形式：</p>
<ol>
<li>直接使用GrabPass{ }，在后续的Pass中使用_GrabTextrue来访问屏幕图像，当场景中有多个物体时，这种方法性能消耗较大，因为对于每个使用它的物体，都会单独进行一次屏幕抓取；<br>但这种方法可以让每个物体得到不同的屏幕图像，这取决于他们的渲染队列和渲染他们时屏幕缓冲中的颜色；</li>
<li>使用GrabPass{“TextureName”}，这种方法同样可以抓取屏幕，但只会在每一帧时为<strong>第一个使用名为TextureName的纹理的物体</strong>执行一次屏幕抓取，这个纹理同样可以在其他Pass中被访问，也意味着所有物体都会使用同一张屏幕图像；</li>
</ol>
<h4 id="10-2-3-渲染纹理-vs-GrabPass"><a href="#10-2-3-渲染纹理-vs-GrabPass" class="headerlink" title="10.2.3 渲染纹理 vs GrabPass"></a>10.2.3 渲染纹理 vs GrabPass</h4><p>Grab的好处在于实现简单，但是渲染纹理的效率往往好于Grab，尤其在移动设备上；</p>
<p>使用渲染纹理我们可以自定义渲染纹理的大小，尽管这种方法需要把部分场景再次渲染一遍，但我们可以通过调整摄像机的渲染层来减少二次渲染时的场景大小；而使用Grab获取到的图像分辨率和屏幕是一致的，意味着高分辨率的设备上造成严重带宽影响；</p>
<p>而且在移动设备上，Grab虽然不会重新渲染场景，但是需要CPU直接读取后备缓冲中的数据，破坏了CPU与GPU的并行性，这是比较耗时的，而且一些移动设备是不支持的；</p>
<h3 id="10-3-程序纹理"><a href="#10-3-程序纹理" class="headerlink" title="10.3 程序纹理"></a>10.3 程序纹理</h3><p>程序纹理指的是那些由计算机生成的图像，我们通常使用一些特定的算法来创建个性化图案或非常真实的自然元素；使用程序纹理的好处是我们可以使用各种参数来控制纹理的外观，不仅是颜色属性，还可以是不同类型的图案属性，这使我们可以得到更加丰富的动画和视觉效果；</p>
<p>通过脚本创建程序纹理：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]<span class="comment">//为了让该脚本能在编辑器模式下运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProceduralTextureGeneration</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Material material = <span class="literal">null</span>;<span class="comment">//声明材质，这个材质将使用该脚本中生成的程序纹理</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">region</span> Material properties</span></span><br><span class="line">	[<span class="meta">SerializeField, SetProperty(<span class="string">&quot;textureWidth&quot;</span>)</span>] <span class="comment">//声明该程序纹理使用的各种参数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> m_textureWidth = <span class="number">512</span>; <span class="comment">//纹理的大小</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> textureWidth &#123;</span><br><span class="line">		<span class="keyword">get</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> m_textureWidth;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">set</span> &#123;</span><br><span class="line">			m_textureWidth = <span class="keyword">value</span>;</span><br><span class="line">			_UpdateMaterial();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">SerializeField, SetProperty(<span class="string">&quot;backgroundColor&quot;</span>)</span>]</span><br><span class="line">	<span class="keyword">private</span> Color m_backgroundColor = Color.white; <span class="comment">//纹理的背景颜色</span></span><br><span class="line">	<span class="keyword">public</span> Color backgroundColor &#123;</span><br><span class="line">		<span class="keyword">get</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> m_backgroundColor;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">set</span> &#123;</span><br><span class="line">			m_backgroundColor = <span class="keyword">value</span>;</span><br><span class="line">			_UpdateMaterial();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">SerializeField, SetProperty(<span class="string">&quot;circleColor&quot;</span>)</span>]</span><br><span class="line">	<span class="keyword">private</span> Color m_circleColor = Color.yellow;<span class="comment">//斑点的颜色</span></span><br><span class="line">	<span class="keyword">public</span> Color circleColor &#123;</span><br><span class="line">		<span class="keyword">get</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> m_circleColor;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">set</span> &#123;</span><br><span class="line">			m_circleColor = <span class="keyword">value</span>;</span><br><span class="line">			_UpdateMaterial();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">SerializeField, SetProperty(<span class="string">&quot;blurFactor&quot;</span>)</span>]</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">float</span> m_blurFactor = <span class="number">2.0f</span>;<span class="comment">//模糊因子</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">float</span> blurFactor &#123;</span><br><span class="line">		<span class="keyword">get</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> m_blurFactor;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">set</span> &#123;</span><br><span class="line">			m_blurFactor = <span class="keyword">value</span>;</span><br><span class="line">			_UpdateMaterial();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//对每个属性，我们使用了set/get方法，为了在面板上修改时可以执行set函数，我们用了开源插件SetProperty,这使得我们修改材质属性时，可以执行_UpdateMaterial函数来重新生成程序纹理</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Texture2D m_generatedTexture = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this for initialization</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (material == <span class="literal">null</span>) &#123; <span class="comment">//当material变量为空，就尝试用该脚本所在的物体上得到相应的材质，完成后调用_UpdateMaterial函数来为其生成程序纹理</span></span><br><span class="line">			Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">			<span class="keyword">if</span> (renderer == <span class="literal">null</span>) &#123;</span><br><span class="line">				Debug.LogWarning(<span class="string">&quot;Cannot find a renderer.&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			material = renderer.sharedMaterial;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		_UpdateMaterial();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> _UpdateMaterial() &#123;</span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123; <span class="comment">//确保material不为空，然后调用_GenerateProceduralTexture来生成一张程序纹理并赋给m_generatedTexture变量，再用SetTexture函数将其赋给材质</span></span><br><span class="line">			m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">			material.SetTexture(<span class="string">&quot;_MainTex&quot;</span>, m_generatedTexture);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="built_in">float</span> mixFactor) &#123;</span><br><span class="line">		Color mixColor = Color.white;</span><br><span class="line">		mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);</span><br><span class="line">		mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);</span><br><span class="line">		mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);</span><br><span class="line">		mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);</span><br><span class="line">		<span class="keyword">return</span> mixColor;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;</span><br><span class="line">		Texture2D proceduralTexture = <span class="keyword">new</span> Texture2D(textureWidth, textureWidth);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 定义圆与圆的间距</span></span><br><span class="line">		<span class="built_in">float</span> circleInterval = textureWidth / <span class="number">4.0f</span>;</span><br><span class="line">		<span class="comment">// 定义圆的半径</span></span><br><span class="line">		<span class="built_in">float</span> radius = textureWidth / <span class="number">10.0f</span>;</span><br><span class="line">		<span class="comment">// 定义模糊系数</span></span><br><span class="line">		<span class="built_in">float</span> edgeBlur = <span class="number">1.0f</span> / blurFactor;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> w = <span class="number">0</span>; w &lt; textureWidth; w++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> h = <span class="number">0</span>; h &lt; textureWidth; h++) &#123;</span><br><span class="line">				<span class="comment">// 使用背景颜色进行初始化</span></span><br><span class="line">				Color pixel = backgroundColor;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 依次画九个圆</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">						<span class="comment">// 计算当前所绘制的圆的圆心位置</span></span><br><span class="line">						Vector2 circleCenter = <span class="keyword">new</span> Vector2(circleInterval * (i + <span class="number">1</span>), circleInterval * (j + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">						<span class="comment">// 计算当前像素与圆心的距离</span></span><br><span class="line">						<span class="built_in">float</span> dist = Vector2.Distance(<span class="keyword">new</span> Vector2(w, h), circleCenter) - radius;</span><br><span class="line"></span><br><span class="line">						<span class="comment">// 模糊圆的边界</span></span><br><span class="line">						Color color = _MixColor(circleColor, <span class="keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="number">0.0f</span>), Mathf.SmoothStep(<span class="number">0f</span>, <span class="number">1.0f</span>, dist * edgeBlur));</span><br><span class="line"></span><br><span class="line">						<span class="comment">// 与之前得到的颜色进行混合</span></span><br><span class="line">						pixel = _MixColor(pixel, color, color.a);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				proceduralTexture.SetPixel(w, h, pixel);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//代码首先初始化一张二维纹理，并提前计算了一些生成纹理时需要的变量，然后使用了一个两层的嵌套循环遍历纹理中的每个像素，并在纹理上依次绘制9个圆形</span></span><br><span class="line">		proceduralTexture.Apply();<span class="comment">//该函数可以强制把像素值写入纹理中</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> proceduralTexture;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Unity中，还有一类专门使用程序纹理的材质，叫做<strong>程序材质</strong>，这类材质使用的程序纹理由外部使用Substance Designer生成；</p>
<h2 id="第十一章-让画面动起来"><a href="#第十一章-让画面动起来" class="headerlink" title="第十一章 让画面动起来"></a>第十一章 让画面动起来</h2><h3 id="11-1-关于时间的内置变量"><a href="#11-1-关于时间的内置变量" class="headerlink" title="11.1 关于时间的内置变量"></a>11.1 关于时间的内置变量</h3><p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220726122444657.png" alt="image-20220726122444657"></p>
<h3 id="11-2-纹理动画"><a href="#11-2-纹理动画" class="headerlink" title="11.2 纹理动画"></a>11.2 纹理动画</h3><h4 id="11-2-1-序列帧动画"><a href="#11-2-1-序列帧动画" class="headerlink" title="11.2.1 序列帧动画"></a>11.2.1 序列帧动画</h4><p>要实现序列帧动画，我们首先需要一张包含了关键帧图像的图像；序列帧动画的精髓在于，我们需要在每个时刻计算该时刻下应该播放的关键帧的位置，并对该关键帧进行纹理采样；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Image Sequence Animation&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Image Sequence&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//包含了所有关键帧图像的纹理</span></span><br><span class="line">    	_HorizontalAmount (&quot;Horizontal Amount&quot;, Float) = <span class="number">4</span></span><br><span class="line">    	_VerticalAmount (&quot;Vertical Amount&quot;, Float) = <span class="number">4</span><span class="comment">//分别代表了水平方向和竖直方向包含的关键帧图像的个数</span></span><br><span class="line">    	_Speed (&quot;Speed&quot;, Range(<span class="number">1</span>, <span class="number">100</span>)) = <span class="number">30</span><span class="comment">//用于控制播放速度</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">		<span class="comment">//序列帧图像通常是透明纹理，通常包含了透明通道，因此当成半透明对象处理设置</span></span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			ZWrite Off</span><br><span class="line">			Blend SrcAlpha OneMinusSrcAlpha<span class="comment">//当做半透明对象处理，关闭深度写入并开启混合</span></span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="type">float</span> _HorizontalAmount;</span><br><span class="line">			<span class="type">float</span> _VerticalAmount;</span><br><span class="line">			<span class="type">float</span> _Speed;</span><br><span class="line">			  </span><br><span class="line">			struct a2v &#123;  </span><br><span class="line">			    float4 vertex : POSITION; </span><br><span class="line">			    float2 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;  </span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;  </span><br><span class="line">			    float4 pos : SV_POSITION;</span><br><span class="line">			    float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;  </span><br><span class="line">			</span><br><span class="line">			v2f vert (a2v v) &#123;  </span><br><span class="line">				v2f o;  </span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);  </span><br><span class="line">				o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);  </span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;  </span><br><span class="line">			</span><br><span class="line">			fixed4 frag (v2f i) : SV_Target &#123;<span class="comment">//本质来说我们需要计算出每个时刻需要播放的关键帧在纹理中的位置</span></span><br><span class="line">				<span class="type">float</span> time = <span class="built_in">floor</span>(_Time.y * _Speed); <span class="comment">//_Time.y即场景加载后经过的时间，乘上速度得到模拟的时间</span></span><br><span class="line">				<span class="type">float</span> row = <span class="built_in">floor</span>(time / _HorizontalAmount);<span class="comment">//由模拟世界获得行索引</span></span><br><span class="line">				<span class="type">float</span> column = time - row * _HorizontalAmount;<span class="comment">//计算列索引</span></span><br><span class="line">				</span><br><span class="line"><span class="comment">//				half2 uv = float2(i.uv.x /_HorizontalAmount, i.uv.y / _VerticalAmount); 将坐标规范到一帧图片的大小</span></span><br><span class="line"><span class="comment">//				uv.x += column / _HorizontalAmount;</span></span><br><span class="line"><span class="comment">//				uv.y -= row / _VerticalAmount; 按照索引得到当前坐标</span></span><br><span class="line">				half2 uv = i.uv + half2(column, -row);</span><br><span class="line">				uv.x /=  _HorizontalAmount;</span><br><span class="line">				uv.y /= _VerticalAmount;<span class="comment">//和注释代码效果一致，整合了除法部分</span></span><br><span class="line">				<span class="comment">//注意纹理坐标竖直方向的顺序(原点在左上角)和序列帧纹理的顺序(播放方向从上到下)相反</span></span><br><span class="line">				</span><br><span class="line">				fixed4 c = tex2D(_MainTex, uv);</span><br><span class="line">				c.rgb *= _Color;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> c;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-2-2-滚动的背景"><a href="#11-2-2-滚动的背景" class="headerlink" title="11.2.2 滚动的背景"></a>11.2.2 滚动的背景</h4><p>很多2D游戏使用不断滚动的背景模拟角色在场景中穿梭，这些背景往往包含很多层来模拟一种视差效果，而这些背景的实现往往就是利用了纹理动画；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Scrolling Background&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base Layer (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//较远的背景纹理</span></span><br><span class="line">		_DetailTex (&quot;<span class="number">2</span>nd Layer (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//较近的背景纹理</span></span><br><span class="line">		_ScrollX (&quot;Base layer Scroll Speed&quot;, Float) = <span class="number">1.0</span><span class="comment">//较远纹理滚动速度</span></span><br><span class="line">		_Scroll2X (&quot;<span class="number">2</span>nd layer Scroll Speed&quot;, Float) = <span class="number">1.0</span><span class="comment">//较近纹理滚动速度</span></span><br><span class="line">		_Multiplier (&quot;Layer Multiplier&quot;, Float) = <span class="number">1</span><span class="comment">//控制整体亮度</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			<span class="type">sampler2D</span> _DetailTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			float4 _DetailTex_ST;</span><br><span class="line">			<span class="type">float</span> _ScrollX;</span><br><span class="line">			<span class="type">float</span> _Scroll2X;</span><br><span class="line">			<span class="type">float</span> _Multiplier;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float4 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert (a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, <span class="number">0.0</span>) * _Time.y);<span class="comment">//frac返回小数部分</span></span><br><span class="line">				o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, <span class="number">0.0</span>) * _Time.y);</span><br><span class="line">				<span class="comment">//首先利用TRANSFORM_TEX得到初始的纹理坐标，然后利用时间变量再水平方向上对纹理坐标偏移，达到滚动的效果</span></span><br><span class="line">				<span class="comment">//这里把两张纹理的坐标存储在同一个变量o.uv中来减少占用的插值寄存器空间</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">				fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">				fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);<span class="comment">//利用坐标对纹理采样</span></span><br><span class="line">				</span><br><span class="line">				fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);<span class="comment">//使用第二层纹理的透明通道的值混合两张纹理</span></span><br><span class="line">				c.rgb *= _Multiplier;<span class="comment">//调整亮度</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> c;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;VertexLit&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-3-顶点动画"><a href="#11-3-顶点动画" class="headerlink" title="11.3 顶点动画"></a>11.3 顶点动画</h3><p>顶点动画可以用来模拟飘动的旗帜、流动的河水等；</p>
<h4 id="11-3-1-流动的河流"><a href="#11-3-1-流动的河流" class="headerlink" title="11.3.1 流动的河流"></a>11.3.1 流动的河流</h4><p>河流的模拟是顶点动画最常见的应用之一，它的原理通常就是使用正弦函数等来模拟水流的波动效果。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Water&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//河流纹理</span></span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="comment">//控制整体颜色</span></span><br><span class="line">		_Magnitude (&quot;Distortion Magnitude&quot;, Float) = <span class="number">1</span><span class="comment">//控制水流波动的幅度</span></span><br><span class="line"> 		_Frequency (&quot;Distortion Frequency&quot;, Float) = <span class="number">1</span><span class="comment">//控制波动频率</span></span><br><span class="line"> 		_InvWaveLength (&quot;Distortion Inverse Wave Length&quot;, Float) = <span class="number">10</span><span class="comment">//控制波长的倒数</span></span><br><span class="line"> 		_Speed (&quot;Speed&quot;, Float) = <span class="number">0.5</span><span class="comment">//控制河流速度</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;</span><br><span class="line">		<span class="comment">//除了设置透明效果外，还设置了DisableBatching，因为批处理会合并所有相关的模型，而这些模型各自的模型空间就会丢失，而本例中，我们需要在物体的模型空间下对顶点位置进行偏移</span></span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			ZWrite Off</span><br><span class="line">			Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">			Cull Off</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			<span class="meta">#pragma vertex vert </span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot; </span></span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">float</span> _Magnitude;</span><br><span class="line">			<span class="type">float</span> _Frequency;</span><br><span class="line">			<span class="type">float</span> _InvWaveLength;</span><br><span class="line">			<span class="type">float</span> _Speed;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				</span><br><span class="line">				float4 <span class="keyword">offset</span>;<span class="comment">//定义顶点位移量</span></span><br><span class="line">				<span class="keyword">offset</span>.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);<span class="comment">//我们仅对x方向位移，因此yzw的位移量设置为0</span></span><br><span class="line">				<span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">				<span class="comment">//利用_Frequency属性和内置的时间变量来控制正弦函数的频率，为了让不同位置有不同的位置，对结果加上了位置分量并乘波长的倒数来控制波长，最后乘上幅度属性来控制波动幅度；</span></span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex + <span class="keyword">offset</span>);<span class="comment">//将偏移量加到顶点位置上；</span></span><br><span class="line">				</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">				o.uv +=  float2(<span class="number">0.0</span>, _Time.y * _Speed);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;<span class="comment">//片元着色器仅需对纹理采样并控制颜色即可；</span></span><br><span class="line">				fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">				c.rgb *= _Color.rgb;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> c;</span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="11-3-2-广告牌"><a href="#11-3-2-广告牌" class="headerlink" title="11.3.2 广告牌"></a>11.3.2 广告牌</h4><p>广告牌技术会根据视角方向来旋转一个被纹理着色的多边形，使多边形看起来总是面对摄像机，该技术用于渲染烟雾、云朵、闪光效果等；</p>
<p>广告牌技术的本质就是构建旋转矩阵，使用的基向量通常就是表面法线、指向上的方向和指向右的方向；除此之外我们还需要指定一个锚点，这个锚点在旋转过程中是固定不变的，以此来确定多边形在空间中的位置；</p>
<p>难点在于，如何根据需求构建三个相互正交的基向量；计算过程通常是，我们首先会通过初始计算得到目标的表面法线和指向上的方向，而两者往往是不垂直的。但是两者之一是固定的，例如：</p>
<ul>
<li>模拟草丛时，我们希望广告牌指向上的方向永远是(0,1,0)，而法线方向应该随视角变化；</li>
<li>模拟粒子效果时，我们希望法线方向是固定的，即总是指向视角方向，指向上的方向可以发生变化；</li>
</ul>
<p>我们假设法线方向是固定的，首先我们根据初始的表面法线和指向上的方向来计算出目标方向的指向右的方向：right &#x3D; up x normal（叉积），对其归一化后，再由法线方向和指向右的方向计算出正交的指向上的方向即可：up’ &#x3D; normal x right；</p>
<p>至此，我们就可以得到用于旋转的三个正交基了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-fc0ad6026c19e6c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="计算过程图示"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">11</span>/Billboard&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//广告牌显示的透明纹理</span></span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="comment">//控制整体颜色</span></span><br><span class="line">		_VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span><span class="comment">//调整是固定法线还是固定指向上的方向，即约束垂直方向的程度 </span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		<span class="comment">// Need to disable batching because of the vertex animation</span></span><br><span class="line">		Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;DisableBatching&quot;=&quot;True&quot;&#125;<span class="comment">//我们需要物体模型空间下的锚点进行计算，因此需要关闭批处理</span></span><br><span class="line">		</span><br><span class="line">		Pass &#123; </span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			ZWrite Off</span><br><span class="line">			Blend SrcAlpha OneMinusSrcAlpha <span class="comment">//设置透明相关</span></span><br><span class="line">			Cull Off <span class="comment">//关闭剔除让每个面都能显示</span></span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			fixed _VerticalBillboarding;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert (a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				</span><br><span class="line">				float3 center = float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//设置模型空间的原点为广告牌的锚点</span></span><br><span class="line">				float3 viewer = mul(unity_WorldToObject,float4(_WorldSpaceCameraPos, <span class="number">1</span>));<span class="comment">//获取模型空间下的视角位置</span></span><br><span class="line">				</span><br><span class="line">				float3 normalDir = viewer - center;</span><br><span class="line">				<span class="comment">// If _VerticalBillboarding equals 1, we use the desired view dir as the normal dir</span></span><br><span class="line">				<span class="comment">// Which means the normal dir is fixed</span></span><br><span class="line">				<span class="comment">// Or if _VerticalBillboarding equals 0, the y of normal is 0</span></span><br><span class="line">				<span class="comment">// Which means the up dir is fixed</span></span><br><span class="line">				normalDir.y =normalDir.y * _VerticalBillboarding;<span class="comment">//当_VerticalBillboarding为1时，意味着法线方向固定为视角方向；为0时，意味着向上方向固定为(0,1,0)</span></span><br><span class="line">				normalDir = <span class="built_in">normalize</span>(normalDir);<span class="comment">//最后对法线方向归一化得到单位矢量</span></span><br><span class="line">				<span class="comment">// Get the approximate up dir</span></span><br><span class="line">				<span class="comment">// If normal dir is already towards up, then the up dir is towards front</span></span><br><span class="line">				float3 upDir = <span class="built_in">abs</span>(normalDir.y) &gt; <span class="number">0.999</span> ? float3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) : float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//对法线的y分量进行判断，以得到合适的向上方向；</span></span><br><span class="line">				float3 rightDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(upDir, normalDir));<span class="comment">//根据法线方向和粗略的向上方向得到向右方向</span></span><br><span class="line">				upDir = <span class="built_in">normalize</span>(<span class="built_in">cross</span>(normalDir, rightDir));<span class="comment">//根据准确的法线方向和向右方向得到最后的向上方向</span></span><br><span class="line">				</span><br><span class="line">				float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">				float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line">                <span class="comment">//根据原始的位置相对于锚点的偏移量以及三个正交基矢量得到新的顶点位置</span></span><br><span class="line">				o.pos = UnityObjectToClipPos(float4(localPos, <span class="number">1</span>));<span class="comment">//把模型空间的顶点位置变换到裁剪空间中</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag (v2f i) : SV_Target &#123;</span><br><span class="line">				fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">				c.rgb *= _Color.rgb;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> c;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上例中，我们使用的是Unity自带的Quad作为广告牌而不能用Plane，因为代码建立在一个竖直摆放的多边形的基础上，即这个多边形的顶点结构需要满足在模型空间下是数值排列的，这样我们才能使用v.vertex来计算得到正确的相对于中心的位置偏移量；</p>
<h4 id="11-3-3-注意事项"><a href="#11-3-3-注意事项" class="headerlink" title="11.3.3 注意事项"></a>11.3.3 注意事项</h4><p>在使用顶点动画的时候，批处理往往会破坏效果，我们虽然可以关闭，但是这会带来一定的性能下降，增加了Draw Call，因此我们应该尽量避免使用模型空间下的一些绝对位置和方向来进行计算；</p>
<p>如果想要对包含了顶点动画的物体添加阴影，也不能用默认回调Pass的方法，因为ShadowCaster Pass中没有顶点动画，因此我们需要自定义一个ShadowCaster Pass；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">	Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line">			</span><br><span class="line">	CGPROGRAM</span><br><span class="line">			</span><br><span class="line">	<span class="meta">#pragma vertex vert</span></span><br><span class="line">	<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">	<span class="meta">#pragma multi_compile_shadowcaster</span></span><br><span class="line">			</span><br><span class="line">	<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">	<span class="type">float</span> _Magnitude;</span><br><span class="line">	<span class="type">float</span> _Frequency;</span><br><span class="line">	<span class="type">float</span> _InvWaveLength;</span><br><span class="line">	<span class="type">float</span> _Speed;</span><br><span class="line">			</span><br><span class="line">	struct v2f &#123; </span><br><span class="line">	    V2F_SHADOW_CASTER;</span><br><span class="line">	&#125;;</span><br><span class="line">			</span><br><span class="line">	v2f vert(appdata_base v) &#123;</span><br><span class="line">		v2f o;</span><br><span class="line">				</span><br><span class="line">		float4 <span class="keyword">offset</span>;</span><br><span class="line">		<span class="keyword">offset</span>.yzw = float3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">		<span class="keyword">offset</span>.x = <span class="built_in">sin</span>(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">		v.vertex = v.vertex + <span class="keyword">offset</span>;</span><br><span class="line"></span><br><span class="line">		TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">	fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">		 SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">	&#125;</span><br><span class="line">	ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十二章-屏幕后处理效果"><a href="#第十二章-屏幕后处理效果" class="headerlink" title="第十二章 屏幕后处理效果"></a>第十二章 屏幕后处理效果</h2><h3 id="12-1-建立一个基本的屏幕后处理脚本系统"><a href="#12-1-建立一个基本的屏幕后处理脚本系统" class="headerlink" title="12.1 建立一个基本的屏幕后处理脚本系统"></a>12.1 建立一个基本的屏幕后处理脚本系统</h3><p>屏幕后处理，通常指<strong>在渲染完整个场景得到屏幕图像后</strong>，再对这个图像进行一系列操作，实现各种屏幕特效，使用这种技术，可以为游戏画面添加更多的艺术效果，例如景深、运动模糊等；</p>
<p>因此想要实现后处理的基础在于得到渲染后的屏幕图像，即抓取屏幕，而Unity为我们提供了一个方便的接口——OnRenderImage函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonoBehaveiour.OnRenderImage (RenderTexture src，RenderTexture dest)</span><br></pre></td></tr></table></figure>

<p>OnRenderImage(src,dest)是Camera的一个回调（message），他会在camera执行渲染时候被调用，官方给的大部分Image Effect的实现都是用了这个回调</p>
<p>当我们在脚本中声明此函数后，Unity会把当前渲染得到的图像存储在第一个参数对应的源渲染纹理中，通过函数中的一系列操作后，再把目标渲染纹理，即第二个参数对应的渲染纹理显示到屏幕上。在OnRenderImage函数中，我们通常利用Graphics.Blit函数来完成对渲染纹理的处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span><span class="params">(Texture src, RenderTexture dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span><span class="params">(Texture src, RenderTexture dest, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Blit</span><span class="params">(Texture src, Material mat, <span class="type">int</span> pass = <span class="number">-1</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中src对应了源纹理，通常是当前屏幕的渲染纹理或是上一步处理之后得到的渲染纹理；参数dest是目标渲染纹理，如果它的值为null就会直接将结果显示在屏幕上；mat是我们使用的材质，这个材质使用的Shader会进行各种屏幕后处理操作，而src纹理会被传递给Shader中名为_MainTex的纹理属性；pass的默认值为-1，表示会依次调用Shader内的所有Pass，否则只会调用给定索引的Pass；</p>
<p>默认情况下OnRenderImage会在所有不透明和透明的Pass执行完毕后被调用，以便对所有游戏对象产生影响，但有时候我们希望在不透明的Pass执行之后立即执行，此时我们可以在函数前添加ImageEffectOpaque属性来实现（13.4节例）；</p>
<p>因此要在Unity中实现后处理的步骤：</p>
<ol>
<li>在摄像中添加一个用于屏幕后处理的脚本，在该脚本中实现OnRenderImage函数来获取屏幕的渲染纹理；</li>
<li>调用Graphics.Blit函数使用Shader对图像进行处理；</li>
<li>把返回的渲染纹理显示到屏幕上；</li>
</ol>
<p>对于一些复杂的屏幕特效，可能需要多次调用Graphics.Blit函数来对上一次的输出进行下一步处理；</p>
<p>我们创建一个用于屏幕后处理效果的基类，实现各种屏幕特效时，只需要继承自该基类，再实现派生类中不同的操作即可；</p>
<p>基类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]<span class="comment">//我们希望在编辑器状态下也可以执行查看效果</span></span><br><span class="line">[<span class="meta">RequireComponent (typeof(Camera))</span>]<span class="comment">//所有屏幕后处理效果都需要绑定在某个摄像机上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectsBase</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Called when start</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>()</span> &#123;<span class="comment">//检查各种资源和条件是否满足</span></span><br><span class="line">		<span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (isSupported == <span class="literal">false</span>) &#123;</span><br><span class="line">			NotSupported();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>) &#123;</span><br><span class="line">			Debug.LogWarning(<span class="string">&quot;This platform does not support image effects or render textures.&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>()</span> &#123;</span><br><span class="line">		enabled = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">		CheckResources();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//需要创建此效果使用的材质时调用</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//该函数接受两个参数，第一个指定了该特效需要使用的Shader，第二个参数则是用于后期处理的材质；</span></span><br><span class="line">	<span class="comment">//该函数首先检查Shader的可用性，检查通过后就返回一个使用了该Shader的材质，否则返回null；</span></span><br><span class="line">		<span class="keyword">if</span> (shader == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">			<span class="keyword">return</span> material;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!shader.isSupported) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">			material.hideFlags = HideFlags.DontSave;</span><br><span class="line">			<span class="keyword">if</span> (material)</span><br><span class="line">				<span class="keyword">return</span> material;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-2-调整屏幕的亮度、饱和度和对比度"><a href="#12-2-调整屏幕的亮度、饱和度和对比度" class="headerlink" title="12.2 调整屏幕的亮度、饱和度和对比度"></a>12.2 调整屏幕的亮度、饱和度和对比度</h3><p>基于上节的基类，调整亮度、饱和度和对比度的派生类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrightnessSaturationAndContrast</span> : <span class="title">PostEffectsBase</span> &#123;<span class="comment">//继承上节创建的基类</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Shader briSatConShader;</span><br><span class="line">	<span class="keyword">private</span> Material briSatConMaterial;</span><br><span class="line">	<span class="keyword">public</span> Material material &#123;  </span><br><span class="line">		<span class="keyword">get</span> &#123;</span><br><span class="line">			briSatConMaterial = CheckShaderAndCreateMaterial(briSatConShader, briSatConMaterial);<span class="comment">//调用基类函数</span></span><br><span class="line">			<span class="keyword">return</span> briSatConMaterial;</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">float</span> brightness = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">float</span> saturation = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">Range(0.0f, 3.0f)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">float</span> contrast = <span class="number">1.0f</span>;</span><br><span class="line">	<span class="comment">//分别表示调整亮度、饱和度和对比度的参数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//每当该函数被调用时，它会检查材质是否可用，若可用就把参数传递给材质，再调用Graphics.Blit处理，否则不进行处理，直接显示原图像到屏幕上</span></span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">			material.SetFloat(<span class="string">&quot;_Brightness&quot;</span>, brightness);</span><br><span class="line">			material.SetFloat(<span class="string">&quot;_Saturation&quot;</span>, saturation);</span><br><span class="line">			material.SetFloat(<span class="string">&quot;_Contrast&quot;</span>, contrast);</span><br><span class="line"></span><br><span class="line">			Graphics.Blit(src, dest, material);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Graphics.Blit(src, dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用到的Shader：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Brightness Saturation And Contrast&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Brightness (&quot;Brightness&quot;, Float) = <span class="number">1</span></span><br><span class="line">		_Saturation(&quot;Saturation&quot;, Float) = <span class="number">1</span></span><br><span class="line">		_Contrast(&quot;Contrast&quot;, Float) = <span class="number">1</span><span class="comment">//声明本例使用的各个属性               </span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Pass &#123;  </span><br><span class="line">			ZTest Always Cull Off ZWrite Off</span><br><span class="line">			<span class="comment">//屏幕后处理实际上是在场景中绘制了一个与屏幕等大的四边形面片，我们关闭深度写入防止他挡住在它之后渲染的物体；</span></span><br><span class="line">                </span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment frag  </span></span><br><span class="line">			  </span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;  </span></span><br><span class="line">			  </span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">			half _Brightness;</span><br><span class="line">			half _Saturation;</span><br><span class="line">			half _Contrast;</span><br><span class="line">			  </span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				half2 uv: TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			  </span><br><span class="line">			v2f vert(appdata_img v) &#123;<span class="comment">//使用了Unity内置的appdata_img结构体作为定点着色器的输入，他只包含了必须的顶点坐标和纹理坐标等变量</span></span><br><span class="line">				v2f o;</span><br><span class="line">				</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uv = v.texcoord;</span><br><span class="line">						 </span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;<span class="comment">//实现用于调整亮度、饱和度和对比度的片元着色器</span></span><br><span class="line">				fixed4 renderTex = tex2D(_MainTex, i.uv);<span class="comment">//得到对屏幕图像的采样结果</span></span><br><span class="line">				  </span><br><span class="line">				fixed3 finalColor = renderTex.rgb * _Brightness;<span class="comment">//乘上亮度值即可调整亮度</span></span><br><span class="line">				</span><br><span class="line">				fixed luminance = <span class="number">0.2125</span> * renderTex.r + <span class="number">0.7154</span> * renderTex.g + <span class="number">0.0721</span> * renderTex.b;<span class="comment">//通过对每个颜色分量乘以一个特定的系数相加得到亮度值</span></span><br><span class="line">				fixed3 luminanceColor = fixed3(luminance, luminance, luminance);<span class="comment">//用该亮度值创建了一个饱和度为0的颜色值</span></span><br><span class="line">				finalColor = lerp(luminanceColor, finalColor, _Saturation);<span class="comment">//使用_Saturation属性和上一步得到的颜色之间进行插值，从而得到希望的饱和度颜色</span></span><br><span class="line">				</span><br><span class="line">				fixed3 avgColor = fixed3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>);<span class="comment">//对比度与上述类似，先得到对比度为0的颜色值</span></span><br><span class="line">				finalColor = lerp(avgColor, finalColor, _Contrast);<span class="comment">//再使用_Contrast属性和上步得到的颜色插值，得到最终的处理结果</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(finalColor, renderTex.a);  </span><br><span class="line">			&#125;  </span><br><span class="line">			  </span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Fallback Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-3-边缘检测"><a href="#12-3-边缘检测" class="headerlink" title="12.3 边缘检测"></a>12.3 边缘检测</h3><p>边缘检测是描边效果的一种实现方法；</p>
<p>边缘检测的原理是利用一些边缘检测算子对图像进行<strong>卷积</strong>操作；</p>
<h4 id="12-3-1-什么是卷积"><a href="#12-3-1-什么是卷积" class="headerlink" title="12.3.1 什么是卷积"></a>12.3.1 什么是卷积</h4><p>在图像处理中，卷积操作指的就是使用一个**卷积核(kernel)**，对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形网格结构(例如2x2,3x3的方形区域)，该区域内每个方格都有一个权重值。当对图像中的某个像素进行卷积时，我们会把卷积核的中心放置于该像素上，翻转核(将该矩阵旋转180°)之后再依次计算核中每个元素和其覆盖的图像的像素值的乘积并求和，得到的结果就是该位置的新像素值：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-cf65307b240af2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/619/format/webp" alt="img"></p>
<p>该过程可以实现很多常见的图像处理效果，例如图像模糊、边缘检测等。例如如果我们想要对图像进行均值模糊，可以使用一个3x3的卷积核，核内每个元素的值均为1&#x2F;9；</p>
<h4 id="12-3-2-边缘检测算子"><a href="#12-3-2-边缘检测算子" class="headerlink" title="12.3.2 边缘检测算子"></a>12.3.2 边缘检测算子</h4><p>卷积操作的关键在于选择的卷积核；</p>
<p>对于边缘检测，首先考虑边，如果相邻像素之间存在差别明显的颜色，亮度，纹理等属性，我们就会认为他们之间应该有一条边界，这种相邻像素之间的差值可以用**梯度(gradient)**来表示，可以想象得到，边缘处的梯度绝对值会比较大。基于这样的理解，有几种不同的边缘检测算子：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-15058cb96b36d9da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/769/format/webp" alt="img"></p>
<p>这些算子都包含了两个方向的卷积核，分别用于检测水平方向和竖直方向上的边缘信息。在进行边缘检测时，我们需要对每个像素分别进行一次卷积计算，得到两个方向上的梯度值Gx和Gy，整体的梯度则可以如此计算：<br>$$<br>G &#x3D; \sqrt{G_x^2 + G_y^2}<br>$$<br>但是该计算包含开根，处于性能考虑，我们有时会使用绝对值操作代替：<br>$$<br>G &#x3D; |G_x|+|G_y|<br>$$<br>由此，梯度G越大的像素越有可能是边缘点；</p>
<h4 id="12-3-3-实现"><a href="#12-3-3-实现" class="headerlink" title="12.3.3 实现"></a>12.3.3 实现</h4><p>首先建立一个脚本继承12.1节中的基类，设置好相应参数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> edgesOnly = <span class="number">0.0f</span>;<span class="comment">//该值为0时，边缘会叠加在原渲染图像上；为1时，则只会显示边缘，不显示原渲染图像</span></span><br><span class="line"><span class="keyword">public</span> Color edgeColor = Color.black;<span class="comment">//边缘颜色</span></span><br><span class="line"><span class="keyword">public</span> Color backgroundColor = Color.white;<span class="comment">//背景颜色</span></span><br></pre></td></tr></table></figure>

<p>Shader部分：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Edge Detection&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//输入的渲染纹理</span></span><br><span class="line">		_EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="comment">//三个对应脚本的属性</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Pass &#123;  </span><br><span class="line">			ZTest Always Cull Off ZWrite Off</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment fragSobel</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			<span class="keyword">uniform</span> half4 _MainTex_TexelSize; <span class="comment">//该变量是Unity提供的访问纹理对应的每个纹素大小，我们要利用他来计算各个相邻区域的纹理坐标</span></span><br><span class="line">			fixed _EdgeOnly;</span><br><span class="line">			fixed4 _EdgeColor;</span><br><span class="line">			fixed4 _BackgroundColor; <span class="comment">//声明对应变量</span></span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">				<span class="comment">//定义了一个维数为9的纹理数组，对应了使用Sobel算子采样时需要的9个邻域纹理坐标，通过把计算采样纹理坐标的代码从片元着色器中转移到顶点着色器中，可以减少运算，提高性能；</span></span><br><span class="line">				<span class="comment">//由于从顶点着色器到片元着色器的插值是线性的，因此这样的转移并不会影响纹理坐标的计算结果；</span></span><br><span class="line">			&#125;;</span><br><span class="line">			  </span><br><span class="line">			v2f vert(appdata_img v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				half2 uv = v.texcoord;</span><br><span class="line">				</span><br><span class="line">				o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">				o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">				o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">				o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">				o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">				o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">				o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">				o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//获得相邻坐标</span></span><br><span class="line">						 </span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed luminance(fixed4 color) &#123;</span><br><span class="line">				<span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; <span class="comment">//亮度值计算</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			half Sobel(v2f i) &#123;</span><br><span class="line">				<span class="keyword">const</span> half Gx[<span class="number">9</span>] = &#123;<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>,</span><br><span class="line">										<span class="number">-2</span>,  <span class="number">0</span>,  <span class="number">2</span>,</span><br><span class="line">										<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>&#125;;</span><br><span class="line">				<span class="keyword">const</span> half Gy[<span class="number">9</span>] = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>,</span><br><span class="line">										<span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,</span><br><span class="line">										<span class="number">1</span>,  <span class="number">2</span>,  <span class="number">1</span>&#125;;<span class="comment">//定义水平和竖直方向的卷积核</span></span><br><span class="line">				</span><br><span class="line">				half texColor;</span><br><span class="line">				half edgeX = <span class="number">0</span>;</span><br><span class="line">				half edgeY = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">0</span>; it &lt; <span class="number">9</span>; it++) &#123;</span><br><span class="line">					texColor = luminance(tex2D(_MainTex, i.uv[it]));<span class="comment">//依次对九个像素采样，用亮度值和卷积核中对应权重相乘</span></span><br><span class="line">					edgeX += texColor * Gx[it];</span><br><span class="line">					edgeY += texColor * Gy[it];<span class="comment">//分别叠加到水平和竖直的梯度值上</span></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				half edge = <span class="number">1</span> - <span class="built_in">abs</span>(edgeX) - <span class="built_in">abs</span>(edgeY);<span class="comment">//用1减去水平和竖直方向的梯度值，则edge越小则越可能是边缘点</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> edge;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 fragSobel(v2f i) : SV_Target &#123;</span><br><span class="line">				half edge = Sobel(i);<span class="comment">//调用Sobel函数计算当前像素的梯度值</span></span><br><span class="line">				</span><br><span class="line">				fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">4</span>]), edge);<span class="comment">//用梯度值值计算背景为原图的颜色值</span></span><br><span class="line">				fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<span class="comment">//用梯度值计算背景为纯色的颜色值</span></span><br><span class="line">				<span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);<span class="comment">//使用_EdgeOnly插值获得最终的像素值</span></span><br><span class="line"> 			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本节实现的边缘检测仅仅利用了屏幕颜色信息，实际上物体的纹理、阴影等信息均会影响边缘检测的结果，为了得到更准确的边缘信息，我们会对屏幕的深度纹理和法线纹理上进行边缘检测(13.4节)；</p>
<h3 id="12-4-高斯模糊"><a href="#12-4-高斯模糊" class="headerlink" title="12.4 高斯模糊"></a>12.4 高斯模糊</h3><p>高斯模糊是卷积的另一个常见应用；模糊的实现有很多方法，例如均值模糊和中值模糊，均值模糊使用的卷积核中各个元素值都相等，且相加等于1，也就是说卷积后得到的像素值是其邻域内各个像素值的平均值；而中值模糊是选择邻域内对所有像素后排序得到的中值替换源颜色；高斯模糊则是更高级的一种模糊方法；</p>
<h4 id="12-4-1-高斯滤波"><a href="#12-4-1-高斯滤波" class="headerlink" title="12.4.1 高斯滤波"></a>12.4.1 高斯滤波</h4><p>高斯模糊使用的卷积核名为高斯核，高斯核是一个正方形大小的滤波核，其中每个元素的计算都是基于下面的高斯方程：<br>$$<br>G(x,y) &#x3D; \frac{1}{2πσ^2}e^{-\frac{x^2+y^2}{2σ^2}}<br>$$<br>其中σ是标准方差(一般取值为1)，x和y对应了当前位置到卷积核中心的整数距离，要构建一个高斯核，我们只需要计算高斯核中各个位置对应的高斯值。为了保证滤波后的图像不会变暗，我们需要对高斯核中的权重进行归一化，即让每个权重除以所有权重的核，保证所有权重的和为1；因此，高斯函数中e前面的系数实际不会影响结果；</p>
<p>高斯方程模拟了邻域每个像素对当前处理像素的影响程度——距离越近，影响越大；</p>
<p>高斯核的维数越高，模糊程度越大；使用一个NxN的高斯核对图像进行卷积滤波，就需要NxNxWxH(W和H分别是图像宽高)次纹理采样。</p>
<p>但是我们可以把二维高斯函数拆分成两个一位函数，也就是说使用两个一维的高斯核，先后对图像进行滤波，它们得到的结果和直接使用二维高斯核是一样的，但减少了采样次数(2xNxWxH)</p>
<p>标准方差为1的5x5大小的高斯核：左图为权重分布，右图为拆分结果</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-08ec165085822c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/724/format/webp" alt="img"></p>
<p>我们将先后调用两个Pass，第一个Pass将会使用竖直方向的一维高斯核进行滤波，第二个Pass使用水平方向，得到最终的目标图像；在实现中，我们还将利用图像缩放来进一步提高性能，并通过调整<strong>高斯滤波的应用次数</strong>来控制模糊程度</p>
<h4 id="12-4-2-实现"><a href="#12-4-2-实现" class="headerlink" title="12.4.2 实现"></a>12.4.2 实现</h4><p>首先是继承后处理基类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GaussianBlur</span> : <span class="title">PostEffectsBase</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Shader gaussianBlurShader;</span><br><span class="line">	<span class="keyword">private</span> Material gaussianBlurMaterial = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Material material &#123;  </span><br><span class="line">		<span class="keyword">get</span> &#123;</span><br><span class="line">			gaussianBlurMaterial = CheckShaderAndCreateMaterial(gaussianBlurShader, gaussianBlurMaterial);</span><br><span class="line">			<span class="keyword">return</span> gaussianBlurMaterial;</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[<span class="meta">Range(0, 4)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> iterations = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">	[<span class="meta">Range(0.2f, 3.0f)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">float</span> blurSpread = <span class="number">0.6f</span>;</span><br><span class="line">	</span><br><span class="line">	[<span class="meta">Range(1, 8)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> downSample = <span class="number">2</span>;<span class="comment">//分别控制迭代次数、模糊范围和缩放系数</span></span><br><span class="line">	<span class="comment">//blurSpread和downSample都是出于性能的考虑，在高斯核维数不变的情况下，_BlurSize越大，模糊程度越高，但是采样数不受影响，但是过大的_BlurSize值会造成虚影；</span></span><br><span class="line">	<span class="comment">//而downSample越大，需要处理的像素数越少，同时也能进一步提高模糊程度，但过大的downSample可能会使图像像素化；</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 1st edition: just apply blur 只使用模糊</span></span><br><span class="line"><span class="comment">//	void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//		if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//			int rtW = src.width;</span></span><br><span class="line"><span class="comment">//			int rtH = src.height;</span></span><br><span class="line"><span class="comment">//			RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			// Render the vertical pass</span></span><br><span class="line"><span class="comment">//			Graphics.Blit(src, buffer, material, 0);//使用第一个Pass(使用竖直方向的一维高斯核进行滤波)，结果存储在buffer中</span></span><br><span class="line"><span class="comment">//			// Render the horizontal pass</span></span><br><span class="line"><span class="comment">//			Graphics.Blit(buffer, dest, material, 1);//对buffer使用第二个Pass(水平方向滤波)，返回最终的屏幕图像</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			RenderTexture.ReleaseTemporary(buffer);//释放之前的缓存</span></span><br><span class="line"><span class="comment">//		&#125; else &#123;</span></span><br><span class="line"><span class="comment">//			Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125; </span></span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 2nd edition: scale the render texture 利用缩放对图像进行降采样，减少处理的像素个数(由downSample控制)</span></span><br><span class="line"><span class="comment">//	void OnRenderImage (RenderTexture src, RenderTexture dest) &#123;</span></span><br><span class="line"><span class="comment">//		if (material != null) &#123;</span></span><br><span class="line"><span class="comment">//			int rtW = src.width/downSample;</span></span><br><span class="line"><span class="comment">//			int rtH = src.height/downSample;</span></span><br><span class="line"><span class="comment">//			RenderTexture buffer = RenderTexture.GetTemporary(rtW, rtH, 0);//使用小于原屏幕分辨率的尺寸</span></span><br><span class="line"><span class="comment">//			buffer.filterMode = FilterMode.Bilinear;//将临时渲染纹理的滤波模式设置为双线性</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			// Render the vertical pass</span></span><br><span class="line"><span class="comment">//			Graphics.Blit(src, buffer, material, 0);</span></span><br><span class="line"><span class="comment">//			// Render the horizontal pass</span></span><br><span class="line"><span class="comment">//			Graphics.Blit(buffer, dest, material, 1);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			RenderTexture.ReleaseTemporary(buffer);</span></span><br><span class="line"><span class="comment">//		&#125; else &#123;</span></span><br><span class="line"><span class="comment">//			Graphics.Blit(src, dest);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 3rd edition: use iterations for larger blur 考虑了高斯模糊的迭代次数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">			<span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line"></span><br><span class="line">			RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">			<span class="comment">//该函数分配了一块与屏幕图像大小相同的缓冲区，因为高斯模糊需要调用两个Pass，我们需要使用一块中间缓存来存储第一个Pass执行完毕后得到的模糊结果 </span></span><br><span class="line">			buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line"></span><br><span class="line">			Graphics.Blit(src, buffer0);<span class="comment">//将原图像缩放后存储到buffer0中</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;<span class="comment">//对于每次循环，首先输入buffer0执行第一个Pass，输出到buffer1中，清空buffer0，再将buffer1存储到buffer0中，第二个Pass重复</span></span><br><span class="line">				material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line"></span><br><span class="line">				RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Render the vertical pass</span></span><br><span class="line">				Graphics.Blit(buffer0, buffer1, material, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">				buffer0 = buffer1;</span><br><span class="line">				buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Render the horizontal pass</span></span><br><span class="line">				Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">				RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">				buffer0 = buffer1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Graphics.Blit(buffer0, dest);<span class="comment">//将最终得到的图像显示到屏幕上</span></span><br><span class="line">			RenderTexture.ReleaseTemporary(buffer0);<span class="comment">//释放之前分配的缓存</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Graphics.Blit(src, dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Shader：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE<span class="comment">//使用CGINCLUDE来组织代码，在SubShader块中直接使用CGINCLUDE ENDCG</span></span><br><span class="line">		<span class="comment">//这些代码不需要包含在任何Pass语义块中，使用时，我们只需要在Pass中直接指定需要使用的顶点着色器和片元着色器函数名即可</span></span><br><span class="line">		<span class="comment">//CGINCLUDE类似于C++中头文件的功能，由于高斯模糊需要定义两个Pass，但他们使用的片元着色器代码是完全相同的，这样可以避免我们编写两个一样的frag</span></span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;  </span><br><span class="line">		half4 _MainTex_TexelSize;<span class="comment">//由于需要相邻像素的坐标，我们使用Unity提供的该变量来计算</span></span><br><span class="line">		<span class="type">float</span> _BlurSize;</span><br><span class="line">		  </span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv[<span class="number">5</span>]: TEXCOORD0;<span class="comment">//5x5的高斯核可以拆分成两个大小为5的一维高斯核；uv[0]是当前的采样纹理，剩下的四个坐标则是高斯模糊中对邻域采样时使用的纹理坐标</span></span><br><span class="line">		&#125;;</span><br><span class="line">		  </span><br><span class="line">		v2f vertBlurVertical(appdata_img v) &#123;<span class="comment">//水平方向的顶点着色器</span></span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">1.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv - float2(<span class="number">0.0</span>, _MainTex_TexelSize.y * <span class="number">2.0</span>) * _BlurSize;</span><br><span class="line">			<span class="comment">//和_BlurSize相乘来控制采样距离，在高斯核维数不变的情况下，_BlurSize越大，模糊程度越高，但是采样数不受影响，但是过大的_BlurSize值会造成虚影；</span></span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		v2f vertBlurHorizontal(appdata_img v) &#123;<span class="comment">//竖直方向的顶点着色器</span></span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">1.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv - float2(_MainTex_TexelSize.x * <span class="number">2.0</span>, <span class="number">0.0</span>) * _BlurSize;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragBlur(v2f i) : SV_Target &#123;<span class="comment">//两个Pass共用的片元着色器</span></span><br><span class="line">			<span class="type">float</span> weight[<span class="number">3</span>] = &#123;<span class="number">0.4026</span>, <span class="number">0.2442</span>, <span class="number">0.0545</span>&#125;;<span class="comment">//由于一维高斯核的对称性，我们只需要记录三个高斯权重</span></span><br><span class="line">			</span><br><span class="line">			fixed3 sum = tex2D(_MainTex, i.uv[<span class="number">0</span>]).rgb * weight[<span class="number">0</span>];<span class="comment">//将sum初始化为当前的像素值乘以他的权重值</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++) &#123;<span class="comment">//根据对称性进行两次迭代，每次包含两次纹理采样，把像素值和权重相乘后的结果叠加到sum中</span></span><br><span class="line">				sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span><span class="number">-1</span>]).rgb * weight[it];</span><br><span class="line">				sum += tex2D(_MainTex, i.uv[it*<span class="number">2</span>]).rgb * weight[it];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> fixed4(sum, <span class="number">1.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		    </span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		ZTest Always Cull Off ZWrite Off</span><br><span class="line">		</span><br><span class="line">		Pass &#123;<span class="comment">//高斯模糊使用的两个Pass</span></span><br><span class="line">			NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;<span class="comment">//使用NAME语义定义了名字，因为该效果很常用，定义名字后可以在其他Shader中使用名字来调用</span></span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			  </span><br><span class="line">			<span class="meta">#pragma vertex vertBlurVertical  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">			  </span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;  </span><br><span class="line">			NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vertBlurHorizontal  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBlur</span></span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-5-Bloom效果"><a href="#12-5-Bloom效果" class="headerlink" title="12.5 Bloom效果"></a>12.5 Bloom效果</h3><p>Bloom是游戏中常见的一种屏幕效果，这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果；</p>
<p>Bloom的实现原理非常简单：我们首先根据一个阈值提取出图像中的较亮区域，把他们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-bb49dd7a658cd838.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>Bloom效果是建立在高斯模糊的基础上的，因此参数方面仅增加了一个新的参数来控制提取较亮区域时使用的阈值大小：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 4.0f)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> luminanceThreshold = <span class="number">0.6f</span>;</span><br></pre></td></tr></table></figure>

<p>尽管绝大多数情况下，图像的亮度值不会超过1；但如果我们开启了HDR，硬件会允许我们把颜色值存储在一个更高精度范围的缓冲中，此时像素的亮度值可能会超过1；因此，我们把luminanceThreshold的值规定在[0,4]。(HDR的内容详见18.4.3)</p>
<p>新的OnRenderImage：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">			material.SetFloat(<span class="string">&quot;_LuminanceThreshold&quot;</span>, luminanceThreshold);</span><br><span class="line"></span><br><span class="line">			<span class="built_in">int</span> rtW = src.width/downSample;</span><br><span class="line">			<span class="built_in">int</span> rtH = src.height/downSample;</span><br><span class="line">			</span><br><span class="line">			RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">			buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">			</span><br><span class="line">			Graphics.Blit(src, buffer0, material, <span class="number">0</span>);<span class="comment">//没有直接进行降采样处理，而是使用第一个Pass提取图像中的较亮区域，提取得到的较亮区域存储在buffer0中</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">				material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, <span class="number">1.0f</span> + i * blurSpread);</span><br><span class="line">				</span><br><span class="line">				RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Render the vertical pass</span></span><br><span class="line">				Graphics.Blit(buffer0, buffer1, material, <span class="number">1</span>);</span><br><span class="line">				</span><br><span class="line">				RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">				buffer0 = buffer1;</span><br><span class="line">				buffer1 = RenderTexture.GetTemporary(rtW, rtH, <span class="number">0</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Render the horizontal pass</span></span><br><span class="line">				Graphics.Blit(buffer0, buffer1, material, <span class="number">2</span>);<span class="comment">//第二三个Pass对应水平和竖直处理的操作</span></span><br><span class="line">				</span><br><span class="line">				RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">				buffer0 = buffer1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			material.SetTexture (<span class="string">&quot;_Bloom&quot;</span>, buffer0);  </span><br><span class="line">			Graphics.Blit (src, dest, material, <span class="number">3</span>);<span class="comment">//使用第四个Pass进行最后的混合</span></span><br><span class="line"></span><br><span class="line">			RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Graphics.Blit(src, dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Shader：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Bloom&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Bloom (&quot;Bloom (RGB)&quot;, <span class="number">2</span>D) = &quot;black&quot; &#123;&#125;<span class="comment">//高斯模糊后的较亮区域</span></span><br><span class="line">		_LuminanceThreshold (&quot;Luminance Threshold&quot;, Float) = <span class="number">0.5</span><span class="comment">//提取较量区域时使用的阈值</span></span><br><span class="line">		_BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		<span class="type">sampler2D</span> _Bloom;</span><br><span class="line">		<span class="type">float</span> _LuminanceThreshold;</span><br><span class="line">		<span class="type">float</span> _BlurSize;</span><br><span class="line">		</span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION; </span><br><span class="line">			half2 uv : TEXCOORD0;</span><br><span class="line">		&#125;;	</span><br><span class="line">		</span><br><span class="line">		v2f vertExtractBright(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			o.uv = v.texcoord;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed luminance(fixed4 color) &#123;<span class="comment">//计算亮度函数</span></span><br><span class="line">			<span class="keyword">return</span>  <span class="number">0.2125</span> * color.r + <span class="number">0.7154</span> * color.g + <span class="number">0.0721</span> * color.b; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragExtractBright(v2f i) : SV_Target &#123;</span><br><span class="line">			fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">			fixed val = <span class="built_in">clamp</span>(luminance(c) - _LuminanceThreshold, <span class="number">0.0</span>, <span class="number">1.0</span>);<span class="comment">//将采样得到的亮度值减去阈值，结果截取到[0,1]内，将该值和原像素值相乘，得到提取后的亮部区域</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> c * val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//以上是提取较亮区域使用的顶点着色器和片元着色器</span></span><br><span class="line"></span><br><span class="line">		struct v2fBloom &#123;</span><br><span class="line">			float4 pos : SV_POSITION; </span><br><span class="line">			half4 uv : TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		v2fBloom vertBloom(appdata_img v) &#123;</span><br><span class="line">			v2fBloom o;</span><br><span class="line">			</span><br><span class="line">			o.pos = UnityObjectToClipPos (v.vertex);</span><br><span class="line">			o.uv.xy = v.texcoord;		</span><br><span class="line">			o.uv.zw = v.texcoord;<span class="comment">//xy分量对应_MainTex，zw分量是_Bloom,独立出来是为的下方的平台差异化处理</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#if UNITY_UV_STARTS_AT_TOP			</span></span><br><span class="line">			<span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0.0</span>)</span><br><span class="line">				o.uv.w = <span class="number">1.0</span> - o.uv.w;<span class="comment">//对纹理坐标进行平台差异化处理(5.6.1节)</span></span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line">				        	</span><br><span class="line">			<span class="keyword">return</span> o; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragBloom(v2fBloom i) : SV_Target &#123;</span><br><span class="line">			<span class="keyword">return</span> tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);<span class="comment">//将两张纹理的采样结果相加混合</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//以上是混合亮部图像和原图像使用的顶点着色器和片元着色器</span></span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		ZTest Always Cull Off ZWrite Off</span><br><span class="line">		</span><br><span class="line">		Pass &#123;  </span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			<span class="meta">#pragma vertex vertExtractBright  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragExtractBright  </span></span><br><span class="line">			</span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line">		</span><br><span class="line">		UsePass &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Gaussian Blur/GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line">		<span class="comment">//第二三个Pass可以直接使用12.4节中的Pass，通过UsePass语义知名他们的Pass名即可(注意全部大写)</span></span><br><span class="line">		</span><br><span class="line">		Pass &#123;  </span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			<span class="meta">#pragma vertex vertBloom  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragBloom  </span></span><br><span class="line">			</span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-6-运动模糊"><a href="#12-6-运动模糊" class="headerlink" title="12.6 运动模糊"></a>12.6 运动模糊</h3><p>运动模糊是真实世界中的摄像机的一种效果，如果摄像机曝光时拍摄场景发生了变化，就会产生模糊的画面；</p>
<p>运动模糊的实现有多种方法：</p>
<ul>
<li>一种是利用一块**累积缓存(accumulation buffer)**，来混合多张连续的图像，当物体快速移动产生多张图像后，我们取它们之间的平均值作为最后的运动模糊图像，不过这种方法对性能的消耗很大，因为想要获取多张帧图像往往意味着需要在同一帧里渲染多次场景；</li>
<li>另一种使用广泛的方法是创建和使用**速度缓存(velocity buffer)**，这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小；</li>
<li>本节使用类似第一种的另一个方法，不需要在一帧中渲染多次场景，但需要保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图像中，从而产生一种运动轨迹的视觉效果；这种方法与原始的利用累积缓存的方法相比性能更好，但模糊效果可能略有影响；</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 0.9f)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">float</span> blurAmount = <span class="number">0.5f</span>;<span class="comment">//该值越大，运动拖尾的效果就越明显</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> RenderTexture accumulationTexture;<span class="comment">//定义一个RenderTexture类型的变量，保存之前图像叠加的结果</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123;</span><br><span class="line">		DestroyImmediate(accumulationTexture);<span class="comment">//在脚本不运行即调用OnDisable函数时，立即销毁accumulationTexture，因为我们需要在下次开始应用运动模糊时重新计算叠加图像</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (accumulationTexture == <span class="literal">null</span> || accumulationTexture.width != src.width || accumulationTexture.height != src.height)</span><br><span class="line">			&#123;<span class="comment">//判断accumulationTexture是否满足条件，他如果为空或者与当前屏幕分辨率不相等则重新创建一个</span></span><br><span class="line">				DestroyImmediate(accumulationTexture);</span><br><span class="line">				accumulationTexture = <span class="keyword">new</span> RenderTexture(src.width, src.height, <span class="number">0</span>);</span><br><span class="line">				accumulationTexture.hideFlags = HideFlags.HideAndDontSave;<span class="comment">//意味着这个变量不会显示在Hierarchy中，也不会保存到场景中</span></span><br><span class="line">				Graphics.Blit(src, accumulationTexture);<span class="comment">//用当前帧图像初始化该Texture</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// We are accumulating motion over frames without clear/discard</span></span><br><span class="line">			<span class="comment">// by design, so silence any performance warnings from Unity</span></span><br><span class="line">			accumulationTexture.MarkRestoreExpected();<span class="comment">//该函数表明了我们需要进行一个渲染纹理的恢复操作</span></span><br><span class="line">			<span class="comment">//恢复操作发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下；</span></span><br><span class="line"></span><br><span class="line">			material.SetFloat(<span class="string">&quot;_BlurAmount&quot;</span>, <span class="number">1.0f</span> - blurAmount);</span><br><span class="line"></span><br><span class="line">			Graphics.Blit (src, accumulationTexture, material);</span><br><span class="line">			<span class="comment">//本例中，我们每次调用该函数时都需要把当前的帧图像和accumulation中的混合，因此不清空，直接将src叠加上去</span></span><br><span class="line">			Graphics.Blit (accumulationTexture, dest);<span class="comment">//再将结果显示到屏幕上</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Graphics.Blit(src, dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Shader部分：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">12</span>/Motion Blur&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BlurAmount (&quot;Blur Amount&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		fixed _BlurAmount;</span><br><span class="line">		</span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv : TEXCOORD0;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		v2f vert(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			o.uv = v.texcoord;</span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragRGB (v2f i) : SV_Target &#123;</span><br><span class="line">			<span class="keyword">return</span> fixed4(tex2D(_MainTex, i.uv).rgb, _BlurAmount);<span class="comment">//对当前图像采样，并将其A通道的值设为_BlurAmount,以便在后面混合时可以使用他的透明通道进行混合</span></span><br><span class="line">		&#125;<span class="comment">//第一个片元着色器用于更新渲染纹理的RGB通道部分</span></span><br><span class="line">		</span><br><span class="line">		half4 fragA (v2f i) : SV_Target &#123;</span><br><span class="line">			<span class="keyword">return</span> tex2D(_MainTex, i.uv);<span class="comment">//直接返回采样结果即可，仅为维护渲染纹理的透明通道值，不让其受混合时使用的透明度值的影响</span></span><br><span class="line">		&#125;<span class="comment">//第二个片元着色器用于更新渲染纹理的A通道部分</span></span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		ZTest Always Cull Off ZWrite Off</span><br><span class="line">		</span><br><span class="line">		Pass &#123;<span class="comment">//第一个Pass用于更新RGB通道</span></span><br><span class="line">			Blend SrcAlpha OneMinusSrcAlpha<span class="comment">//混合操作，前因子和原颜色(片元着色器得到)相乘，后因子和目标颜色(颜色缓冲)相乘</span></span><br><span class="line">			<span class="comment">//因此混合后输出颜色的透明度值就是源颜色的透明度</span></span><br><span class="line">			ColorMask RGB</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragRGB  </span></span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;<span class="comment">//第二个用于更新A通道，分开是因为更新RGB时需要设置A通道来混合图像，但是不希望A通道的值写入渲染纹理中</span></span><br><span class="line">			Blend One Zero<span class="comment">//混合因子前者为1后者为0</span></span><br><span class="line">			ColorMask A</span><br><span class="line">			   	</span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragA</span></span><br><span class="line">			  </span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-7-扩展阅读"><a href="#12-7-扩展阅读" class="headerlink" title="12.7 扩展阅读"></a>12.7 扩展阅读</h3><p>Unity的Image Effect包中有更多特效的实现；GPU Gems系列中，也介绍了许多基于图像处理的渲染技术；</p>
<h2 id="第十三章-使用深度和法线纹理"><a href="#第十三章-使用深度和法线纹理" class="headerlink" title="第十三章 使用深度和法线纹理"></a>第十三章 使用深度和法线纹理</h2><p>之前的屏幕后处理效果都是在屏幕颜色图像上进行各种操作来实现的，但是很多时候我们不仅需要当前屏幕的颜色信息，还希望得到深度和法线信息，例如在进行边缘检测时，直接利用颜色信息会使检测到的边缘信息受物体纹理和光照等外部因素的影响，得到我们不需要的边缘点；而更好的方法是<strong>在深度和法线纹理上进行边缘检测</strong>，<strong>这些图像仅仅保存了模型信息</strong>，检测出来的边缘更加可靠；</p>
<h3 id="13-1-获取深度和法线纹理"><a href="#13-1-获取深度和法线纹理" class="headerlink" title="13.1 获取深度和法线纹理"></a>13.1 获取深度和法线纹理</h3><h4 id="13-1-1-背后的原理"><a href="#13-1-1-背后的原理" class="headerlink" title="13.1.1 背后的原理"></a>13.1.1 背后的原理</h4><p>深度纹理实际就是一张渲染纹理，只不过它里面存储的像素值不是颜色值，而是一个高精度的深度值，范围是[0,1]，而且通常是非线性分布的；</p>
<p>这些深度值来自于顶点变换后得到的归一化的设备坐标（Normalized Device Coordinates，NDC）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-29273214886843cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>在透视投影中，投影矩阵首先对顶点进行了缩放。在经过齐次除法后，透视投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-d8a778e9f3523400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>在正交投影中，投影矩阵对顶点进行了缩放。在经过齐次除法后，正交投影的裁剪空间会变换到一个立方体。图中标注了4个关键点经过投影矩阵变换后的结果；</p>
<p>在得到NDC之后，深度纹理中的像素值即可得到——深度值对应NDC中顶点坐标的z分量的值，由于NDC中z分量的范围在[-1,1]，为了存储在图像中，我们需要使用公式进行映射：<br>$$<br>d &#x3D; 0.5*z+0.5<br>$$<br>而在Unity中，如果想<strong>获得相机的深度纹理</strong>，可以直接来自于真正的深度缓存，也可以由一个单独的Pass渲染而得，这取决于使用的渲染路径和硬件，当使用<strong>延迟渲染路径</strong>时可以直接访问到，因为延迟渲染会把这些信息渲染到G-buffer中；</p>
<p>而如果使用<strong>前向渲染路径</strong>，Unity会使用着色器替换技术(Shader Replacement)技术选择那些渲染类型为Opaque的物体，判断它们使用的渲染队列是否小于等于2500(即Background、Geometry、AlphaTest队列)，满足的物体将渲染到深度纹理中，而这个过程是使用的ShadowCaster的Pass，因此实际上是<strong>重新渲染了一遍场景，每个物体都用的是ShadowCaster的Pass</strong>(没有对应Pass的物体将不会出现在深度纹理中)</p>
<p>关于为什么不直接使用渲染完毕后得到的屏幕的深度值，而是要重新渲染一次，Unity的工作人员回答有两点原因：</p>
<ol>
<li>对于非全屏渲染的情况，本来是想拿对应相机渲染的深度，但是Depth Buffer是全屏的；</li>
<li>很多平台不支持直接拿Depth Buffer的数据</li>
</ol>
<p>tips：由于Unity生成阴影使用的是屏幕空间的阴影映射技术，生成阴影时本身就会生成一张相机的深度纹理图加上一张基于光源空间的阴影映射纹理；所以如果灯光开启了阴影，我们去获取相机的深度纹理并不会导致相机再去额外渲染一遍场景(因为本身已经生成了一张深度纹理)，也不会额外增加DrawCall，这也是渲染深度纹理用到的Pass和渲染阴影用到的纹理是同一个Pass的原因；</p>
<p>如果选择生成一张深度+法线纹理，Unity会创建一张和屏幕分辨率相同、精度为32位(每个通道8位)的纹理，其中观察空间下的法线信息会被编码进纹理的R和G通道，而深度信息会被编码进B和A通道。法线信息的获取在延迟渲染中只要合并深度和法线缓存即可得到；而在前向渲染中，默认情况下是不会创建法线缓存的，因此Unity底层使用了一个单独的Pass把整个场景再次渲染一遍来完成；(可见Camera-DepthNormalTexture.shader)</p>
<h4 id="13-1-2-如何获取"><a href="#13-1-2-如何获取" class="headerlink" title="13.1.2 如何获取"></a>13.1.2 如何获取</h4><p>在Unity中，获取深度纹理只需要在脚本中<strong>设置摄像机的DepthTextureMode</strong>，然后就可以在Shader中通过<strong>声明_CameraDepthTexture</strong>变量来访问他：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">camera.depthTextureMode = DepthTextureMode.Depth;<span class="comment">//获取深度纹理</span></span><br><span class="line">camera.depthTextureMode = DepthTextureMode.DepthNormals;<span class="comment">//获取深度+法线纹理</span></span><br><span class="line"></span><br><span class="line">camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line">camera.depthTextureMode |= DepthTextureMode.DepthNormals;<span class="comment">//组合模式，同时产生一张深度和深度+法线纹理</span></span><br></pre></td></tr></table></figure>

<p>在Shader中访问到深度纹理_CameraDepthTexture后，我们就可以对其采样，但对于常规的tex2D函数采样来说，在某些平台(如PS2，PS3)则不适配，我们需要特殊处理，Unity提供了一个统一的宏来处理：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);</span><br></pre></td></tr></table></figure>

<p>i.uv是一个float2类型的变量，对应当前像素的纹理坐标；</p>
<p>当通过采样得到深度值后，这些深度值往往是非线性的，这种非线性来自于透视投影使用的裁剪矩阵；但我们计算需要线性的深度值，也就是说我们需要把投影后的深度值变换到线性空间下，例如视角空间下的深度值，那么我们需要倒推顶点变换的过程：</p>
<p>当我们使用透视投影的裁剪矩阵对视角空间下的一个顶点进行变换后，裁剪空间下顶点的z和w分量为：<br>$$<br>z_c&#x3D;-z_v\frac{Far + Near}{Far-Near}-\frac{2<em>Near</em>Far}{Far-Near}<br>$$</p>
<p>$$<br>w_c &#x3D; -z_v<br>$$</p>
<p>其中Far和Near分别是远近裁剪平面的距离，然后我们通过齐次除法就可以得到NDC下的z分量：<br>$$<br>z_n&#x3D;\frac{z_c}{w_c}&#x3D;\frac{Far+Near}{Far-Near}+\frac{2<em>Near</em>Far}{(Far-Near)<em>z_v}<br>$$<br>又因为深度纹理中的深度值是由d &#x3D; 0.5</em>z<del>n</del>+0.5得到的：<br>$$<br>Z_v &#x3D; \frac{1}{\frac{Far-Near}{Near<em>Far}d-\frac{1}{Near}}<br>$$<br>由于在Unity使用的视角空间中，摄像机正向对应的z值均为负值，因此为了得到深度值的正数表示，需要对上面的结果取反：<br>$$<br>Z_v’ &#x3D; \frac{1}{\frac{Near-Far}{Near</em>Far}d+\frac{1}{Near}}<br>$$<br>它的取值范围就是视锥体深度范围，即[Near,Far]，如果我们想得到范围在[0,1]之间的深度值，只需要把上面的结果除以Far即可，这样，0就表示该点与摄像机同一位置，1表示该点位于视锥体的远裁剪平面上：<br>$$<br>Z_v &#x3D; \frac{1}{\frac{Near-Far}{Near}d+\frac{Far}{Near}}<br>$$<br><strong>幸运的是，Unity提供了两个辅助函数来进行上述计算——LinearEyeDepth和Linear01Depth；</strong>LinearEyeDepth负责把深度纹理的采样结果转换到视角空间下的深度值，也就是我们上面得到的z<del>v</del>’，而Linear01Depth则会返回一个范围在[0,1]的线性深度值，也就是我们上面得到的z，这两个函数内部使用了内置的_ZBufferParams变量来得到远近裁剪平面的距离。</p>
<p>如果我们需要获取深度+法线纹理，可以直接使用tex2D函数对_CameraDepthNormalsTexture进行采样，得到里面存储的法线和深度信息，Unity提供了辅助函数来为我们对这个采样结果解码从而得到深度值和法线方向——DecodeDepthNormal：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inline <span class="keyword">void</span> <span class="title">DecodeDepthNoraml</span>(<span class="params">float4 enc, <span class="keyword">out</span> <span class="built_in">float</span> depth, <span class="keyword">out</span> float3 normal</span>)</span>&#123;</span><br><span class="line">	depth = DecodeFloatRG(enc.zw);</span><br><span class="line">	normal = DecodeViweNormalStereo(enc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数enc是采样结果，其xy分量存储的是视角空间下的法线信息，而深度信息被编码进了zw分量，解码后我们就可以得到解码后的深度值和法线，这个深度值是范围在[0,1]的线性深度值(这与单独的深度纹理中存储的深度值不同)，而得到的法线则是视角空间下的法线方向，同样我们也可以通过调用DecodeFloatRG和DecodeViweNormalStereo来解码深度和法线信息；</p>
<p>接下来我们将使用深度和法线纹理实现屏幕特效；</p>
<h4 id="13-1-3-实现扫描效果"><a href="#13-1-3-实现扫描效果" class="headerlink" title="13.1.3 实现扫描效果"></a>13.1.3 实现扫描效果</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Test/DepthTexture&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">		_ScanColor (&quot;Scan Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>)</span><br><span class="line">		_ScanWidth (&quot;Scan Width&quot;, Range(<span class="number">0.001</span>, <span class="number">0.5</span>)) = <span class="number">0.002</span></span><br><span class="line">		_ScanSpeed (&quot;Scan Speed&quot;, Range(<span class="number">0.001</span>, <span class="number">8</span>)) = <span class="number">0.03</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        LOD <span class="number">100</span></span><br><span class="line"></span><br><span class="line">		ZTest Off</span><br><span class="line">		Cull Off</span><br><span class="line">		ZWrite Off</span><br><span class="line">		Fog&#123; Mode Off &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#pragma vertex vert</span></span><br><span class="line">            <span class="meta">#pragma fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">sampler2D</span> _MainTex;</span><br><span class="line">            <span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">			fixed4 _ScanColor;</span><br><span class="line">			<span class="type">float</span> _ScanSpeed;</span><br><span class="line">			<span class="type">float</span> _ScanWidth;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">				fixed4 color = tex2D(_MainTex, i.uv);</span><br><span class="line"> </span><br><span class="line">				<span class="type">float</span> depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture,i.uv);</span><br><span class="line">				depth = Linear01Depth(depth);<span class="comment">//采样并获取深度值</span></span><br><span class="line">				<span class="type">float</span> pos = (_Time.y * _ScanSpeed * <span class="number">1000</span> % <span class="number">1000</span>) * <span class="number">0.001</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// sign(x) 如果x&lt;0，返回-1；如果x=0，返回0；如果x&gt;0，返回1</span></span><br><span class="line">				<span class="type">float</span> scanFlag = saturate(<span class="built_in">sign</span>(depth - pos)) * saturate(<span class="built_in">sign</span>(pos + _ScanWidth - depth));</span><br><span class="line">                  <span class="comment">//扫描标记，当该处深度值和扫描深度一致并且在扫描宽度内时该值才为1，因此当scanFlag为1则说明扫描到物体</span></span><br><span class="line">				color.rgb = color.rgb * (<span class="number">1</span> - _ScanColor.a * scanFlag) + _ScanColor.rgb * scanFlag;</span><br><span class="line">                  <span class="comment">//扫描到则叠加上扫描的颜色</span></span><br><span class="line">				<span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-2-再谈运动模糊"><a href="#13-2-再谈运动模糊" class="headerlink" title="13.2 再谈运动模糊"></a>13.2 再谈运动模糊</h3><p>在12.6节中，使用了混合多张屏幕图像来模拟运动模糊的效果，而另一种应用更加广泛的技术是使用速度映射图；速度映射图存储了每个像素的速度，然后使用这个速度来决定模糊的方向和大小；</p>
<p>速度缓冲的生成有多种办法，一种方法是把场景中所有物体的速度渲染到一张纹理中，这种方法的缺点在于<strong>需要修改场景中所有物体的Shader代码，使其添加计算速度的代码并输出到一个渲染纹理中</strong>；</p>
<p>而来自《GPU Gems3》中有另一种生成速度映射图的方法；这种方法利用深度纹理在片元着色器中为每个像素计算其在世界空间下的位置，这是通过使用当前的视角* 投影矩阵的逆矩阵对NDC下的顶点坐标进行变换得到的；当得到世界空间中的顶点坐标后，我们使用前一帧的视角*投影矩阵对其进行变换，得到该位置在前一帧中的NDC坐标；然后我们计算前一帧和当前帧的位置差，生成该像素的速度；这种方法优点是可以在一个屏幕后处理步骤中完成整个效果的模拟，但缺点是需要在片元着色器中进行两次矩阵乘法的操作，影响性能；</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Range(0.0f, 1.0f)</span>]</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">float</span> blurSize = <span class="number">0.5f</span>;<span class="comment">//定义运动模糊时模糊图像使用的大小</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Matrix4x4 previousViewProjectionMatrix;<span class="comment">//保存上一帧摄像机的视角*投影矩阵</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>()</span> &#123;</span><br><span class="line">		camera.depthTextureMode |= DepthTextureMode.Depth;</span><br><span class="line"></span><br><span class="line">		previousViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;<span class="comment">//这里倒过来乘只需后续也将NDC坐标放在右边乘就行</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">			material.SetFloat(<span class="string">&quot;_BlurSize&quot;</span>, blurSize);</span><br><span class="line"></span><br><span class="line">			material.SetMatrix(<span class="string">&quot;_PreviousViewProjectionMatrix&quot;</span>, previousViewProjectionMatrix);</span><br><span class="line">			Matrix4x4 currentViewProjectionMatrix = camera.projectionMatrix * camera.worldToCameraMatrix;<span class="comment">//投影和视角矩阵相乘</span></span><br><span class="line">			Matrix4x4 currentViewProjectionInverseMatrix = currentViewProjectionMatrix.inverse;<span class="comment">//结果取逆，得到当前帧的视角*投影矩阵的逆矩阵</span></span><br><span class="line">			material.SetMatrix(<span class="string">&quot;_CurrentViewProjectionInverseMatrix&quot;</span>, currentViewProjectionInverseMatrix);</span><br><span class="line">			previousViewProjectionMatrix = currentViewProjectionMatrix;<span class="comment">//取逆前的结果，在下一帧将传递给_PreviousViewProjectionMatrix</span></span><br><span class="line"></span><br><span class="line">			Graphics.Blit (src, dest, material);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Graphics.Blit(src, dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Motion Blur With Depth Texture&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_BlurSize (&quot;Blur Size&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		<span class="type">sampler2D</span> _CameraDepthTexture;<span class="comment">//深度纹理</span></span><br><span class="line">		float4x4 _CurrentViewProjectionInverseMatrix;</span><br><span class="line">		float4x4 _PreviousViewProjectionMatrix;<span class="comment">//脚本传递来的矩阵</span></span><br><span class="line">		half _BlurSize;</span><br><span class="line">		</span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv : TEXCOORD0;</span><br><span class="line">			half2 uv_depth : TEXCOORD1;<span class="comment">//增加了用于对深度纹理采样的纹理坐标变量</span></span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		v2f vert(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			o.uv = v.texcoord;</span><br><span class="line">			o.uv_depth = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">			<span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">				o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;<span class="comment">//由于同时处理多张渲染纹理，因此需要处理平台差异导致的图像翻转问题</span></span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">			<span class="type">float</span> d = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth);<span class="comment">//对深度纹理进行采样</span></span><br><span class="line">			float4 H = float4(i.uv.x * <span class="number">2</span> - <span class="number">1</span>, i.uv.y * <span class="number">2</span> - <span class="number">1</span>, d * <span class="number">2</span> - <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//将深度值映射回NDC</span></span><br><span class="line">			float4 D = mul(_CurrentViewProjectionInverseMatrix, H);<span class="comment">//用当前帧视角*投影矩阵的逆矩阵对其进行变换</span></span><br><span class="line">			float4 worldPos = D / D.w;<span class="comment">//结果值除以w分量来得到世界空间下的坐标表示worldPos</span></span><br><span class="line">			</span><br><span class="line">			float4 currentPos = H;</span><br><span class="line">			float4 previousPos = mul(_PreviousViewProjectionMatrix, worldPos);<span class="comment">//用前一帧的视角*投影矩阵对它进行变换，得到前一帧在NDC下的坐标</span></span><br><span class="line">			previousPos /= previousPos.w;<span class="comment">//进行齐次除法得到NDC坐标</span></span><br><span class="line">			</span><br><span class="line">			float2 velocity = (currentPos.xy - previousPos.xy)/<span class="number">2.0</span>f;<span class="comment">//通过位置差计算速度</span></span><br><span class="line">			</span><br><span class="line">			float2 uv = i.uv;</span><br><span class="line">			float4 c = tex2D(_MainTex, uv);</span><br><span class="line">			uv += velocity * _BlurSize;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> it = <span class="number">1</span>; it &lt; <span class="number">3</span>; it++, uv += velocity * _BlurSize) &#123;</span><br><span class="line">				float4 currentColor = tex2D(_MainTex, uv);<span class="comment">//用该速度值对邻域进行采样</span></span><br><span class="line">				c += currentColor;</span><br><span class="line">			&#125;</span><br><span class="line">			c /= <span class="number">3</span>;<span class="comment">//混合多次后取平均值</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> fixed4(c.rgb, <span class="number">1.0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		Pass &#123;<span class="comment">//定义了运动模糊所需的Pass</span></span><br><span class="line">			ZTest Always Cull Off ZWrite Off</span><br><span class="line">			    	</span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment frag  </span></span><br><span class="line">			  </span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-3-全局雾效"><a href="#13-3-全局雾效" class="headerlink" title="13.3 全局雾效*"></a>13.3 全局雾效*</h3><p>Unity内置的雾效可以产生基于距离的线性或指数雾效。如果希望在自己编写的着色器中实现，我们需要在Shader中添加#pragma multi_compile_fog指令，同时还需要使用相关的内置宏；这种方法的缺点在于需要为场景中所有物体添加相关的渲染代码，而且能实现的效果非常有限；</p>
<p>本节将介绍基于屏幕后处理的全局雾效的实现，此法可以模拟均匀的、基于距离的线性&#x2F;指数的、基于高度的雾效等；</p>
<p>该法的关键是<strong>根据深度纹理重建每个像素在世界空间下的位置</strong>，上节中我们首先构造了NDC坐标，再通过视角*投影逆矩阵得到世界空间下的像素坐标，但较为消耗性能；而本节的方法是首先对图像空间下的视锥体射线(从摄像机出发指向图像上某点的射线)进行插值，这条射线存储了<strong>该像素在世界空间下到摄像机的方向信息</strong>；然后我们<strong>把该射线和线性化后的视角空间下的深度值相乘，再加上摄像机的世界位置</strong>，就可以得到该像素在世界空间下的位置</p>
<h4 id="13-3-1-重建世界坐标"><a href="#13-3-1-重建世界坐标" class="headerlink" title="13.3.1 重建世界坐标"></a>13.3.1 重建世界坐标</h4><p>坐标系中的一个顶点坐标可以通过它相对于另一个顶点坐标的偏移量来求得；我们只需要知道摄像机在世界空间下的位置，以及世界空间下该像素相对于摄像机的偏移量，把他们相加就可以得到该像素的世界坐标：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 worldPos = _WorldSpaceCameraPos + linearDepth * interpolatedRay;</span><br><span class="line"><span class="comment">//linearDepth是由深度纹理得到的线性深度值，interpolatedRay是由顶点着色器输出并插值后得到的射线，他不仅包含了该像素到摄像机的方向，也包含了距离信息；相乘得到偏移值；</span></span><br></pre></td></tr></table></figure>

<p>interpolatedRay来源于对近裁剪平面的4个角的某个特定向量的插值，这4个向量包含了它们到摄像机方向和距离信息，我们可以利用摄像机的近裁剪平面距离、FOV、横纵比计算而得。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-2bb2567043bb57a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/405/format/webp" alt="img"></p>
<p>如图，toTop和toRight是起点位于近裁剪平面中心、分别指向摄像机正上方和正右方的向量，它们的计算公式如下：<br>$$<br>halfHeight&#x3D;Near×tan(\frac{FOV}{2})<br>$$</p>
<p>$$<br>toTop&#x3D;camera.up×halfHeight<br>$$</p>
<p>$$<br>toRight&#x3D;camera.right×halfHeight·aspect<br>$$</p>
<p>其中Near是近裁剪平面的距离，FOV是竖直方向的视角范围，camera.up、camera.right分别对应了摄像机的正上方和正后方，aspect是宽高比；</p>
<p>当得到这两个辅助向量后，我们就可以计算4个角相对于摄像机的方向(左上角为例)：<br>$$<br>TL &#x3D; camera.forward·Near+toTop-toRight<br>$$<br>这四个向量不仅包含了方向信息，他们的模对应了四个点到摄像机的空间距离，由于我们得到的线性深度值并非是点到摄像机的欧氏距离，而是z方向的距离，因此不能直接使用深度值和四个角单位方向上的乘积来计算它们到摄像机的偏移量；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-2c7c84f9b86b85c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/366/format/webp" alt="img"></p>
<p>如图，根据相似三角形，像素的深度值和它到摄像机的实际距离的比等于近裁剪平面的距离和TL向量的模的比：<br>$$<br>\frac{depth}{dist} &#x3D; \frac{Near}{|TL|}<br>$$<br>即：<br>$$<br>dist &#x3D; \frac{|TL|}{Near}×depth<br>$$<br>由于4个点相互对称，因此其他3个向量的模和TL相等，即我们可以使用同一个因子和单位向量相乘，得到它们对应的向量值：<br>$$<br>scale &#x3D; \frac{|TL|}{|Near|}<br>$$</p>
<p>$$<br>Ray_{TL} &#x3D; \frac{TL}{|TL|}×scale，Ray_{TR}&#x3D;\frac{TR}{|TR|}×scale…<br>$$</p>
<p>屏幕后处理的原理是使用特定的材质去渲染一个刚好填充整个屏幕的四边形面片，这个四边形面片的4个顶点就对应了近裁剪平面的4个角，因此我们可以把上面的计算结果传递给顶点着色器，顶点着色器根据当前的位置选择它所对应的向量，然后再将其输出，经插值后传递给片元着色器得到interpolatedRay，我们就可以直接利用本节一开始提到的公式重建该像素在世界空间下的位置了；</p>
<h4 id="13-3-2-雾的计算"><a href="#13-3-2-雾的计算" class="headerlink" title="13.3.2 雾的计算"></a>13.3.2 雾的计算</h4><p>在简单的雾效实现中，我们需要计算一个雾效系数f，作为混合原始颜色和雾的颜色的混合系数：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 afterFog = f * fogColor + (<span class="number">1</span> - f) * origColor;</span><br></pre></td></tr></table></figure>

<p>f有很多计算方法，在Unity内置的雾效实现中支持三种雾的计算方式：线性、指数、指数平方，当给定距离z后，f的计算公式分别如下：</p>
<p>线性：<br>$$<br>f &#x3D; \frac{d_{max}-|z|}{d_{max}-d_{min}}<br>$$<br>d<del>max</del>表示受雾影响的最大距离，d<del>min</del>表示受雾影响的最小距离；</p>
<p>指数：<br>$$<br>f&#x3D;e^{-d·|z|}<br>$$<br>d是控制雾的浓度的参数；</p>
<p>指数平方：<br>$$<br>f&#x3D;e^{-(d-|z|)^2}<br>$$<br>d是控制雾的浓度的参数；</p>
<p>本节中使用类似线性雾的计算方式，计算基于高度的雾效；</p>
<h4 id="13-3-3-实现"><a href="#13-3-3-实现" class="headerlink" title="13.3.3 实现"></a>13.3.3 实现</h4><p>OnRenderImage实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span> (<span class="params">RenderTexture src, RenderTexture dest</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (material != <span class="literal">null</span>) &#123;</span><br><span class="line">			Matrix4x4 frustumCorners = Matrix4x4.identity;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">float</span> fov = camera.fieldOfView;</span><br><span class="line">			<span class="built_in">float</span> near = camera.nearClipPlane;</span><br><span class="line">			<span class="built_in">float</span> aspect = camera.aspect;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">float</span> halfHeight = near * Mathf.Tan(fov * <span class="number">0.5f</span> * Mathf.Deg2Rad);</span><br><span class="line">			Vector3 toRight = cameraTransform.right * halfHeight * aspect;</span><br><span class="line">			Vector3 toTop = cameraTransform.up * halfHeight;</span><br><span class="line"></span><br><span class="line">			Vector3 topLeft = cameraTransform.forward * near + toTop - toRight;</span><br><span class="line">			<span class="built_in">float</span> scale = topLeft.magnitude / near;</span><br><span class="line"></span><br><span class="line">			topLeft.Normalize();</span><br><span class="line">			topLeft *= scale;</span><br><span class="line"></span><br><span class="line">			Vector3 topRight = cameraTransform.forward * near + toRight + toTop;</span><br><span class="line">			topRight.Normalize();</span><br><span class="line">			topRight *= scale;</span><br><span class="line"></span><br><span class="line">			Vector3 bottomLeft = cameraTransform.forward * near - toTop - toRight;</span><br><span class="line">			bottomLeft.Normalize();</span><br><span class="line">			bottomLeft *= scale;</span><br><span class="line"></span><br><span class="line">			Vector3 bottomRight = cameraTransform.forward * near + toRight - toTop;</span><br><span class="line">			bottomRight.Normalize();</span><br><span class="line">			bottomRight *= scale;</span><br><span class="line"></span><br><span class="line">			frustumCorners.SetRow(<span class="number">0</span>, bottomLeft);</span><br><span class="line">			frustumCorners.SetRow(<span class="number">1</span>, bottomRight);</span><br><span class="line">			frustumCorners.SetRow(<span class="number">2</span>, topRight);</span><br><span class="line">			frustumCorners.SetRow(<span class="number">3</span>, topLeft);</span><br><span class="line"></span><br><span class="line">			material.SetMatrix(<span class="string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);</span><br><span class="line"></span><br><span class="line">			material.SetFloat(<span class="string">&quot;_FogDensity&quot;</span>, fogDensity);</span><br><span class="line">			material.SetColor(<span class="string">&quot;_FogColor&quot;</span>, fogColor);</span><br><span class="line">			material.SetFloat(<span class="string">&quot;_FogStart&quot;</span>, fogStart);</span><br><span class="line">			material.SetFloat(<span class="string">&quot;_FogEnd&quot;</span>, fogEnd);</span><br><span class="line"></span><br><span class="line">			Graphics.Blit (src, dest, material);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Graphics.Blit(src, dest);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Fog With Depth Texture&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_FogDensity (&quot;Fog Density&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_FogColor (&quot;Fog Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_FogStart (&quot;Fog Start&quot;, Float) = <span class="number">0.0</span></span><br><span class="line">		_FogEnd (&quot;Fog End&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		float4x4 _FrustumCornersRay;</span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		half4 _MainTex_TexelSize;</span><br><span class="line">		<span class="type">sampler2D</span> _CameraDepthTexture;</span><br><span class="line">		half _FogDensity;</span><br><span class="line">		fixed4 _FogColor;</span><br><span class="line">		<span class="type">float</span> _FogStart;</span><br><span class="line">		<span class="type">float</span> _FogEnd;</span><br><span class="line">		</span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv : TEXCOORD0;</span><br><span class="line">			half2 uv_depth : TEXCOORD1;</span><br><span class="line">			float4 interpolatedRay : TEXCOORD2;<span class="comment">//存储插值后的像素向量</span></span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		v2f vert(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			o.uv = v.texcoord;</span><br><span class="line">			o.uv_depth = v.texcoord;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">			<span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">				o.uv_depth.y = <span class="number">1</span> - o.uv_depth.y;</span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (v.texcoord.x &lt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">				<span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">				<span class="keyword">index</span> = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v.texcoord.x &gt; <span class="number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">				<span class="keyword">index</span> = <span class="number">2</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">index</span> = <span class="number">3</span>;</span><br><span class="line">			&#125;<span class="comment">//平台差异化处理</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">			<span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">index</span> = <span class="number">3</span> - <span class="keyword">index</span>;</span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line">			</span><br><span class="line">			o.interpolatedRay = _FrustumCornersRay[<span class="keyword">index</span>];</span><br><span class="line">				 	 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">			<span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">			float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;<span class="comment">//重建该像素在世界空间中的位置</span></span><br><span class="line">						</span><br><span class="line">			<span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); </span><br><span class="line">			fogDensity = saturate(fogDensity * _FogDensity);</span><br><span class="line">			</span><br><span class="line">			fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">			finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);<span class="comment">//混合雾效颜色</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> finalColor;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			ZTest Always Cull Off ZWrite Off</span><br><span class="line">			     	</span><br><span class="line">			CGPROGRAM  </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment frag  </span></span><br><span class="line">			  </span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-4-再谈边缘检测"><a href="#13-4-再谈边缘检测" class="headerlink" title="13.4 再谈边缘检测"></a>13.4 再谈边缘检测</h3><p>在12.3节中，我们使用Sobel算子对屏幕图像进行边缘检测，实现描边的效果；但是直接利用颜色信息进行边缘检测的方法会产生很多我们不希望得到的边缘线，比如物体的纹理，阴影等位置也描上了黑边：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-af3958e8a5ee5056.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>而本节将在深度和法线纹理上进行边缘检测，这些图像不会受纹理和光照的影响：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-870644bf93c21213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>本节将使用Roberts算子来进行边缘检测，其使用的卷积核如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-7a00630224855b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/368/format/webp" alt="img"></p>
<p>该算子的本质是计算左上角和右下角的差值，乘以右上角和左下角的差值作为评估边缘的依据，即取对角方向的深度或法线值，比较它们之间的差值，如果超过某个阈值，就认为他们之间存在一条边；</p>
<p><strong>在本例的OnRenderImage函数前我们添加了[ImageEffectOpaque]属性</strong>：</p>
<p>默认情况下，OnRenderImage函数会在所有的不透明和透明的Pass执行完毕后被调用，以便对场景中所有游戏对象都产生影响；但有时我们希望在不透明的Pass(即渲染队列&lt;&#x3D;2500的Pass)执行完毕后立即调用该函数，而不对透明物体(渲染队列为Transparent的Pass)产生影响，此时添加该属性即可；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">13</span>/Edge Detection Normals And Depth&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_SampleDistance (&quot;Sample Distance&quot;, Float) = <span class="number">1.0</span></span><br><span class="line">		_Sensitivity (&quot;Sensitivity&quot;, Vector) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		CGINCLUDE</span><br><span class="line">		</span><br><span class="line">		<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">		half4 _MainTex_TexelSize;<span class="comment">//需要对邻域像素进行纹理采样，该变量用于存储纹素大小</span></span><br><span class="line">		fixed _EdgeOnly;</span><br><span class="line">		fixed4 _EdgeColor;</span><br><span class="line">		fixed4 _BackgroundColor;</span><br><span class="line">		<span class="type">float</span> _SampleDistance;</span><br><span class="line">		half4 _Sensitivity;<span class="comment">//xy分量分别对应了法线和深度的检测灵敏度，zw分量没有实际用途</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">sampler2D</span> _CameraDepthNormalsTexture;<span class="comment">//需要获取的深度+法线纹理</span></span><br><span class="line">		</span><br><span class="line">		struct v2f &#123;</span><br><span class="line">			float4 pos : SV_POSITION;</span><br><span class="line">			half2 uv[<span class="number">5</span>]: TEXCOORD0;<span class="comment">//第一个坐标存储屏幕颜色图像的采样纹理，剩余四个坐标则存储了使用Roberts算子时需要采样的纹理坐标</span></span><br><span class="line">		&#125;;</span><br><span class="line">		  </span><br><span class="line">		v2f vert(appdata_img v) &#123;</span><br><span class="line">			v2f o;</span><br><span class="line">			o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">			</span><br><span class="line">			half2 uv = v.texcoord;</span><br><span class="line">			o.uv[<span class="number">0</span>] = uv;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#if UNITY_UV_STARTS_AT_TOP</span></span><br><span class="line">			<span class="keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="number">0</span>)</span><br><span class="line">				uv.y = <span class="number">1</span> - uv.y;</span><br><span class="line">			<span class="meta">#endif</span></span><br><span class="line">			</span><br><span class="line">			o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">-1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>,<span class="number">1</span>) * _SampleDistance;</span><br><span class="line">			o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>,<span class="number">-1</span>) * _SampleDistance;<span class="comment">//计算采样纹理坐标，用_SampleDistance来控制采样距离</span></span><br><span class="line">					 </span><br><span class="line">			<span class="keyword">return</span> o;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		half CheckSame(half4 center, half4 <span class="keyword">sample</span>) &#123;</span><br><span class="line">			half2 centerNormal = center.xy;</span><br><span class="line">			<span class="type">float</span> centerDepth = DecodeFloatRG(center.zw);</span><br><span class="line">			half2 sampleNormal = <span class="keyword">sample</span>.xy;<span class="comment">//直接使用了xy分量，因为只需要比较采样值的差异度而不需要知道他们真正的法线值</span></span><br><span class="line">			<span class="type">float</span> sampleDepth = DecodeFloatRG(<span class="keyword">sample</span>.zw);</span><br><span class="line">			</span><br><span class="line">			half2 diffNormal = <span class="built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;<span class="comment">//对应值相减并取绝对值，乘以灵敏度参数</span></span><br><span class="line">			<span class="type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="number">0.1</span>;<span class="comment">//差异值的分量相加并和阈值比较</span></span><br><span class="line">			<span class="comment">//法线部分比较</span></span><br><span class="line"></span><br><span class="line">			<span class="type">float</span> diffDepth = <span class="built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;</span><br><span class="line">			<span class="type">int</span> isSameDepth = diffDepth &lt; <span class="number">0.1</span> * centerDepth;<span class="comment">//按距离缩放所需阈值</span></span><br><span class="line">			<span class="comment">//深度部分比较</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> isSameNormal * isSameDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;<span class="comment">//该函数返回0说明两点之间存在一条边界</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;</span><br><span class="line">			half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">1</span>]);</span><br><span class="line">			half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">2</span>]);</span><br><span class="line">			half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">3</span>]);</span><br><span class="line">			half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="number">4</span>]);<span class="comment">//使用四个纹理坐标对深度+法线纹理采样；</span></span><br><span class="line">			</span><br><span class="line">			half edge = <span class="number">1.0</span>;</span><br><span class="line">			</span><br><span class="line">			edge *= CheckSame(sample1, sample2);<span class="comment">//CheckSame函数分别计算对角线上两个纹理值的差值</span></span><br><span class="line">			edge *= CheckSame(sample3, sample4);</span><br><span class="line">			</span><br><span class="line">			fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="number">0</span>]), edge);<span class="comment">//和采样颜色混合结果</span></span><br><span class="line">			fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<span class="comment">//和指定的背景色混合结果</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);<span class="comment">//通过_EdgeOnly控制边界和原图像混合程度</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ENDCG</span><br><span class="line">		</span><br><span class="line">		Pass &#123; <span class="comment">//定义边缘检测使用的Pass</span></span><br><span class="line">			ZTest Always Cull Off ZWrite Off</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM      </span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert  </span></span><br><span class="line">			<span class="meta">#pragma fragment fragRobertsCrossDepthAndNormal</span></span><br><span class="line">			</span><br><span class="line">			ENDCG  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第十四章-非真实感渲染"><a href="#第十四章-非真实感渲染" class="headerlink" title="第十四章 非真实感渲染"></a>第十四章 非真实感渲染</h2><h3 id="14-1-卡通风格的渲染"><a href="#14-1-卡通风格的渲染" class="headerlink" title="14.1 卡通风格的渲染"></a>14.1 卡通风格的渲染</h3><p>卡通风格是游戏中很常见的一种渲染风格，使用这种风格的游戏画面通常有一些共有的特点，例如物体都被黑色的线条描边，以及分明的明暗变化等；</p>
<p>要实现这种卡通渲染有很多方法，其中之一就是使用<strong>基于色调的着色技术</strong>；在实现中，我们往往会使用漫反射系数对一张一维纹理进行采样，以控制漫反射的色调；同时，卡通风格中，模型的高光往往是一块块分界明显的纯色区域； </p>
<p>除了光照模型不同外，卡通风格通常还需要在物体边缘部分绘制轮廓，因此本节将介绍基于模型的描边方法，这种方法的实现比之前的深度纹理方案更加简单；</p>
<h4 id="14-1-1-渲染轮廓线"><a href="#14-1-1-渲染轮廓线" class="headerlink" title="14.1.1 渲染轮廓线"></a>14.1.1 渲染轮廓线</h4><p>在实时渲染中，轮廓线的渲染是应用非常广泛的一种效果，在《Real Time Rendering,third edition》一书中作者分了五种类型的方法：</p>
<ol>
<li><p>基于观察角度和表面法线的轮廓线渲染，这种方法使用视角方向和表面法线的点乘结果来得到轮廓线的信息。这种方法简单快速，可以在一个Pass中就得到渲染结果，但局限性很大，很多模型渲染出来的描边效果都不尽如人意；</p>
</li>
<li><p>过程式几何轮廓线渲染，这种方法的核心是使用两个Pass渲染；第一个Pass渲染背面的面片，并使用某些技术让它的轮廓可见；第二个Pass再正常渲染正面的面片。这种方法的优点在于快速有效，并且适用于绝大多数表面平滑的模型，但它的缺点是不适合类似于立方体这样平整的模型；</p>
</li>
<li><p>基于图像处理的轮廓线渲染，即12，13章中通过卷积操作判断边缘的做法，但是这种方法中，一些深度和法线变化很小的轮廓无法被检测出来，例如桌子上的纸张；</p>
</li>
<li><p>基于轮廓边检测的轮廓线渲染，上面提到的各种方法，一个最大的问题是，<strong>无法控制轮廓线的风格渲染</strong>。对于一些情况，我们希望可以渲染出独特风格的轮廓线，例如水墨风格等；为此，我们希望可以检测出精确的轮廓边，然后直接渲染他们；检测一条边是否是轮廓边的公式很简单，我们只需要检查和这条边相邻的两个三角面片是否满足**((n<del>0</del>·v&gt;0) !&#x3D; (n<del>1</del>·v&gt;0))**，其中n<del>0</del>和n<del>1</del>分别表示两个相邻三角面片的法向，v是从视角到该边上任意顶点的方向；上述公式的本质是检查两个相邻的三角面片是否一个朝正面，一个朝背面。我们可以在几何着色器的帮助下实现检测；</p>
<p>这种方法的缺点在于实现复杂，并且逐帧单独提取轮廓，因此帧与帧之间会出现跳跃性；</p>
</li>
<li><p>最后一个种类混合了上述的几种方法；例如首先找到精确的轮廓边，把模型和轮廓边渲染到纹理中，再使用图像处理的方法识别出轮廓线，并在图像空间下进行风格化渲染；</p>
</li>
</ol>
<p>本节中，我们在Unity中使用<strong>过程式几何轮廓线渲染</strong>的方法来对模型进行轮廓描边，我们将使用两个Pass渲染模型：在第一个Pass中，我们会<strong>使用轮廓线颜色渲染整个背面的面片，并在视角空间下把模型顶点沿着法线方向向外扩张一段距离，以此来让背部轮廓线可见</strong>：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewPos = viewPos + viewNormal * _Outline;</span><br></pre></td></tr></table></figure>

<p>但是如果直接使用顶点法线进行扩展，对于一些内凹的模型，就可能发生背面面片遮挡正面面片的情况；为了尽可能防止出现这样的情况，在扩张背面顶点之前，我们<strong>首先对顶点法线的z分量进行处理，使它们等于一个定值，然后把法线归一化后再对顶点进行扩张</strong>，这样的好处在于，扩展后的背面更加扁平化，从而降低了遮挡正面面片的可能性：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">viewNormal.z = <span class="number">-0.5</span>;</span><br><span class="line">viewNormal = <span class="built_in">normalize</span>(viewNormal);</span><br><span class="line">viewPos = viewPos + viewNormal * _Outline;</span><br></pre></td></tr></table></figure>

<h4 id="14-1-2-添加高光"><a href="#14-1-2-添加高光" class="headerlink" title="14.1.2 添加高光"></a>14.1.2 添加高光</h4><p>卡通风格的高光往往是模型上一块块分界明显的纯色区域，为了实现这种效果，我们不能使用之前的光照模型；在之前实现Blinn-Phong模型的过程中，我们使用法线点乘光照方向以及视角方向和的一半，再和另一个参数进行指数操作得到高光反射系数：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dot</span>(normal,halfDir)),_Gloss);</span><br></pre></td></tr></table></figure>

<p>对于卡通渲染需要的高光反射光照模型，我们同样需要计算normal和halfDir的点乘结果，不同的是，我们把该值和一个阈值进行比较，如果小于该阈值，则高光反射系数为0，否则返回1：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">spec = <span class="built_in">step</span>(threshold, spec);<span class="comment">//step函数在第二个参数大于第一个参数时返回1，否则返回0；</span></span><br></pre></td></tr></table></figure>

<p>但是这种粗糙的方法会在边界造成锯齿，因为高光区域的边缘不是平滑渐变的，而是由0突变到1，如果进行抗锯齿处理，我们可以在边界处很小的一块区域内进行平滑处理：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">spec = lerp(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">smoothstep</span>(-w, w, spec - threshold));</span><br><span class="line"><span class="comment">//当spec - threshold小于-w时返回0，大于w时返回1，否则在0到1之间进行插值，这样的效果是在[-w,w]即边界处得到平滑变化的spec值</span></span><br><span class="line"><span class="comment">//我们可以将w设为定值，但也可以选择使用邻域像素之间的近似导数值，这可以通过CG的fwidth函数得到</span></span><br></pre></td></tr></table></figure>

<h4 id="14-1-3-实现"><a href="#14-1-3-实现" class="headerlink" title="14.1.3 实现"></a>14.1.3 实现</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Toon Shading&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (&quot;Main Tex&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Ramp (&quot;Ramp Texture&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//控制漫反射色调的渐变纹理</span></span><br><span class="line">		_Outline (&quot;Outline&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span><span class="comment">//控制轮廓线宽度</span></span><br><span class="line">		_OutlineColor (&quot;Outline Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)<span class="comment">//轮廓线颜色</span></span><br><span class="line">		_Specular (&quot;Specular&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)<span class="comment">//高光反射颜色</span></span><br><span class="line">		_SpecularScale (&quot;Specular Scale&quot;, Range(<span class="number">0</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span><span class="comment">//控制计算高光反射时使用的阈值</span></span><br><span class="line">	&#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;<span class="comment">//只渲染背面的Pass</span></span><br><span class="line">			NAME &quot;OUTLINE&quot;</span><br><span class="line">			</span><br><span class="line">			Cull Front<span class="comment">//剔除正面</span></span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="type">float</span> _Outline;</span><br><span class="line">			fixed4 _OutlineColor;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;; </span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">			    float4 pos : SV_POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert (a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				</span><br><span class="line">				float4 pos = mul(UNITY_MATRIX_MV, v.vertex); </span><br><span class="line">				float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);<span class="comment">//首先变换到视角空间下</span></span><br><span class="line">				normal.z = <span class="number">-0.5</span>;</span><br><span class="line">				pos = pos + float4(<span class="built_in">normalize</span>(normal), <span class="number">0</span>) * _Outline;<span class="comment">//设置z分量，归一化后进行扩张</span></span><br><span class="line">				o.pos = mul(UNITY_MATRIX_P, pos);<span class="comment">//变换到裁剪空间</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			float4 frag(v2f i) : SV_Target &#123; </span><br><span class="line">				<span class="keyword">return</span> float4(_OutlineColor.rgb, <span class="number">1</span>);               </span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;<span class="comment">//定义光照模型所在的Pass来渲染模型的正面</span></span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			Cull Back<span class="comment">//剔除背面</span></span><br><span class="line">		</span><br><span class="line">			CGPROGRAM</span><br><span class="line">		</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">		</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;UnityShaderVariables.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="type">sampler2D</span> _Ramp;</span><br><span class="line">			fixed4 _Specular;</span><br><span class="line">			fixed _SpecularScale;</span><br><span class="line">		</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">				float4 tangent : TANGENT;</span><br><span class="line">			&#125;; </span><br><span class="line">		</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				float3 worldNormal : TEXCOORD1;</span><br><span class="line">				float3 worldPos : TEXCOORD2;</span><br><span class="line">				SHADOW_COORDS(<span class="number">3</span>)</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert (a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				</span><br><span class="line">				o.pos = UnityObjectToClipPos( v.vertex);</span><br><span class="line">				o.uv = TRANSFORM_TEX (v.texcoord, _MainTex);</span><br><span class="line">				o.worldNormal  = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">				</span><br><span class="line">				TRANSFER_SHADOW(o);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			float4 frag(v2f i) : SV_Target &#123; </span><br><span class="line">				fixed3 worldNormal = <span class="built_in">normalize</span>(i.worldNormal);</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));</span><br><span class="line">				fixed3 worldViewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));</span><br><span class="line">				fixed3 worldHalfDir = <span class="built_in">normalize</span>(worldLightDir + worldViewDir);</span><br><span class="line">				</span><br><span class="line">				fixed4 c = tex2D (_MainTex, i.uv);</span><br><span class="line">				fixed3 albedo = c.rgb * _Color.rgb;</span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">				</span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<span class="comment">//计算阴影值，该宏避免了单独处理阴影</span></span><br><span class="line">				</span><br><span class="line">				fixed diff =  <span class="built_in">dot</span>(worldNormal, worldLightDir);</span><br><span class="line">				diff = (diff * <span class="number">0.5</span> + <span class="number">0.5</span>) * atten;</span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * tex2D(_Ramp, float2(diff, diff)).rgb;</span><br><span class="line">				</span><br><span class="line">				fixed spec = <span class="built_in">dot</span>(worldNormal, worldHalfDir);</span><br><span class="line">				fixed w = <span class="built_in">fwidth</span>(spec) * <span class="number">2.0</span>;</span><br><span class="line">				fixed3 specular = _Specular.rgb * lerp(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">smoothstep</span>(-w, w, spec + _SpecularScale - <span class="number">1</span>)) * <span class="built_in">step</span>(<span class="number">0.0001</span>, _SpecularScale);<span class="comment">//如上文所述</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(ambient + diffuse + specular, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="14-2-素描风格的渲染"><a href="#14-2-素描风格的渲染" class="headerlink" title="14.2 素描风格的渲染"></a>14.2 素描风格的渲染</h3><p>微软研究院的Praun等人在01年发表了一篇著名的论文，他们使用提前生成的素描纹理来实现实时的素描风格渲染，这些纹理组成了一个**色调艺术映射(Tonal Art Map,TAM)**，如图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-8baf7ee6809512fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/822/format/webp" alt="img"></p>
<p>图中从左到右纹理中的笔触逐渐在增多，用于模拟不同光照下的漫反射效果，从上到下则对应了每张纹理的多级渐远纹理(mipmaps)；这些多级渐远纹理的生成并不是简单的对上一层纹理进行降采样，而是需要保持笔触之间的间隔，以便更真实地模拟素描效果；</p>
<p>本节将进行简化实现，我们不考虑多级渐远纹理的生成，直接使用6张素描纹理进行渲染；</p>
<p>在渲染阶段，我们首先在顶点着色阶段计算逐顶点的光照，根据光照结果来决定6张纹理的混合权重，并传递给片元着色器；然后在片元着色器中根据权重混合6张纹理的采样结果；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  Reference: 	Praun E, Hoppe H, Webb M, et al. Real-time hatching[C]</span></span><br><span class="line"><span class="comment">///						Proceedings of the 28th annual conference on Computer graphics and interactive techniques. ACM, 2001: 581.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Hatching&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Color Tint&quot;, Color) = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">		_TileFactor (&quot;Tile Factor&quot;, Float) = <span class="number">1</span><span class="comment">//纹理的平铺系数，该值越大则模型上素描线条越密</span></span><br><span class="line">		_Outline (&quot;Outline&quot;, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">		_Hatch0 (&quot;Hatch <span class="number">0</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Hatch1 (&quot;Hatch <span class="number">1</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Hatch2 (&quot;Hatch <span class="number">2</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Hatch3 (&quot;Hatch <span class="number">3</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Hatch4 (&quot;Hatch <span class="number">4</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">		_Hatch5 (&quot;Hatch <span class="number">5</span>&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//六张使用到的素描纹理</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		UsePass &quot;Unity Shaders Book/Chapter <span class="number">14</span>/Toon Shading/OUTLINE&quot;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag </span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;UnityShaderVariables.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">float</span> _TileFactor;</span><br><span class="line">			<span class="type">sampler2D</span> _Hatch0;</span><br><span class="line">			<span class="type">sampler2D</span> _Hatch1;</span><br><span class="line">			<span class="type">sampler2D</span> _Hatch2;</span><br><span class="line">			<span class="type">sampler2D</span> _Hatch3;</span><br><span class="line">			<span class="type">sampler2D</span> _Hatch4;</span><br><span class="line">			<span class="type">sampler2D</span> _Hatch5;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float4 tangent : TANGENT; </span><br><span class="line">				float3 normal : NORMAL; </span><br><span class="line">				float2 texcoord : TEXCOORD0; </span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				fixed3 hatchWeights0 : TEXCOORD1;</span><br><span class="line">				fixed3 hatchWeights1 : TEXCOORD2;<span class="comment">//由于有六个纹理，因此存放六个混合权重在两个fixed3中</span></span><br><span class="line">				float3 worldPos : TEXCOORD3;<span class="comment">//为了添加阴影</span></span><br><span class="line">				SHADOW_COORDS(<span class="number">4</span>)<span class="comment">//声明阴影纹理的采样坐标</span></span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);<span class="comment">//完成基本的坐标变换</span></span><br><span class="line">				</span><br><span class="line">				o.uv = v.texcoord.xy * _TileFactor;</span><br><span class="line">				</span><br><span class="line">				fixed3 worldLightDir = <span class="built_in">normalize</span>(WorldSpaceLightDir(v.vertex));</span><br><span class="line">				fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">				fixed diff = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(worldLightDir, worldNormal));<span class="comment">//利用光照方向和法线方向得到漫反射系数</span></span><br><span class="line">				</span><br><span class="line">				o.hatchWeights0 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">				o.hatchWeights1 = fixed3(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="type">float</span> hatchFactor = diff * <span class="number">7.0</span>;<span class="comment">//将diff缩放到[0,7]范围得到hatchFactor</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (hatchFactor &gt; <span class="number">6.0</span>) &#123;<span class="comment">//通过判断hatchFactor所处的子空间来计算对应的纹理混合权重</span></span><br><span class="line">					<span class="comment">// Pure white, do nothing</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">5.0</span>) &#123;</span><br><span class="line">					o.hatchWeights0.x = hatchFactor - <span class="number">5.0</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">4.0</span>) &#123;</span><br><span class="line">					o.hatchWeights0.x = hatchFactor - <span class="number">4.0</span>;</span><br><span class="line">					o.hatchWeights0.y = <span class="number">1.0</span> - o.hatchWeights0.x;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">3.0</span>) &#123;</span><br><span class="line">					o.hatchWeights0.y = hatchFactor - <span class="number">3.0</span>;</span><br><span class="line">					o.hatchWeights0.z = <span class="number">1.0</span> - o.hatchWeights0.y;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">2.0</span>) &#123;</span><br><span class="line">					o.hatchWeights0.z = hatchFactor - <span class="number">2.0</span>;</span><br><span class="line">					o.hatchWeights1.x = <span class="number">1.0</span> - o.hatchWeights0.z;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hatchFactor &gt; <span class="number">1.0</span>) &#123;</span><br><span class="line">					o.hatchWeights1.x = hatchFactor - <span class="number">1.0</span>;</span><br><span class="line">					o.hatchWeights1.y = <span class="number">1.0</span> - o.hatchWeights1.x;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					o.hatchWeights1.y = hatchFactor;</span><br><span class="line">					o.hatchWeights1.z = <span class="number">1.0</span> - o.hatchWeights1.y;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<span class="comment">//计算顶点的世界坐标</span></span><br><span class="line">				</span><br><span class="line">				TRANSFER_SHADOW(o);<span class="comment">//计算阴影纹理的采样坐标</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o; </span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;			</span><br><span class="line">				fixed4 hatchTex0 = tex2D(_Hatch0, i.uv) * i.hatchWeights0.x;</span><br><span class="line">				fixed4 hatchTex1 = tex2D(_Hatch1, i.uv) * i.hatchWeights0.y;</span><br><span class="line">				fixed4 hatchTex2 = tex2D(_Hatch2, i.uv) * i.hatchWeights0.z;</span><br><span class="line">				fixed4 hatchTex3 = tex2D(_Hatch3, i.uv) * i.hatchWeights1.x;</span><br><span class="line">				fixed4 hatchTex4 = tex2D(_Hatch4, i.uv) * i.hatchWeights1.y;</span><br><span class="line">				fixed4 hatchTex5 = tex2D(_Hatch5, i.uv) * i.hatchWeights1.z;<span class="comment">//对每张纹理进行采样并和他们对应的权重值相乘得到采样颜色</span></span><br><span class="line">				fixed4 whiteColor = fixed4(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) * (<span class="number">1</span> - i.hatchWeights0.x - i.hatchWeights0.y - i.hatchWeights0.z - </span><br><span class="line">							i.hatchWeights1.x - i.hatchWeights1.y - i.hatchWeights1.z);<span class="comment">//通过从1中减去所有6张纹理的权重得到纯白的贡献度</span></span><br><span class="line">				</span><br><span class="line">				fixed4 hatchColor = hatchTex0 + hatchTex1 + hatchTex2 + hatchTex3 + hatchTex4 + hatchTex5 + whiteColor;<span class="comment">//混合颜色值</span></span><br><span class="line">				</span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<span class="comment">//计算阴影值</span></span><br><span class="line">								</span><br><span class="line">				<span class="keyword">return</span> fixed4(hatchColor.rgb * _Color.rgb * atten, <span class="number">1.0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-3-扩展阅读"><a href="#14-3-扩展阅读" class="headerlink" title="14.3 扩展阅读"></a>14.3 扩展阅读</h3><p>在Unity资源商店里：</p>
<p>免费的卡通资源包推荐：Toon Shader Free</p>
<p>付费的非真实感渲染效果包推荐：Toon Styles Shader Pack，Hand-Drawn Shader Pack</p>
<h2 id="第十五章-使用噪声"><a href="#第十五章-使用噪声" class="headerlink" title="第十五章 使用噪声"></a>第十五章 使用噪声</h2><h3 id="15-1-消融效果"><a href="#15-1-消融效果" class="headerlink" title="15.1 消融效果"></a>15.1 消融效果</h3><p>**消融(dissolve)**效果常见于游戏中的角色死亡、地图烧毁等效果；在这些效果中，消融往往从不同的区域开始，并向看似随机的方向扩张，最后整个物体都消失不见；</p>
<p>该效果的原理概括来说就是噪声纹理+透明度测试；我们使用对噪声纹理采样的结果和某个控制消融程度的阈值比较，如果小于阈值，就使用clip函数把它对应的像素裁剪掉，这些部分就对应了消融的区域；而镂空区域边缘的烧焦效果则是将两种颜色混合，再用pow函数处理后，与原纹理颜色混合后的结果；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span></span><br><span class="line"><span class="comment">// Upgrade <span class="doctag">NOTE:</span> replaced &#x27;mul(UNITY_MATRIX_MVP,*)&#x27; with &#x27;UnityObjectToClipPos(*)&#x27;</span></span><br><span class="line"></span><br><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Dissolve&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_BurnAmount (&quot;Burn Amount&quot;, Range(<span class="number">0.0</span>, <span class="number">1.0</span>)) = <span class="number">0.0</span><span class="comment">//用于控制消融程度</span></span><br><span class="line">		_LineWidth(&quot;Burn Line Width&quot;, Range(<span class="number">0.0</span>, <span class="number">0.2</span>)) = <span class="number">0.1</span><span class="comment">//控制模拟烧焦效果时的线宽</span></span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//物体原本的漫反射纹理</span></span><br><span class="line">		_BumpMap (&quot;Normal Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;<span class="comment">//物体原本的法线纹理</span></span><br><span class="line">		_BurnFirstColor(&quot;Burn First Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_BurnSecondColor(&quot;Burn Second Color&quot;, Color) = (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)<span class="comment">//对应火焰边缘的两种颜色值</span></span><br><span class="line">		_BurnMap(&quot;Burn Map&quot;, <span class="number">2</span>D) = &quot;white&quot;&#123;&#125;<span class="comment">//噪声纹理</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;</span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">			Cull Off<span class="comment">//关闭了剔除功能，这样物体正面和背面都会被渲染</span></span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;AutoLight.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			fixed _BurnAmount;</span><br><span class="line">			fixed _LineWidth;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			<span class="type">sampler2D</span> _BumpMap;</span><br><span class="line">			fixed4 _BurnFirstColor;</span><br><span class="line">			fixed4 _BurnSecondColor;</span><br><span class="line">			<span class="type">sampler2D</span> _BurnMap;</span><br><span class="line">			</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			float4 _BumpMap_ST;</span><br><span class="line">			float4 _BurnMap_ST;</span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT;</span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float2 uvMainTex : TEXCOORD0;</span><br><span class="line">				float2 uvBumpMap : TEXCOORD1;</span><br><span class="line">				float2 uvBurnMap : TEXCOORD2;</span><br><span class="line">				float3 lightDir : TEXCOORD3;</span><br><span class="line">				float3 worldPos : TEXCOORD4;</span><br><span class="line">				SHADOW_COORDS(<span class="number">5</span>)</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.uvMainTex = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">				o.uvBumpMap = TRANSFORM_TEX(v.texcoord, _BumpMap);</span><br><span class="line">				o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);<span class="comment">//内置宏获取纹理坐标(片元着色器采样用)</span></span><br><span class="line">				</span><br><span class="line">				TANGENT_SPACE_ROTATION;</span><br><span class="line">  				o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">  				</span><br><span class="line">  				o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">  				</span><br><span class="line">  				TRANSFER_SHADOW(o);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;<span class="comment">//对噪声纹理采样</span></span><br><span class="line">				</span><br><span class="line">				clip(burn.r - _BurnAmount);<span class="comment">//采样结果和控制消融的阈值相减，当结果小于0，该像素会被剔除；</span></span><br><span class="line">				<span class="comment">//_BurnAmount会在后处理脚本中随时间变大</span></span><br><span class="line">				</span><br><span class="line">				float3 tangentLightDir = <span class="built_in">normalize</span>(i.lightDir);</span><br><span class="line">				fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uvBumpMap));</span><br><span class="line">				</span><br><span class="line">				fixed3 albedo = tex2D(_MainTex, i.uvMainTex).rgb;<span class="comment">//根据漫反射纹理得到材质的反射率</span></span><br><span class="line">				</span><br><span class="line">				fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<span class="comment">//计算环境光照</span></span><br><span class="line">				</span><br><span class="line">				fixed3 diffuse = _LightColor0.rgb * albedo * <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dot</span>(tangentNormal, tangentLightDir));<span class="comment">//计算漫反射光照</span></span><br><span class="line"></span><br><span class="line">				fixed t = <span class="number">1</span> - <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, _LineWidth, burn.r - _BurnAmount);<span class="comment">//t为1时表明该像素在消融的边界处，t为0说明为正常颜色，中间的插值模拟烧焦效果</span></span><br><span class="line">				fixed3 burnColor = lerp(_BurnFirstColor, _BurnSecondColor, t);</span><br><span class="line">				burnColor = <span class="built_in">pow</span>(burnColor, <span class="number">5</span>);<span class="comment">//使其更接近烧焦的痕迹</span></span><br><span class="line">				</span><br><span class="line">				UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<span class="comment">//计算阴影值</span></span><br><span class="line">				fixed3 finalColor = lerp(ambient + diffuse * atten, burnColor, t * <span class="built_in">step</span>(<span class="number">0.0001</span>, _BurnAmount));<span class="comment">//使用step函数来保证_BurnAmount为0时不显示消融效果，使用t混合正常颜色和烧焦颜色</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Pass to render object as a shadow caster</span></span><br><span class="line">		Pass &#123;<span class="comment">//定义投射阴影的Pass，防止被剔除的区域仍然会向其他物体投射阴影</span></span><br><span class="line">			Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma multi_compile_shadowcaster</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			fixed _BurnAmount;</span><br><span class="line">			<span class="type">sampler2D</span> _BurnMap;</span><br><span class="line">			float4 _BurnMap_ST;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				V2F_SHADOW_CASTER;<span class="comment">//定义阴影投射需要定义的变量</span></span><br><span class="line">				float2 uvBurnMap : TEXCOORD1;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(appdata_base v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				</span><br><span class="line">				TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)<span class="comment">//填充了V2F_SHADOW_CASTER背后声明的一些变量</span></span><br><span class="line">				</span><br><span class="line">				o.uvBurnMap = TRANSFORM_TEX(v.texcoord, _BurnMap);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				fixed3 burn = tex2D(_BurnMap, i.uvBurnMap).rgb;</span><br><span class="line">				</span><br><span class="line">				clip(burn.r - _BurnAmount);</span><br><span class="line">				</span><br><span class="line">				SHADOW_CASTER_FRAGMENT(i)<span class="comment">//让unity完成阴影投射的部分，把结果输出到深度图和阴影映射纹理中</span></span><br><span class="line">			&#125;</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-水波效果"><a href="#15-2-水波效果" class="headerlink" title="15.2 水波效果*"></a>15.2 水波效果*</h3><p>在模拟实时水面的过程中，我们往往也会使用噪声纹理；此时噪声纹理会用作一个高度图，以不断修改水面的法线方向；为了模拟水不断流动的效果，我们会使用和时间相关的变量来对噪声纹理进行采样，当得到法线信息后，再进行正常的反射+折射计算，得到最后的水面波动效果；</p>
<p>本节将使用一个噪声纹理得到的法线贴图实现一个包含菲涅耳反射的水面效果；</p>
<p>本节使用一张立方体纹理作为环境纹理，模拟反射；为了模拟折射效果，我们<strong>使用GrabPass来获取当前屏幕的渲染纹理，并使用切线空间下的法线方向对像素的屏幕坐标进行偏移，再使用该坐标对渲染纹理进行屏幕采样</strong>，从而模拟近似的折射效果；</p>
<p>与10.2.2不同的是，水波的法线纹理是由一张噪声纹理生成而得，而且会随着时间变化不断平移，模拟波光粼粼的效果；除此之外，我们没有使用一个定值来混合反射和折射颜色，而是<strong>通过菲涅耳系数来动态决定混合系数</strong>：<br>$$<br>fresnel&#x3D;pow(1-max(0,v·n)，4)<br>$$<br>v和n分别对应了视角方向和法线方向，他们的夹角越小，fresnel值越小，反射越弱，折射越强；菲涅耳系数还经常会用于边缘光照的计算中；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unity Shaders Book/Chapter <span class="number">15</span>/Water Wave&quot; &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (&quot;Main Color&quot;, Color) = (<span class="number">0</span>, <span class="number">0.15</span>, <span class="number">0.115</span>, <span class="number">1</span>)<span class="comment">//控制水面颜色</span></span><br><span class="line">		_MainTex (&quot;Base (RGB)&quot;, <span class="number">2</span>D) = &quot;white&quot; &#123;&#125;<span class="comment">//水面波纹材质纹理，默认为白色纹理</span></span><br><span class="line">		_WaveMap (&quot;Wave Map&quot;, <span class="number">2</span>D) = &quot;bump&quot; &#123;&#125;<span class="comment">//由噪声纹理生成的法线纹理</span></span><br><span class="line">		_Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<span class="comment">//用于模拟反射的立方体纹理</span></span><br><span class="line">		_WaveXSpeed (&quot;Wave Horizontal Speed&quot;, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span></span><br><span class="line">		_WaveYSpeed (&quot;Wave Vertical Speed&quot;, Range(<span class="number">-0.1</span>, <span class="number">0.1</span>)) = <span class="number">0.01</span><span class="comment">//分别用于控制法线在XY方向上的平移速度</span></span><br><span class="line">		_Distortion (&quot;Distortion&quot;, Range(<span class="number">0</span>, <span class="number">100</span>)) = <span class="number">10</span><span class="comment">//控制模拟折射时图像的扭曲程度</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<span class="comment">//将渲染队列设置成Transparent,确保渲染该物体时其他不透明物体已经渲染</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// This pass grabs the screen behind the object into a texture.</span></span><br><span class="line">		<span class="comment">// We can access the result in the next pass as _RefractionTex</span></span><br><span class="line">		GrabPass &#123; &quot;_RefractionTex&quot; &#125;<span class="comment">//定义了一个抓取屏幕图像的Pass，在这个Pass中我们定义了一个字符串，该字符串内部的名称决定了抓取得到的屏幕图像会存入哪个纹理；</span></span><br><span class="line">		</span><br><span class="line">		Pass &#123;</span><br><span class="line">			Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">			</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			</span><br><span class="line">			<span class="meta">#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line">			<span class="meta">#include &quot;Lighting.cginc&quot;</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma multi_compile_fwdbase</span></span><br><span class="line">			</span><br><span class="line">			<span class="meta">#pragma vertex vert</span></span><br><span class="line">			<span class="meta">#pragma fragment frag</span></span><br><span class="line">			</span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="type">sampler2D</span> _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line">			<span class="type">sampler2D</span> _WaveMap;</span><br><span class="line">			float4 _WaveMap_ST;</span><br><span class="line">			samplerCUBE _Cubemap;</span><br><span class="line">			fixed _WaveXSpeed;</span><br><span class="line">			fixed _WaveYSpeed;</span><br><span class="line">			<span class="type">float</span> _Distortion;	</span><br><span class="line">			<span class="type">sampler2D</span> _RefractionTex;<span class="comment">//对应了抓取的纹理名称</span></span><br><span class="line">			float4 _RefractionTex_TexelSize;<span class="comment">//得到纹理的纹素大小</span></span><br><span class="line">			</span><br><span class="line">			struct a2v &#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">				float4 tangent : TANGENT; </span><br><span class="line">				float4 texcoord : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			struct v2f &#123;</span><br><span class="line">				float4 pos : SV_POSITION;</span><br><span class="line">				float4 scrPos : TEXCOORD0;</span><br><span class="line">				float4 uv : TEXCOORD1;</span><br><span class="line">				float4 TtoW0 : TEXCOORD2;  </span><br><span class="line">				float4 TtoW1 : TEXCOORD3;  </span><br><span class="line">				float4 TtoW2 : TEXCOORD4; </span><br><span class="line">			&#125;;</span><br><span class="line">			</span><br><span class="line">			v2f vert(a2v v) &#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				</span><br><span class="line">				o.scrPos = ComputeGrabScreenPos(o.pos);<span class="comment">//得到对应被抓取屏幕图像的采样坐标</span></span><br><span class="line">				</span><br><span class="line">				o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">				o.uv.zw = TRANSFORM_TEX(v.texcoord, _WaveMap);<span class="comment">//获取纹理坐标</span></span><br><span class="line">				</span><br><span class="line">				float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  </span><br><span class="line">				fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  </span><br><span class="line">				fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  </span><br><span class="line">				fixed3 worldBinormal = <span class="built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; </span><br><span class="line">				</span><br><span class="line">				o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  </span><br><span class="line">				o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  </span><br><span class="line">				o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line">				<span class="comment">//我们需要在片元着色器中把法线方向从切线空间(由法线纹理采样得到)变换到世界空间下</span></span><br><span class="line">				<span class="comment">//因此计算该顶点的切线空间到世界空间的变换矩阵，分别存储矩阵的每一行</span></span><br><span class="line">				<span class="comment">//这里得到切线空间下的3个坐标轴在世界空间下的表示，再把他们依次按列组成一个变换矩阵(w分量被用来存储世界空间下的顶点坐标)</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">				float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<span class="comment">//得到世界坐标</span></span><br><span class="line">				fixed3 viewDir = <span class="built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));<span class="comment">//得到片元对应的视角方向</span></span><br><span class="line">				float2 speed = _Time.y * float2(_WaveXSpeed, _WaveYSpeed);<span class="comment">//用内置变量和平移速度计算了法线纹理的当前偏移量</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Get the normal in tangent space</span></span><br><span class="line">				fixed3 bump1 = UnpackNormal(tex2D(_WaveMap, i.uv.zw + speed)).rgb;</span><br><span class="line">				fixed3 bump2 = UnpackNormal(tex2D(_WaveMap, i.uv.zw - speed)).rgb;</span><br><span class="line">				fixed3 bump = <span class="built_in">normalize</span>(bump1 + bump2);<span class="comment">//用偏移量对法线纹理进行两次采样(模拟两层交叉的水面波动)，两次结果相加并归一化获得切线空间下的法线方向</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Compute the offset in tangent space</span></span><br><span class="line">				float2 <span class="keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;<span class="comment">//对屏幕图像的采样计算偏移值</span></span><br><span class="line">				i.scrPos.xy = <span class="keyword">offset</span> * i.scrPos.z + i.scrPos.xy;<span class="comment">//偏移量和z分量相乘来模拟深度越大、折射度越大的效果，然后计算便宜后的屏幕坐标</span></span><br><span class="line">				fixed3 refrCol = tex2D( _RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;<span class="comment">//对屏幕坐标进行透视除法，在使用该坐标对抓取的屏幕图像进行采样来得到模拟的折射颜色</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Convert the normal to world space</span></span><br><span class="line">				bump = <span class="built_in">normalize</span>(half3(<span class="built_in">dot</span>(i.TtoW0.xyz, bump), <span class="built_in">dot</span>(i.TtoW1.xyz, bump), <span class="built_in">dot</span>(i.TtoW2.xyz, bump)));<span class="comment">//把法线方向从切线空间变换到世界空间下</span></span><br><span class="line">				fixed4 texColor = tex2D(_MainTex, i.uv.xy + speed);<span class="comment">//主颜色纹理进行纹理动画模拟水波</span></span><br><span class="line">				fixed3 reflDir = <span class="built_in">reflect</span>(-viewDir, bump);</span><br><span class="line">				fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb * _Color.rgb;<span class="comment">//用反射方向对Cubemap进行采样，把结果和主纹理颜色相乘后得到反射颜色</span></span><br><span class="line">				</span><br><span class="line">				fixed fresnel = <span class="built_in">pow</span>(<span class="number">1</span> - saturate(<span class="built_in">dot</span>(viewDir, bump)), <span class="number">4</span>);<span class="comment">//计算菲涅耳系数</span></span><br><span class="line">				fixed3 finalColor = reflCol * fresnel + refrCol * (<span class="number">1</span> - fresnel);<span class="comment">//用系数混合折射和反射颜色得到最终的输出颜色</span></span><br><span class="line">				</span><br><span class="line">				<span class="keyword">return</span> fixed4(finalColor, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Do not cast shadow</span></span><br><span class="line">	FallBack Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中我们需要的是法线纹理，因此我们可以通过噪声纹理的灰度值生成法线信息，将纹理类型设置为Normal map，并选中create from grayscale来完成这一步骤；</p>
<h3 id="15-3-再谈全局雾效"><a href="#15-3-再谈全局雾效" class="headerlink" title="15.3 再谈全局雾效"></a>15.3 再谈全局雾效</h3><p>在13.3节我们使用深度纹理实现了基于屏幕后处理的全局雾效；我们由深度纹理重建每个像素在世界空间下的位置，再使用一个基于高度的公式来计算雾效的混合系数，最后使用该系数来混合雾的颜色和原屏幕颜色；</p>
<p>而本节将通过噪声纹理模拟一种不均匀的雾效，同时让雾不断飘动，使雾看起来更加缥缈；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;<span class="comment">//应用了噪声纹理的片元着色器</span></span><br><span class="line">			<span class="type">float</span> linearDepth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv_depth));</span><br><span class="line">			float3 worldPos = _WorldSpaceCameraPos + linearDepth * i.interpolatedRay.xyz;<span class="comment">//根据深度纹理重建像素在世界空间中的位置</span></span><br><span class="line">			</span><br><span class="line">			float2 speed = _Time.y * float2(_FogXSpeed, _FogYSpeed);<span class="comment">//计算噪声纹理偏移量</span></span><br><span class="line">			<span class="type">float</span> noise = (tex2D(_NoiseTex, i.uv + speed).r - <span class="number">0.5</span>) * _NoiseAmount;<span class="comment">//采样得到噪声值</span></span><br><span class="line">					</span><br><span class="line">			<span class="type">float</span> fogDensity = (_FogEnd - worldPos.y) / (_FogEnd - _FogStart); <span class="comment">//计算应用噪声后的雾效混合系数</span></span><br><span class="line">			fogDensity = saturate(fogDensity * _FogDensity * (<span class="number">1</span> + noise));</span><br><span class="line">			</span><br><span class="line">			fixed4 finalColor = tex2D(_MainTex, i.uv);</span><br><span class="line">			finalColor.rgb = lerp(finalColor.rgb, _FogColor.rgb, fogDensity);<span class="comment">//和原始颜色混合后返回</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">return</span> finalColor;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十六章-Unity中的渲染优化技术"><a href="#第十六章-Unity中的渲染优化技术" class="headerlink" title="第十六章 Unity中的渲染优化技术"></a>第十六章 Unity中的渲染优化技术</h2><p>游戏优化不仅是程序员的工作，更需要美工人员在游戏的美术上进行一定的权衡，例如避免使用全屏的屏幕特效，避免使用计算复杂的Shader，减少透明混合造成的overdraw等；</p>
<h3 id="16-1-移动平台的特点"><a href="#16-1-移动平台的特点" class="headerlink" title="16.1 移动平台的特点"></a>16.1 移动平台的特点</h3><p> 和PC平台相比，移动平台上的GPU架构有很大的不同；由于处理资源等条件的限制，移动设备上的GPU架构专注于尽可能使用更小的带宽和功能，也由此带来了许多和PC平台完全不同的现象；</p>
<p>例如为了尽可能移除那些隐藏的表面，减少overdraw(即一个像素被绘制多次)：</p>
<ol>
<li>PowerVR芯片使用了<strong>基于瓦片的延迟渲染</strong>架构，把所有的渲染图像装入一个个瓦片(tile)中，再由硬件找到可见的片元，只有这些片元执行片元着色器；</li>
<li>Adreno(高通的芯片)和Mali(ARM的芯片)则会使用Early-Z或相似的技术进行低精度的深度检测来剔除不需要的片元；</li>
<li>Tegra(英伟达的芯片)则使用了传统的架构设计，因此在这些设备上，overdraw更可能造成性能的瓶颈；</li>
</ol>
<p>由于这些芯片架构造成的不同，一些游戏往往需要针对不同的芯片发布不同的版本来进行针对优化；尤其是Android上，不同设备的图形芯片、屏幕分辨率等，大相径庭，对图形优化提出了更高的挑战；</p>
<h3 id="16-2-影响性能的因素"><a href="#16-2-影响性能的因素" class="headerlink" title="16.2 影响性能的因素"></a>16.2 影响性能的因素</h3><p>对于一个游戏，主要使用两种计算资源：CPU和GPU；它们会合作来让我们的游戏可以在预期的帧率和分辨率下工作；<strong>其中CPU主要负责保证帧率，GPU主要负责分辨率相关的一些处理；</strong></p>
<p>据此，我们可以对造成游戏性能瓶颈的主要原因分类：</p>
<ol>
<li>CPU<ul>
<li>过多的draw call</li>
<li>复杂的脚本或者物理模拟</li>
</ul>
</li>
<li>GPU<ul>
<li>顶点处理<ul>
<li>过多的顶点</li>
<li>过多的逐顶点计算</li>
</ul>
</li>
<li>片元处理<ul>
<li>过多的片元(可能是由分辨率造成，也可能由于overdraw造成)</li>
<li>过多的逐片元计算</li>
</ul>
</li>
</ul>
</li>
<li>带宽<ul>
<li>使用了尺寸很大且未压缩的纹理</li>
<li>分辨率过高的帧缓存</li>
</ul>
</li>
</ol>
<p>draw call造成的CPU瓶颈在之前已经提及；造成CPU瓶颈的其他原因还有物理、布料模拟、蒙皮、粒子模拟等，这些都是计算量很大的操作；</p>
<p>而对于GPU，他负责整个渲染流水线，相关的优化策略可以从<strong>减少处理的数据规模</strong>(顶点数目和片元数目)、<strong>减少运算复杂度</strong>方面入手</p>
<h3 id="16-3-Unity中的渲染分析工具"><a href="#16-3-Unity中的渲染分析工具" class="headerlink" title="16.3 Unity中的渲染分析工具"></a>16.3 Unity中的渲染分析工具</h3><p>Unity内置了一些工具，来帮助我们方便的查看和渲染相关的各个统计数据，这些数据可以帮助我们分析游戏渲染性能，从而更有针对性地进行优化；</p>
<p>在Unity5中，这些工具包括了**渲染统计窗口(Rendering Statistics Window)、性能分析器(Profiler)以及帧调试器(Frame Debugger)**；</p>
<p><strong>渲染统计窗口：</strong></p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220912152311762.png" alt="image-20220912152311762"></p>
<p>该窗口显示了当前游戏的各个渲染统计变量，主要包含了三方面的信息：音频(Audio)、图像(Graphics)和网络(Network)；</p>
<table>
<thead>
<tr>
<th>信息名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>每帧的时间和FPS</td>
<td>给出了处理和渲染一帧所需的时间以及FPS数目</td>
</tr>
<tr>
<td>Batches</td>
<td>一帧中需要进行的批处理数目</td>
</tr>
<tr>
<td>Saved by batching</td>
<td>合并的批处理数目，这个数字表明批处理为我们节省了多少draw call</td>
</tr>
<tr>
<td>Tris和Verts</td>
<td>需要绘制的三角面片和顶点数目</td>
</tr>
<tr>
<td>Screen</td>
<td>屏幕的大小，以及它占用的内存大小</td>
</tr>
<tr>
<td>SetPass</td>
<td>渲染使用的Pass数目，每个Pass都需要Unity的runtime来绑定一个新的Shader，这可能造成CPU的瓶颈</td>
</tr>
<tr>
<td>Visible Skinned Meshes</td>
<td>渲染的蒙皮网格的数目</td>
</tr>
<tr>
<td>Animations</td>
<td>播放的动画数目</td>
</tr>
</tbody></table>
<p><strong>性能分析器的渲染区域：</strong></p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220912153133292.png" alt="image-20220912153133292"></p>
<p>单击Window-&gt;Analysis-&gt;Profiler即可打开；</p>
<p>性能分析器显示了绝大部分在渲染统计窗口中提供的信息，绿线显示了批处理数目，蓝线显示了Pass数目等；</p>
<h3 id="16-4-减少draw-call数目"><a href="#16-4-减少draw-call数目" class="headerlink" title="16.4 减少draw call数目"></a>16.4 减少draw call数目</h3><p>批处理的实现原理就是为了减少每一帧需要的draw call数目；批处理的思想很简单，就是在每次调用draw call时尽可能多的处理多个物体；</p>
<p>那么什么样的物体可以一起处理呢，答案是使用同一个材质的物体，这些物体的不同仅仅在于顶点数据的差别；我们可以把这些顶点数据合并在一起，再一起发送给GPU，就可以完成一次批处理；</p>
<p>Unity中支持两种批处理方式：一种是动态批处理，另一种是静态批处理；</p>
<ul>
<li>对于动态批处理来说，优点是一切处理都是Unity自动完成的，而且物体是可以移动的，但缺点是限制很多，可能一不小心就会破坏了这种机制，导致Unity无法动态批处理一些使用了相同材质的物体；</li>
<li>而对于静态批处理来说，他的优点是自由度很高，限制很少；但缺点是可能会占用更多的内存，而且经过静态批处理后所有物体都不可以再移动了(即使在脚本中尝试改变物体的位置也是无效的)；</li>
</ul>
<h4 id="16-4-1-动态批处理"><a href="#16-4-1-动态批处理" class="headerlink" title="16.4.1 动态批处理"></a>16.4.1 动态批处理</h4><p>动态批处理的物体仍然可以移动，是由于在处理每帧时Unity都会重新合并一次网格；但只有满足条件的模型和材质才可以被动态批处理，一些主要的条件限制如下：</p>
<ul>
<li>网格的<strong>顶点属性规模要</strong>小于900；例如，如果shader中需要使用顶点位置、法线和纹理坐标这3个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300；需要注意的是这个数字在未来可能会发生变化；</li>
<li>一般来说，所有对象都需要使用<strong>同一个缩放尺度</strong>；一个例外是，如果<strong>所有的物体都使用了不同的非统一缩放</strong>，那么他们也是可以被动态批处理的；但在Unity5中，这种对模型缩放的限制已经不存在了；</li>
<li>使用光照纹理(lightmap)的物体需要小心处理；这些物体需要额外的渲染参数，例如在光照纹理上的索引、偏移量和缩放信息等；因此，为了让这些物体可以被动态批处理，我们需要<strong>保证它们指向光照纹理中的同一个位置</strong>；</li>
<li><strong>多Pass的shader会中断批处理</strong>；在前向渲染中，我们有时需要使用额外的Pass来为模型添加更多的光照效果，但这样一来模型就不会被动态批处理了；</li>
</ul>
<h4 id="16-4-2-静态批处理"><a href="#16-4-2-静态批处理" class="headerlink" title="16.4.2 静态批处理"></a>16.4.2 静态批处理</h4><p>相比于动态批处理来说，静态批处理适用于任何大小的几何模型；</p>
<p>他的实现原理是，只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格结构中，这意味着这些模型不可以在运行时刻被移动；但由于仅需一次合并操作，因此比动态批处理更加高效；</p>
<p>但是静态批处理的一个缺点在于，它往往<strong>需要占用更多的内存来存储合并后的几何结构</strong>；这是因为，如果在静态批处理前一些物体共享了相同的网格，那么在内存中每一个物体都会对应一个该网格的复制品，即一个网格会变成多个网格再发送给GPU，如果这类使用同一网格的对象很多，那么这就会成为一个性能瓶颈了；例如如果使用了1000个相同树模型的森林中使用静态批处理，那么就会多使用1000倍的内存；这种时候，解决方法要么忍受这种牺牲内存换取性能的方法，要么不要使用静态批处理，而使用动态批处理技术，或者自己编写批处理的方法；</p>
<p>静态批处理的实现非常简单，只需要把物体面板上的Static复选框勾选上即可(其实只需要Batching Static)；</p>
<p>在内部实现上，Unity首先把这些静态物体变换到世界空间下，然后为它们构建一个更大的顶点和索引缓存；对于使用了同一材质的物体，Unity只需要调用一个draw call就可以绘制全部物体，而对于使用了不同材质的物体，静态批处理同样可以提升渲染性能；尽管这些物体仍然需要多个draw call，但静态批处理可以减少这些draw call之间的状态切换，而这些切换往往是费时的操作；</p>
<p>如果场景中包含了除了平行光以外的其他光源，并且在shader中定义了额外的Pass来处理它们，这些额外的Pass部分是不会被批处理的；但是处理平行光的Base Pass部分仍然会被静态批处理，因此我们仍然可以节省两个draw call；</p>
<h4 id="16-4-3-共享材质"><a href="#16-4-3-共享材质" class="headerlink" title="16.4.3 共享材质"></a>16.4.3 共享材质</h4><p>由于批处理需要共享材质，因此我们需要一些策略来尽可能合并材质；</p>
<p>如果两个材质之间只有使用的纹理不同，我们可以把这些纹理合并到一张更大的纹理中，这张更大的纹理被称为是一张图集(atlas)；一旦使用了同一张纹理，我们就可以使用同一个材质，再使用不同的坐标对纹理进行采样即可；</p>
<p>但不同的物体可能在材质上还有一些微小的变化，例如颜色不同、某些浮点属性不同；但是我们要求的是同一个材质，而不是同一种shader的材质；这样就会因为微小调整影响到所有对象，一种解决方法就是使用网格的顶点数据(最常见的就是顶点颜色数据)来存储这些参数；</p>
<p>需要注意的是如果我们需要在脚本中访问共享材质，应该<strong>使用Renderer.sharedMaterial来保证修改的是和其他物体共享的材质</strong>，这意味着修改会应用到所有使用该材质的物体上；而如果使用Renderer.material来修改材质，Unity会创建一个该材质的复制品，从而破坏批处理；</p>
<h4 id="16-4-4-批处理的注意事项"><a href="#16-4-4-批处理的注意事项" class="headerlink" title="16.4.4 批处理的注意事项"></a>16.4.4 批处理的注意事项</h4><ul>
<li>尽可能选择静态批处理，时刻小心内存消耗和无法移动；</li>
<li>对于游戏中的小道具例如金币等，可以使用动态批处理；</li>
<li>对于包含动画的物体，我们无法全部使用静态批处理，但其中如果有不同的部分，可以把这部分标识成“Static”；</li>
<li>批处理需要把多个模型变换到世界空间下再合并，因此shader中基于模型空间下坐标的运算会出现错误；此时可以在shader中使用DisableBatching标签来强制使用该shader的材质不会被批处理；</li>
<li>使用半透明材质的物体通常需要使用严格的从后往前的顺序，对于这些物体，Unity会首先保证渲染顺序再尝试批处理，即如果渲染顺序无法满足时，批处理无法成功应用；</li>
</ul>
<h3 id="16-5-减少需要处理的顶点数目"><a href="#16-5-减少需要处理的顶点数目" class="headerlink" title="16.5 减少需要处理的顶点数目"></a>16.5 减少需要处理的顶点数目</h3><h4 id="16-5-1-优化几何体"><a href="#16-5-1-优化几何体" class="headerlink" title="16.5.1 优化几何体"></a>16.5.1 优化几何体</h4><p>在Unity的渲染统计窗口中，我们可以查看渲染当前帧需要的三角面片数目和顶点数目；该数目往往大于建模软件里显示的顶点数；</p>
<p>因为Unity在GPU上计算顶点数，有时需要将一个顶点拆分成两个或更多，主要原因有两个：</p>
<ul>
<li>为了分离纹理坐标</li>
<li>为了产生平滑的边界</li>
</ul>
<p>其本质是因为对于GPU，顶点的每一个属性和顶点之间必须是一对一的关系，分离纹理坐标是因为一个顶点有多个纹理坐标，例如正方体的六个面，不同面上同一个点的纹理坐标可能并不相同；平滑边界类似，此时一个顶点可能对应多个法线或切线信息，这通常是因为我们需要决定一条边是硬边还是平滑边；</p>
<p>对于GPU来说，它本质上只关心有多少顶点，因此应移除不必要的硬边以及纹理衔接，避免边界平滑和纹理分离，减少顶点数目是真正要关心的事情；</p>
<h4 id="16-5-2-模型的LOD技术"><a href="#16-5-2-模型的LOD技术" class="headerlink" title="16.5.2 模型的LOD技术"></a>16.5.2 模型的LOD技术</h4><p>另一个减少顶点数目的方法是使用LOD技术，即当物体离摄像机远时，减少模型上的面片数量从而提高性能；</p>
<p>在Unity中，我们可以使用LOD Group组件来为一个物体构建一个LOD，我们需要为同一个对象准备多个包含不同细节程度的模型然后赋给LOD Group组件中的不同等级；</p>
<h4 id="16-5-3-遮挡剔除技术"><a href="#16-5-3-遮挡剔除技术" class="headerlink" title="16.5.3 遮挡剔除技术"></a>16.5.3 遮挡剔除技术</h4><p>该技术可以用来消除那些在其他物件后面看不到的物件，这意味资源不会浪费在看不见的顶点上，进而提升性能；</p>
<p><strong>我们需要把遮挡剔除和摄像机的视锥体剔除区分开来</strong>；视锥体剔除只会剔除掉那些不在视野范围内的对象，但不会判断遮挡关系，而遮挡剔除会使用一个虚拟摄像机来遍历场景，从而构建一个潜在可见的对象集合的层级结构；在运行时，每个摄像机会用这个数据识别哪个物体可见哪些不可见，可以减少处理的顶点数目和overdraw，提高性能；</p>
<h3 id="16-6-减少需要处理的片元数目"><a href="#16-6-减少需要处理的片元数目" class="headerlink" title="16.6 减少需要处理的片元数目"></a>16.6 减少需要处理的片元数目</h3><p>这部分优化的重点在于减少overdraw即同一个像素绘制多次；</p>
<h4 id="16-6-1-控制绘制顺序"><a href="#16-6-1-控制绘制顺序" class="headerlink" title="16.6.1 控制绘制顺序"></a>16.6.1 控制绘制顺序</h4><p>由于深度测试的存在，如果我们可以保证物体都是从前往后绘制的，那么就可以很大程度减少overdraw；</p>
<p>在Unity中，那些渲染队列数目小于2500(“Background”,”Geometry”和”AlphaTest”)的对象都被认为是不透明物体，这些物体总体上是从前往后绘制的，而使用其他队列的物体则是从后往前绘制的；这意味着我们应该尽可能把物体队列设置为不透明的渲染队列；</p>
<p>而且我们可以充分利用Unity的渲染队列来控制绘制顺序，例如在FPS中，对于游戏中的主要人物角色来说，他们使用的shader往往比较复杂，但是他们通常会挡住屏幕的很大一部分区域，我们可以先绘制他们(使用更小的渲染队列)；而对于敌方，他们经常出现在掩体后面，因此我们可以在所有常规的不透明物体后面渲染他们(更大的渲染队列)；而对于天空盒子，几乎覆盖了所有的像素，而且我们知道它永远会出现在所有物体的后面，因此它的队列可以设置为“Geometry+1”，这样就不会因为它造成overdraw；</p>
<h4 id="16-6-2-时刻警惕透明物体"><a href="#16-6-2-时刻警惕透明物体" class="headerlink" title="16.6.2 时刻警惕透明物体"></a>16.6.2 时刻警惕透明物体</h4><p>半透明对象没有开启深度写入，因此需要从后往前渲染，这意味着几乎一定会造成overdraw；如果不注意会造成严重性能下降，比如如果屏幕中GUI占据的比例很多，主摄像机又没有调整而是投影整个屏幕，那么GUI就会造成大量overdraw；</p>
<p>因此我们应该避免大量半透明对象和GUI占面积很大的情况；或者可以将GUI的绘制交给不同的摄像机；我们应当在代码中对机器的性能进行判断，逐步测试；</p>
<p>移动平台上，它的实现使用了discard或clip操作，会导致一些硬件的优化策略失效；</p>
<h4 id="16-6-3-减少实时光照和阴影"><a href="#16-6-3-减少实时光照和阴影" class="headerlink" title="16.6.3 减少实时光照和阴影"></a>16.6.3 减少实时光照和阴影</h4><p>实时光照对于移动平台是一种非常昂贵的操作；因此一种方法是使用光照烘焙技术；</p>
<p>另一种方法是使用God Ray，场景中很多小型光源的效果都是靠这种方法模拟的，它们一般不是真的光源，很多情况是通过透明纹理模拟得到的；</p>
<p>在《ShadowGun》中，开发者把复杂的光照计算存储到一张查找纹理(lookup table,LUT)中；然后在运行时刻，我们只需要使用光源方向、视角方向、法线方向等参数，对LUT采样得到光照结果即可；使用这样的查找纹理，不仅可以让我们使用更出色的光照模型，例如更加复杂的BRDF，还可以利用查找纹理的大小来进一步优化性能，例如主要角色使用更大分辨率的LUT，而一些NPC使用较小的LUT；该游戏的作者开发了一个LUT烘焙工具，来帮助美工人员快速调整光照模型，并把结果存储到LUT中；</p>
<p>实时阴影同样是一个非常消耗性能的效果，不仅CPU需要提交更多的draw call，GPU也需要进行更多的处理，因此我们应当尽量减少实时阴影；例如使用烘焙阴影，将阴影信息存储到光照纹理中，而只对场景中的动态物体使用适当的实时阴影；</p>
<h3 id="16-7-节省带宽"><a href="#16-7-节省带宽" class="headerlink" title="16.7 节省带宽"></a>16.7 节省带宽</h3><p>大量使用未经压缩的纹理以及使用过大的分辨率都会造成由于带宽而引发的性能瓶颈；</p>
<h4 id="16-7-1-减少纹理大小"><a href="#16-7-1-减少纹理大小" class="headerlink" title="16.7.1 减少纹理大小"></a>16.7.1 减少纹理大小</h4><p>使用纹理图集可以帮助我们减少draw call，但是这些纹理的大小同样是一个需要考虑的问题；需要注意的是所有纹理的长宽比最好是正方形，而且长宽值最好是2的整数幂。这是因为有很多优化策略只有在这种时候才可以发挥最大效用，在Unity5中，会自动把长宽转换到离他最近的2的整数幂值；但我们仍然应该尽量遵守来避免放缩造成的问题；</p>
<p>我们还应该尽可能使用多级渐远纹理技术(mipmapping)和纹理压缩；</p>
<p>当勾选了Generate Mip Maps选项后，Unity就会为同一张纹理创建出很多不同大小的小纹理，构成一个纹理金字塔，运行中就会根据距离来动态选择使用哪个纹理；</p>
<p>纹理压缩同样可以节省带宽；但对于像Android这样的平台，有很多不同架构的GPU，纹理压缩就变的有点复杂，因为不同的GPU架构有他自己的纹理压缩格式；所幸Unity可以根据不同的设备选择不同的压缩格式，而我们只需要把纹理压缩格式设置为自动压缩即可；GUI类型的纹理是个例外，一些时候由于画质的要求，我们不希望对这些纹理进行压缩；</p>
<h4 id="16-7-2-利用分辨率缩放"><a href="#16-7-2-利用分辨率缩放" class="headerlink" title="16.7.2 利用分辨率缩放"></a>16.7.2 利用分辨率缩放</h4><p>过高的屏幕分辨率是造成性能下降的原因之一，过大的屏幕分辨率和糟糕的GPU是两个性能瓶颈；</p>
<p>在Unity中设置屏幕分辨率可以直接调用Screen.SetResolution，实际使用可能会遇到问题，雨松MOMO有一篇文章(xuanyusong网站的&#x2F;archives&#x2F;3205)详细讲解了如何使用该技术；</p>
<h3 id="16-8-减少计算复杂度"><a href="#16-8-减少计算复杂度" class="headerlink" title="16.8 减少计算复杂度"></a>16.8 减少计算复杂度</h3><h4 id="16-8-1-Shader的LOD技术"><a href="#16-8-1-Shader的LOD技术" class="headerlink" title="16.8.1 Shader的LOD技术"></a>16.8.1 Shader的LOD技术</h4><p>和模型的LOD技术类似，Shader的LOD技术可以控制使用的Shader等级；他的原理是只有Shader的LOD值小于某个设定的值，这个Shader才会被使用，而使用了超过设定值的Shader的物体不会被渲染：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">	Tags&#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">	LOD <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在Unity Shader的导入面板上看到该Shader使用的LOD值；默认情况下，允许的LOD等级是无限大的；这意味着任何被当前显卡支持的Shader都可以被使用；如果某些情况需要去掉一些复杂的Shader渲染，我们可以使用Shader.maximumLOD或Shader.globalMaximumLOD来设置允许的最大LOD值；</p>
<p>Unity内置的Shader使用了不同的LOD值，例如Diffuse的LOD为200，Bumped Specular的LOD为400；</p>
<h4 id="16-8-2-代码方面的优化"><a href="#16-8-2-代码方面的优化" class="headerlink" title="16.8.2 代码方面的优化"></a>16.8.2 代码方面的优化</h4><p><strong>尽可能使用低精度的浮点值进行运算</strong></p>
<ul>
<li><p>最高精度的float&#x2F;highp适用于存储诸如顶点坐标等变量，但它的计算速度是最慢的，我们应该尽量避免在片元着色器中使用这种精度进行计算；</p>
</li>
<li><p>而half&#x2F;mediump适用于一些标量、纹理坐标等变量，它的计算速度大约是float的两倍；</p>
</li>
<li><p>fixed&#x2F;lowp适用于绝大多数颜色变量和归一化后的方向矢量，再进行一些对精度要求不高的计算时，我们应该尽量使用这种精度的变量；他的计算速度大约是float的4倍，但要避免对这些低精度变量进行频繁的swizzle操作(如color.xwxw)；</p>
</li>
</ul>
<p>而且我们应当<strong>尽量避免在不同精度之间的转换</strong>，这可能造成性能下降；</p>
<p>如果特别关心游戏在PowerVR上的性能，就不要把两个纹理打包在同一个四维变量中，这样GPU无法进行一些纹理的预读取，他会认为这些纹理采样依赖其他数据；</p>
<p><strong>尽可能不要使用全屏的屏幕后处理效果</strong>，使用屏幕特效时尽量使用fixed&#x2F;lowp进行低精度运算，那些高精度的运算可以使用LUT或者转移到顶点着色器处理；同时<strong>尽量把多个特效合并到一个Shader中</strong>；</p>
<p>还有一些规则：</p>
<ul>
<li>尽可能不要使用分支和循环语句；</li>
<li>尽可能避免sin,tan,pow,log等较为复杂的数学运算，可以用LUT替代；</li>
<li>尽可能不要使用discard操作，会影响硬件的某些优化；</li>
</ul>
<h2 id="第十七章-Unity的表面着色器"><a href="#第十七章-Unity的表面着色器" class="headerlink" title="第十七章 Unity的表面着色器"></a>第十七章 Unity的表面着色器</h2><ul>
<li>如果需要和各种光源打交道，尤其是想要使用Unity中的全局光照的话，你可能更喜欢表面着色器，但需要时刻小心他的性能；</li>
<li>如果需要处理的光源数目非常少，例如只有一个平行光，顶点&#x2F;片元着色器是更好的选择；</li>
<li>如果有很多自定义的渲染效果，请选择顶点&#x2F;片元着色器；</li>
</ul>
<h2 id="第十八章-基于物理的渲染"><a href="#第十八章-基于物理的渲染" class="headerlink" title="第十八章 基于物理的渲染"></a>第十八章 基于物理的渲染</h2><h3 id="18-1-PBS的理论和数学基础"><a href="#18-1-PBS的理论和数学基础" class="headerlink" title="18.1 PBS的理论和数学基础"></a>18.1 PBS的理论和数学基础</h3><h4 id="18-1-1-光是什么"><a href="#18-1-1-光是什么" class="headerlink" title="18.1.1 光是什么"></a>18.1.1 光是什么</h4><p>光由太阳或其他光源中被发射出来，然后与场景中的对象相交；一些光线被<strong>吸收</strong>，而另一些则被<strong>散射</strong>，最后光线被一个感应器吸收成像；</p>
<p>在光的传播过程中，影响光的一个重要的特性是材质的折射率；我们知道，在均匀的介质中，光是沿直线传播的；但如果光在传播时介质的折射率发生了变化，光的传播方向就会发生变化；特别是，如果折射率是突变的，就会发生光的散射现象；</p>
<p>事实上现实生活中，光和物体的交互过程非常复杂，并不存在一个可分析的解决方法；但为了在渲染中对光照进行建模，我们往往只考虑一种特殊情况，即只考虑两个介质的边界是无限大并且是光学平滑的；在这样的前提下，光在不同介质的边界会被分割成两个方向：反射和折射方向，而不同方向的百分比则是由<strong>菲涅耳等式</strong>来描述的；</p>
<p>与光线的交界处相对于光的波长来说确实可以认为光学平坦；但是实际上物体表面有很多凹凸不平的平面，此时和光照发生的各种行为更像是<strong>和一系列微小的光学光滑平面和光交互</strong>的结果，其中每个平面会把光分割成不同的方向；</p>
<p>这种建立在微表面的模型更容易解释为什么有些物体看起来粗糙，而有些看起来平滑：一个光滑物体的表面，微表面的法线方向变化角度小，因此表面反射的光线方向变化也比较小，这使得物体的高光反射更加清晰；粗糙物体则相反；</p>
<p>对于被折射的光，这些光折射到物体的内部，一部分被介质吸收，一部分又被散射到外部；金属材质具有很高的吸收系数，因此所有折射光往往立刻被吸收；而非金属材质则会同时出现吸收和散射两种现象，这些散射出去的光又被称为<strong>次表面散射光</strong>：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-2afcab6bbd51c149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300/format/webp" alt="img"></p>
<p>从渲染角度，微表面反射的光可以认为是该点上一些方向变化不大的反射光；而次表面散射光会从不同于入射点的位置从物体内部再次射出，而这些离入射点的距离值如果小于像素大小，意味着距离可以忽略，那渲染就可以在局部进行；但如果像素小于距离值，我们就需要特殊的渲染模型，即<strong>次表面散射渲染技术</strong>；</p>
<h4 id="18-1-2-双向反射分布函数-BRDF"><a href="#18-1-2-双向反射分布函数-BRDF" class="headerlink" title="18.1.2 双向反射分布函数(BRDF)"></a>18.1.2 双向反射分布函数(BRDF)</h4><p>我们可以用<strong>辐射率(radiance)<strong>来量化光；辐射率是单位面积、单位方向上光源的辐射通量，通常用L来表示，被认为是对单一光线的亮度和颜色评估；在渲染中，我们通常会基于表面的入射光线的入射辐射率L<del>i</del>来计算出射辐射率L<del>0</del>，这个过程也往往被称为是</strong>着色</strong>过程；</p>
<p>要得到出射辐射率，我们需要知道物体表面一点是如何和光进行交互的；而这个过程就可以使用BRDF(双向反射分布函数)来定量分析；大多数情况下，BRDF可以用<strong>f(l,v)<strong>来表示，l为入射方向，v为观察方向；这种情况下，绕着表面法线旋转入射方向或观察方向不会影响BRDF的结果，这种BRDF被称为是</strong>各向同性</strong>的BRDF，对应的是<strong>各向异性</strong>的BRDF；</p>
<p>BRDF有两种理解方式：</p>
<ul>
<li>当给定入射角度后，BRDF可以给出所有出射方向上的反射和散射光线的相对分布情况；</li>
<li>当给定观察方向(即出射方向)后，BRDF可以给出从所有入射方向到该出射方向的光线分布；</li>
</ul>
<p>一个更直观的理解是，<strong>当一束光线沿着入射方向l到达表面某点时，f(l,v)表示了有多少部分的能量被反射到了观察方向v上</strong>；</p>
<p>据此，在PBR中，第一个重要的等式——反射等式(<strong>reflection equation</strong>)：<br>$$<br>L_0(v)&#x3D;\int_Ωf(l,v)×L_1(l)(n·l)dω_i<br>$$<br>反射等式实际上是渲染方程的一个特殊情况，但它是基于物理的；</p>
<p>在游戏渲染中，我们通常和一些精确光源打交道，而不是计算所有入射光线在半球面上的积分；精确光源即方向确定、大小为无限小的光源；我们使用l<del>c</del>来表示它的方向，使用c<del>light</del>表示它的颜色，此时可以大大简化上面的反射等式，对于一个精确光源，我们可以使用下面的等式计算它在某个观察方向v上的出射辐射率：<br>$$<br>L_0(v)&#x3D;πf(l_c,v)×c_{light}(n·l_c)<br>$$<br>该式使用一个特定的BRDF值来代替积分操作，大大简化了计算；如果场景中包含多个精确光源，我们分别代入式子最后结果相加即可；</p>
<h4 id="18-1-3-漫反射项"><a href="#18-1-3-漫反射项" class="headerlink" title="18.1.3 漫反射项"></a>18.1.3 漫反射项</h4><p>之前学习的Lambert模型是最简单、也是应用最广泛的漫反射BRDF，准确的 Lambert BRDF的表示为：<br>$$<br>f_{Lambert}(l,v)&#x3D;\frac{c_{diff}}{π}<br>$$<br>其中c<del>diff</del>表示漫反射光线所占的比例，它也通常被称为是漫反射颜色；与我们之前的Lambert光照模型不太一样的是，上面的式子实际上是一个定值，我们常见到的余弦(n·l)因子部分实际是反射等式的一部分，而不是BRDF的一部分；上面的式子之所以要除以π，是因为我们假设漫反射在所有方向上的强度都是相同的，而BRDF要求在半球内的积分制为1；因此，给定入射方向l的光源在表面某点的出射漫反射辐射率为：<br>$$<br>L_{diff}&#x3D;\frac{c_{diff}}{π}×L_i(l)(n·l)<br>$$<br>Lambert模型虽然简单，但很多基于物理的渲染选择使用了更复杂的漫反射项来模拟次表面散射的效果；</p>
<h4 id="18-1-4-高光反射项"><a href="#18-1-4-高光反射项" class="headerlink" title="18.1.4 高光反射项"></a>18.1.4 高光反射项</h4><p>现实生活中，几乎所有的物体都或多或少有高光反射现象；在PBR中，BDRF中的高光反射项大多数都是建立在<strong>微面元理论</strong>的假设上的；该理论认为，物体表面实际是由许多人眼看不到的微面元组成的，虽然物体表面并不是光学平滑的，但这些微面元可以被认为是光学平滑的，也就是说它们具有完美的高光反射；当光线和物体表面一点相交时，实际上是和一系列微面元交互的结果；</p>
<p>假设表面法线为n，这些微面元的法线m并不都等于n，因此，不同的微面元会把同一入射方向的光线反射到不同的方向上；而当我们计算BRDF时，入射方向l和观察方向v都会被给定，这意味着只有一部分微面元反射的光线才会进入我们的眼睛肿，这部分微面元会恰好把光线反射到方向v上，即他们的法线m等于l和v的一半，也就是我们一直看到的半角度矢量h(a图)；</p>
<p>然而这些m&#x3D;h的微面元反射也并不会全部添加到BRDF的计算中，这是因为他们其中的一部分会在入射方向l上被其他微面元挡住(b图)，或是在他们的反射方向v上被其他微面元挡住了(c)；微面元理论认为，所有这些被遮挡住的微面元不会添加到高光反射项的计算中；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2372757-34090dd12b7ca68d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>基于微面元理论的这些假设，BRDF的高光反射项可以用下面的形式来表示：<br>$$<br>f_{spec}(l,v)&#x3D;\frac{F(l,h)G(l,v,h)D(h)}{4(n·l)(n·v)}<br>$$<br>这就是著名的Torrance-Sparrow微面元模型：</p>
<ul>
<li>D(h)是微面元的<strong>法线分布函数</strong>，它用于计算有多少比例的微面元的法线满足m&#x3D;h，只有这部分微面元才会把光线从l方向反射到v上。</li>
<li>G(l,v,h)是<strong>阴影—遮掩函数</strong>，它用于计算那些满足m&#x3D;h的微面元中有多少会由于遮挡而不会被人眼看到，因此他给出了活跃的微面元所占的浓度，只有活跃的微面元才会成功地把光线反射到观察方向上；</li>
<li>F(l,h)则是这些活跃微面元的<strong>菲涅耳反射</strong>系数，他可以告诉我们每个活跃的微面元会把多少入射光线反射到观察方向上，即表示了反射光线占入射光线的比率；</li>
<li>分母则是用于校正从微面元的局部空间到整体宏观表面数量差异的校正因子；</li>
</ul>
<h3 id="18-2-Unity5的Standard-Shader"><a href="#18-2-Unity5的Standard-Shader" class="headerlink" title="18.2 Unity5的Standard Shader"></a>18.2 Unity5的Standard Shader</h3><p>Unity使用的默认着色器Standard Shader就使用了PBR；</p>
<p>Unity支持两种流行的基于物理的工作流程：<strong>金属工作流和高光反射工作流</strong>；其中金属工作流是默认的工作流程，对应的Shader为Standard Shader；如果想要使用高光反射工作流，就要选择Standard(Specular setup)</p>
<h4 id="18-2-2-如何使用Standard-Shader"><a href="#18-2-2-如何使用Standard-Shader" class="headerlink" title="18.2.2 如何使用Standard Shader"></a>18.2.2 如何使用Standard Shader</h4><p>材质和光的交互可以分成漫反射和高光反射两个部分，其中漫反射对应了次表面散射的结果，而高光反射则对应了表面反射的结果；通过对金属材质和非金属材质的分析，我们可以得到他们的漫反射和高光反射的一些特点：</p>
<ol>
<li>金属材质<ul>
<li>几乎没有漫反射，因为所有被吸收的光都会被自由电子立刻转化为其他形式的能量；</li>
<li>有非常强烈的高光反射；</li>
<li>高光反射通常是有颜色的，例如金子的反光颜色为黄色；</li>
</ul>
</li>
<li>非金属材质<ul>
<li>大多数角度高光反射的强度比较弱，但在掠射角时高光反射强度反而会增强，即菲涅耳现象；</li>
<li>高光反射的颜色比较单一；</li>
<li>漫反射的颜色多种多样；</li>
</ul>
</li>
</ol>
<p>但真实的材质大多混合了上面的这些特性；</p>
<p>若在Unity中实现，首先在Edit-Project Settings-Player-Other Settings-Color Space中选择Linear，因为PBR需要使用线性空间进行相关计算；</p>
<p>在金属工作流中，材质面板中的<strong>Albedo</strong>定义了物体的整体颜色，可以使用纹理来作为Albedo值；<strong>Metallic</strong>定义了该物体表面看起来是否更像金属或非金属，同样可以使用纹理采样得到表面的Metallic，此时纹理中的R通道值对应了Metallic值；<strong>Smoothness</strong>是Metallic的附属值，定义了从视觉上来看该表面的光滑程度，若Metallic是纹理，其A通道就对应了该值(此时纹理的GB通道则被忽略)；</p>
<p>高光反射工作流中，<strong>Albedo</strong>定义了表面的漫反射强度，对于非金属材质，通常定义为视觉上的颜色，对于金属材质常定义为黑色（金属材质几乎不存在次表面反射）；<strong>Specular</strong>定义了表面的高光反射强度，非金属材质通常使用一个灰度值在0~55的深灰色来作为Specular值，表明非金属材质的高光反射较弱，金属材质则通常使用视觉上的颜色定义该值；<strong>Smoothness</strong>定义了视觉上来看该表面的光滑程度，和金属工作流类似，若使用纹理给Specular，那么RGB通道对应Specular，A通道对应Smoothness；</p>
<p>除了上述属性，我们还可以设置四种渲染模式：</p>
<ul>
<li>Opaque用于渲染最常见的不透明物体；</li>
<li>Transparent模式适合玻璃这样的材质，此模式下Albedo的A通道控制透明度；</li>
<li>Cutout模式下，Albedo中的A通道会成为一个掩码问哪里，其子属性Alpha Cutoff将是透明度测试中的阈值；</li>
<li>Fade模式和Transparent模式类似，不过Transparent当透明值降低时，反射依然保留，但是Fade下所有渲染效果都会淡出；</li>
</ul>
<h3 id="18-3-一个更加复杂的例子"><a href="#18-3-一个更加复杂的例子" class="headerlink" title="18.3 一个更加复杂的例子"></a>18.3 一个更加复杂的例子</h3><h4 id="18-3-1-设置光照环境"><a href="#18-3-1-设置光照环境" class="headerlink" title="18.3.1 设置光照环境"></a>18.3.1 设置光照环境</h4><p>设置天空盒；</p>
<p>设置环境光照；默认反射源是场景使用的Skybox，如果不想让场景接受默认的反射光照，可以把反射源设置为Custom然后空着Cubemap即可(也可以直接空着天空盒)；</p>
<p>Unity中还有实时全局光照流水线即GI，此时场景中的物体不仅可以受直接光照的影响，还可以接受间接光照的影响，这些间接光照会受反弹光的表面的颜色影响，这些表面会在反弹光线时把自身表面的颜色添加到反射光的计算中；</p>
<p>设置直接光照，同时Unity5中直接光照会产生间接光照；</p>
<h4 id="18-3-2-放置反射探针"><a href="#18-3-2-放置反射探针" class="headerlink" title="18.3.2 放置反射探针"></a>18.3.2 放置反射探针</h4><p>反射探针允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上；当游戏中包含反射效果的物体从这些探针附近经过时，Unity会把从这些临近探针存储的反射结果传递给物体使用的反射纹理；如果物体周围存在多个反射探针，Unity还会在这些反射结果之间进行插值来得到平滑渐变的反射效果；</p>
<p>反射探针有三种类型：</p>
<ul>
<li>Bake，这类反射探针通过提前烘焙来得到该位置使用的Cubemap的，在游戏运行时反射探针中存储的Cubemap并不会发生变化；这种类型的反射探针在烘焙时也只会处理静态物体；</li>
<li>Realtime，这种类型会实时更新当前的Cubemap，并且不受静态物体还是动态物体的限制；但是这种类型需要更多的处理时间；不过Unity允许我们在脚本中控制反射探针的更新；</li>
<li>Custom，这种类型既可以让我们从编辑器中烘焙他，也可以使用自定义的Cubemap来作为反射映射，但自定义的Cubemap不会被实时更新；</li>
</ul>
<p>反射探针应该被放置在那些明显具有反射现象的物体旁边，或是一些墙角等容易发生遮挡的物体周围；</p>
<p>使用反射探针的另一个好处是可以模拟<strong>互相反射</strong>，传统的Cubemap无法做到；</p>
<h4 id="18-3-4-线性空间"><a href="#18-3-4-线性空间" class="headerlink" title="18.3.4 线性空间"></a>18.3.4 线性空间</h4><p>使用线性空间可以得到更加真实的效果，但他的缺点在于，需要一些硬件支持来实现线性计算，一些移动平台则并不支持，此时只能使用伽马空间进行渲染和计算；</p>
<p>在默认的伽马空间计算时，由于使用了非线性的输入数据，导致许多计算都是在非线性空间下进行的，这意味着我们得到的结果并不符合真实的物理期望；除此之外，由于输出时没有考虑显示器的显示伽马的影响，会导致渲染出来的画面整体偏暗，和真实世界不像；</p>
<h3 id="18-4-答疑解惑"><a href="#18-4-答疑解惑" class="headerlink" title="18.4 答疑解惑"></a>18.4 答疑解惑</h3><h4 id="18-4-1-什么是全局光照"><a href="#18-4-1-什么是全局光照" class="headerlink" title="18.4.1 什么是全局光照"></a>18.4.1 什么是全局光照</h4><p>Unity使用了实时+预计算的方法来模拟场景中的光照；其中实时光照用于计算那些直接光源对场景的影响，当物体移动时，光照也会随之发生变化，蛋实时光照无法模拟光线被多次反射的效果；</p>
<p>预计算光照包含了<strong>光照烘焙</strong>，将光源对静态物体的光照效果烘焙到一张光照纹理中，然后直接贴在物体表面来得到光照效果，这些纹理存储了反射得到的间接光照和直接光照；</p>
<p>静态的光照烘焙无法在光照条件改变时更新物体的光照效果，因此Unity使用了<strong>预计算实时全局光照</strong>，使用这种技术我们可以让场景中的物体包含丰富的全局光照效果，例如多次反射等，并且这些计算都是实时的，可以随着光源和物体的移动而发生变化；</p>
<p>该技术利用了一个事实——一旦物体和光源的位置被固定了，这些物体对光线的反弹路径以及漫反射光照也是固定的，也就是说是和摄像机无关的；因此我们通过预计算把这些物体之间的关系提前计算出来，这些信息在运行时就一直有效，不需要实时更新；在预计算阶段，Enlighten会在由所有静态物体组成的场景上，进行简化的“光线追踪”过程，这个过程中Enlighten会自动把场景分割成很多子系统，它并不是为了得到精确的光照效果，而是为了得到场景中物体之间的关系；</p>
<p>不过这些预计算都是在静态物体上进行的，因此为了使用上述的预计算方法，我们至少需要把场景中的一个物体标识为static；</p>
<h4 id="18-4-2-什么是伽马校正"><a href="#18-4-2-什么是伽马校正" class="headerlink" title="18.4.2 什么是伽马校正"></a>18.4.2 什么是伽马校正</h4><p>要把伽马空间转换到线性空间，需要进行伽马校正；</p>
<p>伽马校正中的伽马一词来自伽马曲线，通常伽马曲线的表达式如下：<br>$$<br>L_{out}&#x3D;L_{in}^γ<br>$$<br>伽马指的即指数部分；</p>
<p>使用伽马空间是因为我们图像的存储空间不足，不能储存更多的亮度信息；</p>
<h4 id="18-4-3-什么是HDR"><a href="#18-4-3-什么是HDR" class="headerlink" title="18.4.3 什么是HDR"></a>18.4.3 什么是HDR</h4><p>HDR是High Dynamic Range的缩写，即高动态范围，与之相对的是低动态范围LDR；这个动态范围指的是最高和最低的亮度值之间的比值；在真实世界中，太阳发出的光可能比场景中某个影子上点的亮度高出几万倍，而显示设备使用的颜色缓冲中每个通道仅有8位的精度，意味着我们只有256种不同的亮度；</p>
<p>而HDR使用远高于8位的精度来记录亮度信息，从而更加精确的反映真实的环境；尽管我们最后还是需要把信息转换到显示设备使用的LDR内，但中间的计算却可以让我们得到更加真实的效果；</p>
<p>HDR进行渲染的动机：让亮的物体可以真的非常亮，暗的物体可以真的非常暗，同时又可以看到两者之间的细节；</p>
<p>使用HDR来存储的图像被称为高动态范围图像(HDRI)，用这种图像作为Skybox可以更加真实的反映物体周围的环境，从而得到更加真实的反射效果；</p>
<p>同时HDR对光照叠加有重要作用，如果光照叠加到亮度超过1，没有HDR就会截取到1，会丢失一些亮部的细节；在最后转换到LDR显示时，我们可以使用<strong>色调映射技术</strong>来控制转换过程来最大限度保留亮度细节；</p>
<p>总之HDR可以让我们不会丢失高亮度区域的颜色值，提供了更真实的光照效果；</p>
<p>但HDR使用了浮点缓冲来存储高精度图像，需要更大的显存，渲染速度变慢，而且一些硬件不支持；而且一旦使用了HDR，我们无法利用硬件的抗锯齿，不过我们可以使用屏幕后处理的抗锯齿；</p>
<p>在Unity中，我们可以在Camera组件中打开HDR即可；此时场景就会被渲染到一个HDR的图像缓冲中，这个缓冲的精度范围可以远超过0~1；最后，我们可以再使用一个色调映射的屏幕后处理脚本来把HDR图像转换到LDR图像进行显示；</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://example.com">HeptagramV</a></p><p> <span>Link:  </span><a href="http://example.com/2022/04/29/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E5%AD%A6%E4%B9%A0/">http://example.com/2022/04/29/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E5%AD%A6%E4%B9%A0/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2022/06/07/I-JUST-WANT-TO-SLEEP/" title="I JUST WANT TO SLEEP"><span>< PreviousPost</span><br><span class="prevTitle">I JUST WANT TO SLEEP</span></a><a class="nextSlogan" href="/2022/04/27/HDRP%E5%AD%A6%E4%B9%A0/" title="HDRP学习"><span>NextPost ></span><br><span class="nextTitle">HDRP学习</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">Shader入门精要</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.1.</span> <span class="toc-text">第二章 渲染流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">2.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-CPU%E5%92%8CGPU%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.2 CPU和GPU之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-GPU%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.3 GPU流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A%E5%8F%8A%E6%9C%AC%E7%AB%A0%E8%A7%A3%E6%83%91"><span class="toc-number">1.1.4.</span> <span class="toc-text">2.4 术语解释及本章解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E4%BB%80%E4%B9%88%E6%98%AFOpenGL-x2F-DirectX"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">2.4.1 什么是OpenGL&#x2F;DirectX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E4%BB%80%E4%B9%88%E6%98%AFHLSL%E3%80%81GLSL%E3%80%81Cg"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2.4.2 什么是HLSL、GLSL、Cg</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E4%BB%80%E4%B9%88%E6%98%AFDraw-Call"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">2.4.3 什么是Draw Call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%AE%A1%E7%BA%BF%E6%B8%B2%E6%9F%93"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">2.4.4 什么是固定管线渲染</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Shader"><span class="toc-number">1.1.5.</span> <span class="toc-text">2.5 Shader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Unity-Shader%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">第三章 Unity Shader基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ShaderLab"><span class="toc-number">1.2.1.</span> <span class="toc-text">3.2 ShaderLab</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-Properties"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">3.3.2 Properties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-SubShader"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">3.3.3 SubShader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">3.4.1 表面着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E9%A1%B6%E7%82%B9-x2F-%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">3.4.2 顶点&#x2F;片元着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-%E5%BD%A2%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">3.4.4 形式的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E5%AD%A6"><span class="toc-number">1.3.</span> <span class="toc-text">第四章 数学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%80%E5%A7%8BUnity-Shader"><span class="toc-number">1.4.</span> <span class="toc-text">第五章 开始Unity Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B6%E7%82%B9-x2F-%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">5.2 一个最简单的顶点&#x2F;片元着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Unity%E6%8F%90%E4%BE%9B%E7%9A%84%E5%86%85%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">5.3 Unity提供的内置文件和变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Unity%E6%8F%90%E4%BE%9B%E7%9A%84Cg-x2F-HLSL%E8%AF%AD%E4%B9%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">5.4 Unity提供的Cg&#x2F;HLSL语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-Unity%E6%94%AF%E6%8C%81%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">5.4.2 Unity支持的语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">5.4.3 语义与变量类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-Debug"><span class="toc-number">1.4.4.</span> <span class="toc-text">5.5 Debug</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1%E4%BD%BF%E7%94%A8%E5%81%87%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">5.5.1使用假彩色图像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-Graphics-Debugger"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">5.5.2 Graphics Debugger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-3-%E5%B8%A7%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">5.5.3 帧调试器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%B8%B2%E6%9F%93%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.4.5.</span> <span class="toc-text">5.6 渲染平台的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-1-%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86%E7%9A%84%E5%9D%90%E6%A0%87%E5%B7%AE%E5%BC%82"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">5.6.1 渲染纹理的坐标差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-2-Shader%E7%9A%84%E8%AF%AD%E6%B3%95%E5%B7%AE%E5%BC%82"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">5.6.2 Shader的语法差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-Shader%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93"><span class="toc-number">1.4.6.</span> <span class="toc-text">5.7 Shader整洁之道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-1-%E5%8F%98%E9%87%8F%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">5.7.1 变量精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-%E8%A7%84%E8%8C%83%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">5.7.2 规范语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-3-%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">5.7.3 避免不必要的运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-4-%E6%85%8E%E7%94%A8%E5%88%86%E6%94%AF%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">5.7.4 慎用分支和循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-5-%E4%B8%8D%E8%A6%81%E9%99%A4%E4%BB%A50"><span class="toc-number">1.4.6.5.</span> <span class="toc-text">5.7.5 不要除以0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-Unity%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7"><span class="toc-number">1.5.</span> <span class="toc-text">第六章 Unity中的基础光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%A0%87%E5%87%86%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">6.2 标准光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E7%8E%AF%E5%A2%83%E5%85%89"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">6.2.1 环境光</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E8%87%AA%E5%8F%91%E5%85%89"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">6.2.2 自发光</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E6%BC%AB%E5%8F%8D%E5%B0%84"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">6.2.3 漫反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B0%E4%BC%AF%E7%89%B9%E5%AE%9A%E5%BE%8B"><span class="toc-number">1.5.1.3.1.</span> <span class="toc-text">兰伯特定律</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">6.2.4 高光反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-%E9%80%90%E5%83%8F%E7%B4%A0%E8%BF%98%E6%98%AF%E9%80%90%E9%A1%B6%E7%82%B9"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">6.2.5 逐像素还是逐顶点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Unity%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%85%89%E5%92%8C%E8%87%AA%E5%8F%91%E5%85%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">6.3 Unity中的环境光和自发光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%AE%9E%E7%8E%B0%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">6.4 实现漫反射光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E9%80%90%E9%A1%B6%E7%82%B9%E5%85%89%E7%85%A7"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">6.4.1 逐顶点光照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E7%85%A7"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">6.4.2 逐像素光照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-%E5%8D%8A%E5%85%B0%E4%BC%AF%E7%89%B9%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">6.4.3 半兰伯特模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.4.</span> <span class="toc-text">6.5 实现高光反射光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1-%E9%80%90%E9%A1%B6%E7%82%B9%E5%85%89%E7%85%A7"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">6.5.1 逐顶点光照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2-%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E7%85%A7"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">6.5.2 逐像素光照</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-Unity%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.5.</span> <span class="toc-text">6.6 Unity内置函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">第七章 基础纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8D%95%E5%BC%A0%E7%BA%B9%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">7.1 单张纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">7.1.1 实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E7%BA%B9%E7%90%86%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">7.1.2 纹理的属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%87%B9%E5%87%B8%E6%98%A0%E5%B0%84"><span class="toc-number">1.7.</span> <span class="toc-text">7.2 凹凸映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E9%AB%98%E5%BA%A6%E7%BA%B9%E7%90%86"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.2.1  高度纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2.2 法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E4%B8%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">在切线空间下计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E4%B8%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">在世界空间下计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%B8%90%E5%8F%98%E7%BA%B9%E7%90%86"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 渐变纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E9%81%AE%E7%BD%A9%E7%BA%B9%E7%90%86"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 遮罩纹理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">1.8.</span> <span class="toc-text">第八章 透明效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 渲染顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Unity-Shader%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 Unity Shader的渲染顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 透明度测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 透明度混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E5%86%99%E5%85%A5%E7%9A%84%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 开启深度写入的半透明效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-ShaderLab%E7%9A%84%E6%B7%B7%E5%90%88%E5%91%BD%E4%BB%A4"><span class="toc-number">1.8.6.</span> <span class="toc-text">8.6 ShaderLab的混合命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1-%E6%B7%B7%E5%90%88%E7%AD%89%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">8.6.1 混合等式和参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-2-%E6%B7%B7%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">8.6.2 混合操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-3-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.6.3.</span> <span class="toc-text">8.6.3 常见的混合类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">1.8.7.</span> <span class="toc-text">8.7 双面渲染的透明效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7"><span class="toc-number">1.9.</span> <span class="toc-text">第九章 更复杂的光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-Unity%E7%9A%84%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1 Unity的渲染路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">9.1.1 前向渲染路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-%E9%A1%B6%E7%82%B9%E7%85%A7%E6%98%8E%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">9.1.2 顶点照明渲染路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">1.9.1.3.</span> <span class="toc-text">9.1.3 延迟渲染路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.9.1.4.</span> <span class="toc-text">9.1.4 渲染路径的选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Unity%E7%9A%84%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2 Unity的光源类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">9.2.1 光源类型有什么影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E5%9C%A8%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E4%B8%AD%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">9.2.2 在前向渲染中处理不同的光源类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-Unity%E7%9A%84%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3 Unity的光照衰减</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E7%94%A8%E4%BA%8E%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F%E7%9A%84%E7%BA%B9%E7%90%86"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">9.3.1 用于光照衰减的纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%A1%B0%E5%87%8F"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">9.3.2 使用数学公式计算衰减</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Unity%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4 Unity的阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-%E9%98%B4%E5%BD%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">9.4.1 阴影是如何实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">9.4.2 不透明物体的阴影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-4-%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">9.4.4 统一管理光照衰减和阴影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-5-%E9%80%8F%E6%98%8E%E5%BA%A6%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">1.9.4.4.</span> <span class="toc-text">9.4.5 透明度物体的阴影</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E6%A0%87%E5%87%86Unity-Shader"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5 标准Unity Shader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86"><span class="toc-number">1.10.</span> <span class="toc-text">第十章 高级纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E7%AB%8B%E6%96%B9%E4%BD%93%E7%BA%B9%E7%90%86"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1 立方体纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-%E5%A4%A9%E7%A9%BA%E7%9B%92%E5%AD%90"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">10.1.1 天空盒子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-%E5%88%9B%E5%BB%BA%E7%94%A8%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84%E7%9A%84%E7%AB%8B%E6%96%B9%E4%BD%93%E7%BA%B9%E7%90%86"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">10.1.2 创建用于环境映射的立方体纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-%E5%8F%8D%E5%B0%84"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">10.1.3 反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-4-%E6%8A%98%E5%B0%84"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">10.1.4 折射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-5-%E8%8F%B2%E6%B6%85%E8%80%B3%E5%8F%8D%E5%B0%84"><span class="toc-number">1.10.1.5.</span> <span class="toc-text">10.1.5 菲涅耳反射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2 渲染纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-%E9%95%9C%E5%AD%90%E6%95%88%E6%9E%9C"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">10.2.1 镜子效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">10.2.2 玻璃效果*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-3-%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86-vs-GrabPass"><span class="toc-number">1.10.2.3.</span> <span class="toc-text">10.2.3 渲染纹理 vs GrabPass</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E7%A8%8B%E5%BA%8F%E7%BA%B9%E7%90%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">10.3 程序纹理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E8%AE%A9%E7%94%BB%E9%9D%A2%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="toc-number">1.11.</span> <span class="toc-text">第十一章 让画面动起来</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">11.1 关于时间的内置变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB"><span class="toc-number">1.11.2.</span> <span class="toc-text">11.2 纹理动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">11.2.1 序列帧动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2-%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">11.2.2 滚动的背景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB"><span class="toc-number">1.11.3.</span> <span class="toc-text">11.3 顶点动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-%E6%B5%81%E5%8A%A8%E7%9A%84%E6%B2%B3%E6%B5%81"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">11.3.1 流动的河流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-%E5%B9%BF%E5%91%8A%E7%89%8C"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">11.3.2 广告牌</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-3-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">11.3.3 注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86%E6%95%88%E6%9E%9C"><span class="toc-number">1.12.</span> <span class="toc-text">第十二章 屏幕后处理效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B1%8F%E5%B9%95%E5%90%8E%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.12.1.</span> <span class="toc-text">12.1 建立一个基本的屏幕后处理脚本系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E8%B0%83%E6%95%B4%E5%B1%8F%E5%B9%95%E7%9A%84%E4%BA%AE%E5%BA%A6%E3%80%81%E9%A5%B1%E5%92%8C%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6"><span class="toc-number">1.12.2.</span> <span class="toc-text">12.2 调整屏幕的亮度、饱和度和对比度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">1.12.3.</span> <span class="toc-text">12.3 边缘检测</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%B7%E7%A7%AF"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">12.3.1 什么是卷积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E7%AE%97%E5%AD%90"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">12.3.2 边缘检测算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-3-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.3.3.</span> <span class="toc-text">12.3.3 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A"><span class="toc-number">1.12.4.</span> <span class="toc-text">12.4 高斯模糊</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">12.4.1 高斯滤波</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.12.4.2.</span> <span class="toc-text">12.4.2 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-Bloom%E6%95%88%E6%9E%9C"><span class="toc-number">1.12.5.</span> <span class="toc-text">12.5 Bloom效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A"><span class="toc-number">1.12.6.</span> <span class="toc-text">12.6 运动模糊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">1.12.7.</span> <span class="toc-text">12.7 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">1.13.</span> <span class="toc-text">第十三章 使用深度和法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%BA%A6%E5%92%8C%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86"><span class="toc-number">1.13.1.</span> <span class="toc-text">13.1 获取深度和法线纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1-%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.13.1.1.</span> <span class="toc-text">13.1.1 背后的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96"><span class="toc-number">1.13.1.2.</span> <span class="toc-text">13.1.2 如何获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3-%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E6%95%88%E6%9E%9C"><span class="toc-number">1.13.1.3.</span> <span class="toc-text">13.1.3 实现扫描效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E5%86%8D%E8%B0%88%E8%BF%90%E5%8A%A8%E6%A8%A1%E7%B3%8A"><span class="toc-number">1.13.2.</span> <span class="toc-text">13.2 再谈运动模糊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E5%85%A8%E5%B1%80%E9%9B%BE%E6%95%88"><span class="toc-number">1.13.3.</span> <span class="toc-text">13.3 全局雾效*</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1-%E9%87%8D%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">13.3.1 重建世界坐标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-2-%E9%9B%BE%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">13.3.2 雾的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-3-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.13.3.3.</span> <span class="toc-text">13.3.3 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E5%86%8D%E8%B0%88%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">1.13.4.</span> <span class="toc-text">13.4 再谈边缘检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%9D%9E%E7%9C%9F%E5%AE%9E%E6%84%9F%E6%B8%B2%E6%9F%93"><span class="toc-number">1.14.</span> <span class="toc-text">第十四章 非真实感渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E5%8D%A1%E9%80%9A%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-number">1.14.1.</span> <span class="toc-text">14.1 卡通风格的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-1-%E6%B8%B2%E6%9F%93%E8%BD%AE%E5%BB%93%E7%BA%BF"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">14.1.1 渲染轮廓线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-2-%E6%B7%BB%E5%8A%A0%E9%AB%98%E5%85%89"><span class="toc-number">1.14.1.2.</span> <span class="toc-text">14.1.2 添加高光</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-3-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.14.1.3.</span> <span class="toc-text">14.1.3 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E7%B4%A0%E6%8F%8F%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-number">1.14.2.</span> <span class="toc-text">14.2 素描风格的渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">1.14.3.</span> <span class="toc-text">14.3 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E4%BD%BF%E7%94%A8%E5%99%AA%E5%A3%B0"><span class="toc-number">1.15.</span> <span class="toc-text">第十五章 使用噪声</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E6%B6%88%E8%9E%8D%E6%95%88%E6%9E%9C"><span class="toc-number">1.15.1.</span> <span class="toc-text">15.1 消融效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E6%B0%B4%E6%B3%A2%E6%95%88%E6%9E%9C"><span class="toc-number">1.15.2.</span> <span class="toc-text">15.2 水波效果*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E5%86%8D%E8%B0%88%E5%85%A8%E5%B1%80%E9%9B%BE%E6%95%88"><span class="toc-number">1.15.3.</span> <span class="toc-text">15.3 再谈全局雾效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-Unity%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">1.16.</span> <span class="toc-text">第十六章 Unity中的渲染优化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.16.1.</span> <span class="toc-text">16.1 移动平台的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.16.2.</span> <span class="toc-text">16.2 影响性能的因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-Unity%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">1.16.3.</span> <span class="toc-text">16.3 Unity中的渲染分析工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-%E5%87%8F%E5%B0%91draw-call%E6%95%B0%E7%9B%AE"><span class="toc-number">1.16.4.</span> <span class="toc-text">16.4 减少draw call数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-1-%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.16.4.1.</span> <span class="toc-text">16.4.1 动态批处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-2-%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">1.16.4.2.</span> <span class="toc-text">16.4.2 静态批处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-3-%E5%85%B1%E4%BA%AB%E6%9D%90%E8%B4%A8"><span class="toc-number">1.16.4.3.</span> <span class="toc-text">16.4.3 共享材质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-4-%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.16.4.4.</span> <span class="toc-text">16.4.4 批处理的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-%E5%87%8F%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E9%A1%B6%E7%82%B9%E6%95%B0%E7%9B%AE"><span class="toc-number">1.16.5.</span> <span class="toc-text">16.5 减少需要处理的顶点数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-1-%E4%BC%98%E5%8C%96%E5%87%A0%E4%BD%95%E4%BD%93"><span class="toc-number">1.16.5.1.</span> <span class="toc-text">16.5.1 优化几何体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-2-%E6%A8%A1%E5%9E%8B%E7%9A%84LOD%E6%8A%80%E6%9C%AF"><span class="toc-number">1.16.5.2.</span> <span class="toc-text">16.5.2 模型的LOD技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-3-%E9%81%AE%E6%8C%A1%E5%89%94%E9%99%A4%E6%8A%80%E6%9C%AF"><span class="toc-number">1.16.5.3.</span> <span class="toc-text">16.5.3 遮挡剔除技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-%E5%87%8F%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E7%9A%84%E7%89%87%E5%85%83%E6%95%B0%E7%9B%AE"><span class="toc-number">1.16.6.</span> <span class="toc-text">16.6 减少需要处理的片元数目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-6-1-%E6%8E%A7%E5%88%B6%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.16.6.1.</span> <span class="toc-text">16.6.1 控制绘制顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-6-2-%E6%97%B6%E5%88%BB%E8%AD%A6%E6%83%95%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93"><span class="toc-number">1.16.6.2.</span> <span class="toc-text">16.6.2 时刻警惕透明物体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-6-3-%E5%87%8F%E5%B0%91%E5%AE%9E%E6%97%B6%E5%85%89%E7%85%A7%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="toc-number">1.16.6.3.</span> <span class="toc-text">16.6.3 减少实时光照和阴影</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-%E8%8A%82%E7%9C%81%E5%B8%A6%E5%AE%BD"><span class="toc-number">1.16.7.</span> <span class="toc-text">16.7 节省带宽</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-7-1-%E5%87%8F%E5%B0%91%E7%BA%B9%E7%90%86%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.16.7.1.</span> <span class="toc-text">16.7.1 减少纹理大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-7-2-%E5%88%A9%E7%94%A8%E5%88%86%E8%BE%A8%E7%8E%87%E7%BC%A9%E6%94%BE"><span class="toc-number">1.16.7.2.</span> <span class="toc-text">16.7.2 利用分辨率缩放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-8-%E5%87%8F%E5%B0%91%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.16.8.</span> <span class="toc-text">16.8 减少计算复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-1-Shader%E7%9A%84LOD%E6%8A%80%E6%9C%AF"><span class="toc-number">1.16.8.1.</span> <span class="toc-text">16.8.1 Shader的LOD技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-8-2-%E4%BB%A3%E7%A0%81%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.16.8.2.</span> <span class="toc-text">16.8.2 代码方面的优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-Unity%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.17.</span> <span class="toc-text">第十七章 Unity的表面着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E7%89%A9%E7%90%86%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-number">1.18.</span> <span class="toc-text">第十八章 基于物理的渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-1-PBS%E7%9A%84%E7%90%86%E8%AE%BA%E5%92%8C%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">1.18.1.</span> <span class="toc-text">18.1 PBS的理论和数学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-1-%E5%85%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.18.1.1.</span> <span class="toc-text">18.1.1 光是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-2-%E5%8F%8C%E5%90%91%E5%8F%8D%E5%B0%84%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0-BRDF"><span class="toc-number">1.18.1.2.</span> <span class="toc-text">18.1.2 双向反射分布函数(BRDF)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-3-%E6%BC%AB%E5%8F%8D%E5%B0%84%E9%A1%B9"><span class="toc-number">1.18.1.3.</span> <span class="toc-text">18.1.3 漫反射项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-4-%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E9%A1%B9"><span class="toc-number">1.18.1.4.</span> <span class="toc-text">18.1.4 高光反射项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-Unity5%E7%9A%84Standard-Shader"><span class="toc-number">1.18.2.</span> <span class="toc-text">18.2 Unity5的Standard Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-2-2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Standard-Shader"><span class="toc-number">1.18.2.1.</span> <span class="toc-text">18.2.2 如何使用Standard Shader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-3-%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E5%A4%8D%E6%9D%82%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.18.3.</span> <span class="toc-text">18.3 一个更加复杂的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-3-1-%E8%AE%BE%E7%BD%AE%E5%85%89%E7%85%A7%E7%8E%AF%E5%A2%83"><span class="toc-number">1.18.3.1.</span> <span class="toc-text">18.3.1 设置光照环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-3-2-%E6%94%BE%E7%BD%AE%E5%8F%8D%E5%B0%84%E6%8E%A2%E9%92%88"><span class="toc-number">1.18.3.2.</span> <span class="toc-text">18.3.2 放置反射探针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-3-4-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4"><span class="toc-number">1.18.3.3.</span> <span class="toc-text">18.3.4 线性空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-%E7%AD%94%E7%96%91%E8%A7%A3%E6%83%91"><span class="toc-number">1.18.4.</span> <span class="toc-text">18.4 答疑解惑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7"><span class="toc-number">1.18.4.1.</span> <span class="toc-text">18.4.1 什么是全局光照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-4-2-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%BD%E9%A9%AC%E6%A0%A1%E6%AD%A3"><span class="toc-number">1.18.4.2.</span> <span class="toc-text">18.4.2 什么是伽马校正</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-4-3-%E4%BB%80%E4%B9%88%E6%98%AFHDR"><span class="toc-number">1.18.4.3.</span> <span class="toc-text">18.4.3 什么是HDR</span></a></li></ol></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>