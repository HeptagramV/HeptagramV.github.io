<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="HeptagramV"><meta name="renderer" content="webkit"><meta name="copyright" content="HeptagramV"><meta name="keywords" content="七酱的布洛克"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>虚拟线上会议室 · HeptagramV's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/web.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/headpic.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">七酱</div><div class="profile-signature">姑且算个游戏开发人</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">HeptagramV's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">虚拟线上会议室</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2022-08-30</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="项目"> 项目</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="虚拟线上会议室"><a href="#虚拟线上会议室" class="headerlink" title="虚拟线上会议室"></a>虚拟线上会议室</h1><p>在喻老师的建议下独立开发的应用项目</p>
<p>使用引擎：Unity</p>
<p>开发时间：2022年8月</p>
<p>开发细节：基于mirror实现了联机的虚拟会议室(目前没有部署服务器因此只能在局域网运行)，通过声网的SDK实现了频道式的语音通话，同时完成了屏幕共享的功能，支持最多一人在会议室大屏幕共享自己的电脑桌面及相关操作；</p>
<h2 id="截图及说明："><a href="#截图及说明：" class="headerlink" title="截图及说明："></a>截图及说明：</h2><p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220830163744867.png" alt="开始选择界面"></p>
<p>该界面为连接前的Offline场景，用户可以在这里选择角色(目前没有人物建模)，修改连接的IP地址；</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220830163943614.png" alt="会议室场景"></p>
<p>该界面为连接后的会议室场景，由一个用户作为主机，其他用户连接到主机的IP地址之后即可在本场景显示自己的虚拟造型，并且可以以第一人称视角在会议室内移动；</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220830164133394.png" alt="音频连接"></p>
<p>该界面为随时可以打开的音频连接界面，不同用户只要输入相同的频道名称即可开始语音通话，通话过程中可通过最下方的静音键来闭麦；</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20220830164348708.png" alt="屏幕共享"></p>
<p>在会议室中，在当前无人共享屏幕的情况下可以开启屏幕共享，此时自己的桌面可以实时显示在房间一侧的大屏幕上，其他玩家可以靠近观看，或者<strong>按F进入全屏模式观看</strong>；</p>
<h2 id="Mirror基础："><a href="#Mirror基础：" class="headerlink" title="Mirror基础："></a>Mirror基础：</h2><p>既然需要制作实现线上功能的软件，首先需要明确通信的数据传输方式和逻辑结构：</p>
<p>本次使用的是Unity的Mirror插件，关于连接主机以及角色移动的功能，该插件已经十分清晰的进行了实现，仅需使用插件提供的组件如Network Manager、Network Identity、Network Transform等即可，因此在此不再赘述；</p>
<p>在使用Mirror插件编写线上相关代码时，需要了解不同属性下代码的调用逻辑来进行信息的同步：</p>
<h3 id="Client向server发送命令"><a href="#Client向server发送命令" class="headerlink" title="Client向server发送命令"></a>Client向server发送命令</h3><p>此时将会用到属性[Command]，被此属性标记的方法将被视为一道命令，调用时用户向服务器发出该命令，该逻辑在server上被调用，但是此时其他用户将不会受到影响，因为其他用户并没有收到该命令，也就没有和sever同步，因此在[Command]修饰的方法中，我们通常会调用另一个由[ClientRPC]属性修饰的方法；</p>
<h3 id="Server向所有Client发送命令"><a href="#Server向所有Client发送命令" class="headerlink" title="Server向所有Client发送命令"></a>Server向所有Client发送命令</h3><p>被[ClientRPC]修饰的方法将在服务器上被调用，此时所有用户的客户端上都会执行该方法，以此达到同步的效果；</p>
<h3 id="Server向特定Client发送命令"><a href="#Server向特定Client发送命令" class="headerlink" title="Server向特定Client发送命令"></a>Server向特定Client发送命令</h3><p>在实际应用中，我们往往需要指定接收信息的客户端，比如FPS中击中了某个玩家，此时不能向全体客户端发送命令，因此需要用到[TargetRPC]属性，该方法至少需要有一个NetworkConnection的形参，来确定指向哪个用户的客户端</p>
<p>此外还有着<strong>值同步SyncVal</strong>以及权限方面的一些问题，不过本次并没有使用到相关内容，因此不予展开；</p>
<h2 id="屏幕共享功能的实现"><a href="#屏幕共享功能的实现" class="headerlink" title="屏幕共享功能的实现"></a>屏幕共享功能的实现</h2><p>本例中比较需要讲解的部分即屏幕共享的实现，如果要实现一人共享，全员可见，需要将屏幕内容信息传递到服务器，再由服务器传递到所有客户端，因此使用上文提到的[Command]和[ClientRPC]修饰的方法即可；</p>
<p>但是在Mirror中，可以传递的参数类型比较有限，只能传输一些基本类型如int,float或者transform,vector3等，而屏幕信息往往由二维纹理存储，在开发过程中我尝试了Render Texture，Texture2D和Sprite类型，其中Mirror报错显示Render Texture无法直接传递，因为信息在传输之前将进行一个序列化的过程，将其处理成string或其他类型，在传递之后又将进行一个反序列化的过程，如果是自定义的类型，可以手动实现每个参数的序列化和反序列化，但由于个人能力有限，无法将一个Unity定义的纹理信息类手动序列化，因此无法实现；</p>
<p>而Texture2D和Sprite在传输过程中会出现问题，在反序列化操作之后会丢失部分信息，导致其他客户端无法正常使用；</p>
<p>此时我发现可以将Texture2D类型的信息转化成字节数组，使用unity自带的函数Texture2D.EncodeToJPG()即可实现，此时我们可以传递字节数组，再在客户端的回调上使用Texture2D.LoadImage(byte[])函数即可重新得到Texture2D，之后将其渲染到我们指定的Plane物体上即可；</p>
<p>但是此时我发现了新的问题，由于我们传递的是基于Texture2D的图像信息，而我们需要实现的是屏幕共享，因此我们需要在每帧都传输图片，当我测试时我发现在第二帧开始之后，图片不再更新而且编辑器出现报错，经查证，我得知一个Texture2D对象无法反复LoadImage，当他调用过一次之后再次进行便会报错，因此我们需要一个新的Texture2D对象来存储，这样就造成了一个严重的问题：<strong>我需要在每帧都new一个Texture2D对象</strong>，由于Unity没有相应的回收机制，这样的话共享一分钟之后各位的电脑就会内存溢出，不过这很好解决，我只要在每帧结束的时候Destroy该对象即可；</p>
<p>但是当我测试时，我发现画面变成了全黑(废话)，此时我陷入了短暂的迷茫：如果不Destroy，内存会溢出；如果Destroy，则无法显示画面，事情似乎陷入了一个死循环，不过我灵机一动，想出了如下的方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcShare</span>(<span class="params"><span class="built_in">byte</span>[] t2d</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       GameObject turn = GameObject.Find(<span class="string">&quot;Turn&quot;</span>);</span><br><span class="line">       turn.GetComponent&lt;SpriteRenderer&gt;().enabled = <span class="literal">false</span>;</span><br><span class="line">       GameObject SharePoint = GameObject.Find(<span class="string">&quot;PointShare&quot;</span>);</span><br><span class="line">       transform.position = SharePoint.transform.position;</span><br><span class="line">       transform.rotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">90</span>, <span class="number">0</span>);</span><br><span class="line">       GameObject video = GameObject.Find(<span class="string">&quot;VideoPlayer&quot;</span>);</span><br><span class="line">       video.GetComponent&lt;Renderer&gt;().enabled = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           mid1 = <span class="keyword">new</span> Texture2D(w, h, TextureFormat.RGB24, <span class="literal">false</span>);</span><br><span class="line">           mid1.LoadImage(t2d);</span><br><span class="line">           video.GetComponent&lt;Renderer&gt;().material.mainTexture = mid1;</span><br><span class="line">           Destroy(mid2);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           mid2 = <span class="keyword">new</span> Texture2D(w, h, TextureFormat.RGB24, <span class="literal">false</span>);</span><br><span class="line">           mid2.LoadImage(t2d);</span><br><span class="line">           video.GetComponent&lt;Renderer&gt;().material.mainTexture = mid2;</span><br><span class="line">           Destroy(mid1);</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= <span class="number">10</span>) i = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我定义了两个Texture2D作为公共变量，在回调中，我选择在渲染结束后，每帧Destroy上一帧new出的Texture2D，这样就保证了每帧的渲染结果不被Destroy，同时内存也永远不会溢出，当时我觉得自己真聪明）；</p>
<p>而实际上我后来发现——<strong>我只要改成每帧开始Destroy上次的渲染结果不就好了</strong></p>
<p>随即修改成了现在这个样子：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RpcShare</span>(<span class="params"><span class="built_in">byte</span>[] t2d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Destroy(mid1);</span><br><span class="line">        GameObject turn = GameObject.Find(<span class="string">&quot;Turn&quot;</span>);</span><br><span class="line">        turn.GetComponent&lt;SpriteRenderer&gt;().enabled = <span class="literal">false</span>;</span><br><span class="line">        GameObject SharePoint = GameObject.Find(<span class="string">&quot;PointShare&quot;</span>);</span><br><span class="line">        transform.position = SharePoint.transform.position;</span><br><span class="line">        transform.rotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">90</span>, <span class="number">0</span>);</span><br><span class="line">        GameObject video = GameObject.Find(<span class="string">&quot;VideoPlayer&quot;</span>);</span><br><span class="line">        video.GetComponent&lt;Renderer&gt;().enabled = <span class="literal">true</span>;</span><br><span class="line">        mid1 = <span class="keyword">new</span> Texture2D(w, h, TextureFormat.RGB24, <span class="literal">false</span>);</span><br><span class="line">        mid1.LoadImage(t2d);</span><br><span class="line">        video.GetComponent&lt;Renderer&gt;().material.mainTexture = mid1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>（感觉可以改标题为<strong>记一次脑残</strong>）</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://example.com">HeptagramV</a></p><p> <span>Link:  </span><a href="http://example.com/2022/08/30/%E8%99%9A%E6%8B%9F%E7%BA%BF%E4%B8%8A%E4%BC%9A%E8%AE%AE%E5%AE%A4/">http://example.com/2022/08/30/%E8%99%9A%E6%8B%9F%E7%BA%BF%E4%B8%8A%E4%BC%9A%E8%AE%AE%E5%AE%A4/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="nextSlogan" href="/2022/06/26/%E5%8D%B1%E9%99%A9%EF%BC%81%E5%B9%BD%E7%81%B5%E5%B0%8F%E5%A7%90/" title="危险！幽灵小姐"><span>NextPost ></span><br><span class="nextTitle">危险！幽灵小姐</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E4%B8%8A%E4%BC%9A%E8%AE%AE%E5%AE%A4"><span class="toc-number">1.</span> <span class="toc-text">虚拟线上会议室</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%AA%E5%9B%BE%E5%8F%8A%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">截图及说明：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mirror%E5%9F%BA%E7%A1%80%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">Mirror基础：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Client%E5%90%91server%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.1.</span> <span class="toc-text">Client向server发送命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server%E5%90%91%E6%89%80%E6%9C%89Client%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">Server向所有Client发送命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Server%E5%90%91%E7%89%B9%E5%AE%9AClient%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">Server向特定Client发送命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">屏幕共享功能的实现</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>