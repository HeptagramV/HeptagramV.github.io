<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="HeptagramV"><meta name="renderer" content="webkit"><meta name="copyright" content="HeptagramV"><meta name="keywords" content="七酱的布洛克"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>图形学-OpenGL学习 · HeptagramV's Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/web.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.1.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/headpic.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">HeptaV</div><div class="profile-signature">姑且算个游戏开发人</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">HeptagramV's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">图形学-OpenGL学习</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2022-10-07</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="学习"> 学习</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><h1 id="LearnOpenGL-CN"><a href="#LearnOpenGL-CN" class="headerlink" title="LearnOpenGL CN"></a>LearnOpenGL CN</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p>OpenGL一般被认为是一个API,包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由<a target="_blank" rel="noopener" href="http://www.khronos.org/">Khronos组织</a>制定并维护的规范(Specification)。</p>
<p>实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。</p>
<p>使用扩展的代码大多看上去如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(GL_ARB_extension_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用硬件支持的全新的现代特性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不支持此扩展: 用旧的方式去做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。</p>
<p>假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。</p>
<p>当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> objectId = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGenObject</span>(<span class="number">1</span>, &amp;objectId);</span><br><span class="line"><span class="comment">// 绑定对象至上下文</span></span><br><span class="line"><span class="built_in">glBindObject</span>(GL_WINDOW_TARGET, objectId);</span><br><span class="line"><span class="comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class="line"><span class="built_in">glSetObjectOption</span>(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="number">800</span>);</span><br><span class="line"><span class="built_in">glSetObjectOption</span>(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="number">600</span>);</span><br><span class="line"><span class="comment">// 将上下文对象设回默认</span></span><br><span class="line"><span class="built_in">glBindObject</span>(GL_WINDOW_TARGET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这一小段代码展现了你以后使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。</p>
<p>使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。</p>
<h4 id="GLAD"><a href="#GLAD" class="headerlink" title="GLAD"></a>GLAD</h4><p>因为OpenGL只是一个标准&#x2F;规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函<strong>数指针</strong>中供以后使用；幸运的是，有些库能简化此过程，其中<strong>GLAD</strong>是目前最新，也是最流行的库。</p>
<h4 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h4><p>OpenGL幕后使用glViewport中定义的位置和宽高进行2D坐标的转换，将OpenGL中的位置坐标转换为你的屏幕坐标。例如，OpenGL中的坐标(-0.5, 0.5)有可能（最终）被映射为屏幕中的坐标(200,450)。注意，处理过的OpenGL坐标范围只为-1到1，因此我们事实上将(-1到1)范围内的坐标映射到(0, 800)和(0, 600)。</p>
<p>然而，当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用。这个回调函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个帧缓冲大小函数需要一个GLFWwindow作为它的第一个参数，以及两个整数表示窗口的新维度。每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br></pre></td></tr></table></figure>

<p>当窗口被第一次显示的时候framebuffer_size_callback也会被调用。对于视网膜(Retina)显示屏，width和height都会明显比原输入值更高一点。</p>
<p>我们还可以将我们的函数注册到其它很多的回调函数中。比如说，我们可以创建一个回调函数来处理手柄输入变化，处理错误消息等。我们会在创建窗口之后，渲染循环初始化之前注册这些回调函数。</p>
<h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了；</p>
<h3 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h3><ul>
<li>顶点数组对象：Vertex Array Object，VAO</li>
<li>顶点缓冲对象：Vertex Buffer Object，VBO</li>
<li>元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO</li>
</ul>
<p>在现代OpenGL中，我们<strong>必须</strong>定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点&#x2F;片段着色器）。</p>
<p>定义顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p>
<p>我们通过<strong>顶点缓冲对象(Vertex Buffer Objects, VBO)<strong>管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。</strong>使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。</strong>从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;<span class="comment">//定义一个三角形所需的顶点数据</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;VBO);<span class="comment">//使用glGenBuffers函数和一个缓冲ID生成一个VBO对象</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//把新创建的缓冲绑定到GL_ARRAY_BUFFER上，现在开始在该目标上使用的任何缓冲调用都会用来配置绑定的缓冲(VBO)；</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//将用户定义的数据复制到当前绑定缓冲；</span></span><br></pre></td></tr></table></figure>

<p>glBufferData用来将用户定义的数据复制到当前绑定缓冲：</p>
<p>它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的<code>sizeof</code>计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p>
<p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p>
<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
<p>现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。下面我们会创建一个顶点着色器和片段着色器来真正处理这些数据。</p>
<h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><p>我们需要做的第一件事是用着色器语言GLSL(OpenGL Shading Language)编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core //版本声明，同时声明使用核心模式</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="comment">//使用in关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)</span></span><br><span class="line"><span class="comment">//我们创建一个vec3输入变量aPos。我们同样也通过layout (location = 0)设定了输入变量的位置值(Location),后面会看到为什么会需要这个位置值;</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">//为了设置顶点着色器的输出，把位置数据赋值给预定义的gl_Position变量</span></span><br><span class="line">    <span class="comment">//gl_Position是顶点着色器（所有版本的顶点着色器）必须计算的值，是每个顶点的最终的位置信息。这里的顶点位置信息是通过glVertexAttribPointer上传的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译着色器：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了能够让OpenGL使用它，我们必须在运行时动态编译它的源代码,暂时将顶点着色器的源代码硬编码在代码文件顶部的C风格字符串中</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"><span class="comment">//我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为unsigned int，然后用glCreateShader创建这个着色器;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vertexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);<span class="comment">//传入的参数是要创建的着色器类型</span></span><br><span class="line"><span class="comment">//把这个着色器源码附加到着色器对象上，然后编译它</span></span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);<span class="comment">//第一个参数是要编译的着色器对象；第二参数指定了传递的源码字符串数量，这里只有一个；第三个参数是顶点着色器真正的源码，第四个参数我们先设置为NULL；</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221107144642630.png" alt="image-20221107144642630"></p>
<h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"><span class="comment">//片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。声明输出变量可以使用out关键字，这里我们命名为FragColor。下面，我们将一个Alpha值为1.0(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<h4 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h4><p>两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</p>
<p><strong>着色器程序对象</strong>(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();<span class="comment">//glCreateProgram函数创建一个程序，并返回新创建程序对象的ID引用。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram, fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);<span class="comment">//将着色器附加到了程序上，然后用glLinkProgram链接</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);<span class="comment">//调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象</span></span><br><span class="line"><span class="comment">//在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<h4 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h4><p>顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。</p>
<p><strong>我们的顶点缓冲数据</strong>会被解析为下面这样子：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_attribute_pointer.png" alt="img"></p>
<ul>
<li>位置数据被储存为32位（4字节）浮点值。</li>
<li>每个位置包含3个这样的值。</li>
<li>在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。</li>
<li>数据中第一个值在缓冲开始的位置。</li>
</ul>
<p>我们将使用这些信息在glVertexAttribPointer函数中告诉OpenGL如何解析顶点数据(应用到逐个顶点属性上)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="comment">//该函数第一个参数通过位置值(location)指定要配置的顶点属性，即我们在顶点着色器中设置的layout(location = 0),因此这里传入0；</span></span><br><span class="line"><span class="comment">//第二个参数指定顶点属性大小，我们使用vec3，所以传入3；</span></span><br><span class="line"><span class="comment">//第三个参数指定数据类型，我们选择浮点型；</span></span><br><span class="line"><span class="comment">//第四个参数定义数据是否需要归一化；</span></span><br><span class="line"><span class="comment">//第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)；当数值紧密排列时也可以设置为0，由OpenGl自行决定步长；(该参数可以理解为这个属性第二次出现的地方到数组0位置之间有多少字节)；</span></span><br><span class="line"><span class="comment">//最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数；</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//以顶点属性为参数，启用顶点属性，因为顶点属性默认是禁用的；</span></span><br></pre></td></tr></table></figure>

<p><strong>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。</strong></p>
<h4 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h4><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了，<strong>设置的所有状态都将存储在VAO中</strong>。这使<strong>在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO</strong>就行了。</p>
<p><strong>OpenGL的核心模式要求我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。</strong></p>
<p>一个顶点数组对象会储存以下这些内容：</p>
<ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</li>
<li>通过glVertexAttribPointer设置的顶点属性配置。</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li>
</ul>
<p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects.png" alt="img"></p>
<p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO；从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用；当我们打算绘制一个物体的时候，我们只要在绘制前把VAO绑定到希望使用的设定上就行了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化代码(只运行一次，除非你的物体频繁改变)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);<span class="comment">//创建VAO</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">//同上文</span></span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);<span class="comment">//绑定VBO</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制代码(渲染循环中)</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);<span class="comment">//绑定VAO</span></span><br><span class="line"><span class="built_in">someOpenGLFunctionThatDrawsOurTriangle</span>();</span><br></pre></td></tr></table></figure>

<h4 id="绘制三角形"><a href="#绘制三角形" class="headerlink" title="绘制三角形"></a>绘制三角形</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填0。最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</span></span><br></pre></td></tr></table></figure>

<h4 id="元素缓冲对象"><a href="#元素缓冲对象" class="headerlink" title="元素缓冲对象"></a>元素缓冲对象</h4><p>元素缓冲对象(Element Buffer Object，EBO)，也叫索引缓冲对象(Index Buffer Object，IBO)。</p>
<p>当我们绘制图形时，顶点可能有重合，比如我们需要用两个三角形拼成一个矩形，而我们希望只储存四个而不是六个顶点然后只指定绘制的顺序；</p>
<p>而元素缓冲区对象的工作方式正是如此；EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。这种所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span></span><br><span class="line">    <span class="comment">// 这样可以由下标代表顶点组合成矩形</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;EBO);<span class="comment">//创建元素缓冲对象；</span></span><br><span class="line"><span class="comment">//与VBO类似，我们先绑定EBO然后用glBufferData把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后我们使用glDrawElements来绘制，此时会使用当前绑定的索引缓冲对象中的索引进行绘制：</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是GL_UNSIGNED_INT。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</span></span><br></pre></td></tr></table></figure>



<p><img src="https://learnopengl-cn.github.io/img/01/04/vertex_array_objects_ebo.png" alt="img"></p>
<p>glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取其索引。这意味着我们每次想要使用索引渲染对象时都必须绑定相应的EBO，这又有点麻烦。碰巧顶点数组对象也跟踪元素缓冲区对象绑定。在绑定VAO时，绑定的最后一个元素缓冲区对象存储为VAO的元素缓冲区对象。然后，绑定到VAO也会自动绑定该EBO。</p>
<p><strong>当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。</strong></p>
<h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><p>一个典型的着色器有下面的结构：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="comment">//声明版本</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限；</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nrAttributes;</span><br><span class="line">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line">std::cout &lt;&lt; &quot;Maximum nr of vertex attributes supported: &quot; &lt;&lt; nrAttributes &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221110114428423.png" alt="image-20221110114428423"></p>
<p>向量是一种灵活的数据类型，允许如下的语法：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> someVec;</span><br><span class="line"><span class="type">vec4</span> differentVec = someVec.xyxx;</span><br><span class="line"><span class="type">vec3</span> anotherVec = differentVec.zyw;</span><br><span class="line"><span class="type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;<span class="comment">//重组(Swizzling)</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec2</span> vect = <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line"><span class="type">vec4</span> result = <span class="type">vec4</span>(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec4</span> otherResult = <span class="type">vec4</span>(result.xyz, <span class="number">1.0</span>);<span class="comment">//向量作为参数创建新向量</span></span><br></pre></td></tr></table></figure>

<h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><p>GLSL定义了<code>in</code>和<code>out</code>关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。</p>
<p>顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们<strong>使用location这一元数据指定输入变量</strong>，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout (location &#x3D; 0)。顶点着色器<strong>需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据</strong>。</p>
<p>所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。</p>
<p>例如我们从顶点着色器中定义颜色传递给片元着色器使用：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core//顶点着色器</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core//片元着色器</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h4><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量<strong>必须在每个着色器程序对象中都是独一无二的</strong>，而且<strong>它可以被着色器程序的任意着色器在任意阶段访问</strong>。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p>
<p><strong>如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</strong></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;<span class="comment">//我们先在片元着色器中声明一个uniform;</span></span><br><span class="line"><span class="comment">//这个uniform现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中uniform属性的索引/位置值。当我们得到uniform的索引/位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色：</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> timeValue = glfwGetTime();<span class="comment">//获取运行的秒数</span></span><br><span class="line"><span class="type">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0</span>f) + <span class="number">0.5</span>f;<span class="comment">//用sin让颜色在0.0-1.0之间改变，将结果存储到greenValue中</span></span><br><span class="line"><span class="type">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);</span><br><span class="line"><span class="comment">//用glGetUniformLocation查询uniform ourColor的位置值，我们为查询函数提供着色器程序和uniform的名字(没找到将返回-1)</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0</span>f, greenValue, <span class="number">0.0</span>f, <span class="number">1.0</span>f);<span class="comment">//通过glUniform4f函数设置uniform值；</span></span><br><span class="line"><span class="comment">//(查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你必须先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="更多属性"><a href="#更多属性" class="headerlink" title="更多属性"></a>更多属性</h4><p>假如我们有这样一些属性，他们都储存到一个VAO里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么新的顶点着色器需要接受颜色值作为一个顶点属性输入：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们的VBO数据：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/05/vertex_attribute_pointer_interleaved.png" alt="img"></p>
<p>知道了现在使用的布局，我们就可以使用glVertexAttribPointer函数更新顶点格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="number">3</span>* <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*glVertexAttribPointer函数的前几个参数比较明了。这次我们配置属性位置值为1的顶点属性。颜色值有3个float那么大，我们不去标准化这些值。</span></span><br><span class="line"><span class="comment">由于我们现在有了两个顶点属性，我们不得不重新计算步长值。为获得数据队列中下一个属性值（比如位置向量的下个x分量）我们必须向右移动6个float，其中3个是位置值，另外3个是颜色值。这使我们的步长值为6乘以float的字节数（=24字节）。</span></span><br><span class="line"><span class="comment">同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是3 * sizeof(float)，用字节来计算就是12字节。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221121163646623.png" alt="运行结果"></p>
<p>得到的运行结果如上图，因为我们只提供了三个颜色，这是片元着色器中插值得到的结果；在光栅化时，会根据像素数量生成片元；</p>
<p>基于这些片元的位置，会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝 + 70%绿。</p>
<h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>纹理可以用来添加物体的细节，可以让物体非常精细而不用指定额外的顶点；</p>
<p>为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>
<p>纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做**采样(Sampling)**。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p>
<p><img src="https://learnopengl-cn.github.io/img/01/06/tex_coords.png" alt="img"></p>
<p>我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> texCoords[] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">1.0f</span> <span class="comment">// 上中</span></span><br><span class="line">&#125;;<span class="comment">//定义纹理坐标</span></span><br></pre></td></tr></table></figure>

<p>而对纹理采样的解释非常宽松，他可以采用几种不同的插值方式；所以我们需要自己告诉OpenGL该怎样对纹理采样；</p>
<h4 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h4><p>纹理坐标的范围通常从(0,0)到(1,1)；当坐标超出范围时，OpenGL提供了如下选择：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221122161436202.png" alt="image-20221122161436202"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述选项可以用该函数对单独的一个坐标轴设置(s,t,r(3D情况下))</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br><span class="line"><span class="comment">//第一个参数指定了目标纹理，第二个参数指定设置的选项和轴，第三个参数指定环绕方式；</span></span><br><span class="line"><span class="comment">//(设定为GL_CLAMP_TO_BORDER时还需要一个参数指定颜色)</span></span><br></pre></td></tr></table></figure>

<h4 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h4><p>纹理坐标不依赖于分辨率，可以是任意浮点值，所以OpenGL需要将纹理像素映射到纹理坐标，尤其是在物体很大但纹理的分辨率很低时；这个过程称作纹理过滤：</p>
<p>纹理过滤一般有四种方式：</p>
<p>1、最近点采样 GL_NEAREST<br>2、线性纹理过滤(双线性过滤)GL_LINEAR<br>3、mipmap纹理过滤(三线性过滤) GL_LINEAR_MIPMAP_LINEAR<br>4、各向异性过滤</p>
<p><strong>GL_NEAREST 邻近过滤</strong></p>
<p>默认的过滤方式，OpenGL会选择中心点最接近纹理坐标的像素：<img src="https://learnopengl-cn.github.io/img/01/06/filter_nearest.png" alt="img"></p>
<p><strong>GL_LINEAR 线性过滤</strong></p>
<p>基于纹理坐标附近的像素进行插值，一个纹素的中心距离纹理坐标越近则颜色贡献越大：<img src="https://learnopengl-cn.github.io/img/01/06/filter_linear.png" alt="img"></p>
<p>如果在很大的物体上使用低分辨率的纹理，两种过滤方式的区别很明显：</p>
<p><img src="https://learnopengl-cn.github.io/img/01/06/texture_filtering.png" alt="img"></p>
<p>纹理过滤通常分为2种情况：<br>1、纹理被缩小（GL_TEXTURE_MIN_FILTER）<br>比如说一个8 x 8的纹理贴到一个平行于xy平面的正方形上，最后该正方形在屏幕上只占4 x 4的象素矩阵，这种情况下一个象素对应着多个纹理单元。<br>2、纹理被放大（ GL_TEXTURE_MAG_FILTER）<br>纹理被放大这种情况刚好跟上面相反，假如我们放大该正方形，最后正方形在屏幕上占了一个16 x 16的象素矩阵，这样就变成一个纹理单元对应着多个象素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当进行放大和缩小操作时可以设置纹理过滤的选项</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//比如在纹理被缩小时使用邻近过滤，纹理被放大时使用线性过滤</span></span><br></pre></td></tr></table></figure>

<h4 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h4><p>对于场景中远处的物体，如果他们的纹理拥有和近处物体同样高的分辨率，但是他们可能在屏幕上只会生成数个片元，此时对他们获取颜色值就较为困难，需要跨过很大的纹理部分只拾取一个纹理颜色，同时对他们使用高分辨率纹理浪费内存；</p>
<p>而多级渐远纹理(mipmap)解决了这个问题，他是一系列的纹理图像，后一个纹理图像是前一个的二分之一；当物体和观察者的距离超过一个阈值，OpenGL会使用不同的多级渐远纹理；</p>
<p><img src="https://learnopengl-cn.github.io/img/01/06/mipmaps.png" alt="img"></p>
<p>OpenGL提供了glGenerateMipmaps函数来创建多级渐远纹理；</p>
<p>在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221122163828420.png" alt="image-20221122163828420"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">//一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</span></span><br></pre></td></tr></table></figure>

<h4 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h4><p><code>stb_image.h</code>是<a target="_blank" rel="noopener" href="https://github.com/nothings">Sean Barrett</a>的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"><span class="comment">//通过定义STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 .cpp 文件了。现在只需要在你的程序中包含stb_image.h并编译就可以了。</span></span><br><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//使用stb_image加载图片，我们需要使用它的stbi_load函数</span></span><br><span class="line"><span class="comment">//参数为文件位置，宽度，高度，颜色通道的个数；</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);<span class="comment">//该函数首先输入生成纹理的数量，然后把它们储存在第二个参数的数组中；</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);<span class="comment">//和其他对象一样，纹理对象需要绑定，让之后的纹理指令配置当前绑定的纹理；</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<span class="comment">//设置过滤</span></span><br><span class="line"><span class="comment">//接下来使用前面载入的图片生成纹理；</span></span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    <span class="comment">//第一个参数指定纹理坐标，意味着生成与当前绑定的纹理对象在同一个目标上的纹理(绑定到1D和3D的不受影响)</span></span><br><span class="line">    <span class="comment">//第二个参数指定多级渐远纹理的级别；这里填0意味着基本级别；</span></span><br><span class="line">    <span class="comment">//第三个参数表示储存格式，我们的图像只有RGB值，因此储存为RGB值；</span></span><br><span class="line">    <span class="comment">//四五个参数设置宽度高度，第六个参数由于历史遗留问题永远设置为0；</span></span><br><span class="line">    <span class="comment">//七八个参数定义了原图的格式和数据类型，我们使用RGB值加载，并存储为char数组</span></span><br><span class="line">    <span class="comment">//最后一个参数是图像数据</span></span><br><span class="line">    <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);<span class="comment">//这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);<span class="comment">//生成纹理之后，释放图像内存</span></span><br></pre></td></tr></table></figure>

<h4 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h4><p>使用glUniform1i，我们可以给纹理采样器分配一个位置值，这样我们能在一个片元着色器中设置多个纹理；一个纹理的位置值通常称为一个纹理单元(Texture Unit)；默认的纹理单元是0，是默认激活的纹理单元；</p>
<p>纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元,纹理单元和采样器互相对应</span></span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">//OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。</span></span><br></pre></td></tr></table></figure>

<p>OpenGL要求y轴<code>0.0</code>坐标是在图片的底部的，但是图片的y轴<code>0.0</code>坐标通常在顶部。很幸运，<code>stb_image.h</code>能够在图像加载时帮助我们翻转y轴，只需要在加载任何图像前加入以下语句即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>向量和矩阵部分为数学基础；</p>
<p>使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。让我们看看我们是否能生成一个变换矩阵，让它组合多个变换。假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221123152746955.png" alt="image-20221123152746955"></p>
<p>注意，当矩阵相乘时我们先写位移再写缩放变换的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议您在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！</p>
<p>用最终的变换矩阵左乘我们的向量会得到以下结果：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221123152813170.png" alt="image-20221123152813170"></p>
<p>不错！向量先缩放2倍，然后位移了(1, 2, 3)个单位。</p>
<h4 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h4><h4 id="该库中矩阵按列存储！"><a href="#该库中矩阵按列存储！" class="headerlink" title="该库中矩阵按列存储！"></a>该库中矩阵按列存储！</h4><p>GLM是Open<strong>GL</strong> <strong>M</strong>athematics的缩写，它是一个<strong>只有头文件的</strong>库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的<a target="_blank" rel="noopener" href="https://glm.g-truc.net/0.9.8/index.html">网站</a>上下载。把头文件的根目录复制到你的<strong>includes</strong>文件夹，然后你就可以使用这个库了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans;</span><br><span class="line">trans = glm::<span class="built_in">rotate</span>(trans, glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::<span class="built_in">scale</span>(trans, glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));<span class="comment">//使用Glm库函数获得旋转+缩放的变换矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(<span class="built_in">glGetUniformLocation</span>(ourShader.ID, <span class="string">&quot;transform&quot;</span>), <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(trans));</span><br><span class="line"><span class="comment">//定义一个变换矩阵，并将它使用uniform传入顶点着色器</span></span><br></pre></td></tr></table></figure>

<h3 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h3><p>OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为<strong>标准化设备坐标(Normalized Device Coordinate, NDC)<strong>。也就是说，每个顶点的</strong>x</strong>，<strong>y</strong>，<strong>z</strong>坐标都应该在**-1.0<strong>到</strong>1.0<strong>之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为</strong>标准化设备坐标**。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p>
<p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个<strong>过渡</strong>坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p>
<ul>
<li>局部空间(Local Space，或者称为物体空间(Object Space))</li>
<li>世界空间(World Space)</li>
<li>观察空间(View Space，或者称为视觉空间(Eye Space))</li>
<li>裁剪空间(Clip Space)</li>
<li>屏幕空间(Screen Space)</li>
</ul>
<p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p>
<p><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png" alt="coordinate_systems"></p>
<p>在GLM中可以这样创建一个透视投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), (<span class="type">float</span>)width/(<span class="type">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="comment">/*它的第一个参数定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。*/</span></span><br></pre></td></tr></table></figure>

<p>接下来设置变换矩阵，让二维的平面进入三维世界：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, glm::<span class="built_in">radians</span>(<span class="number">-55.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));<span class="comment">//模型矩阵</span></span><br><span class="line">glm::mat4 view;</span><br><span class="line"><span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></span><br><span class="line">view = glm::<span class="built_in">translate</span>(view, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));<span class="comment">//视角矩阵</span></span><br><span class="line">glm::mat4 projection;</span><br><span class="line">projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), <span class="number">800.f</span> / <span class="number">600.f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);<span class="comment">//透视矩阵</span></span><br><span class="line">ourShader.<span class="built_in">setMat</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">ourShader.<span class="built_in">setMat</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">ourShader.<span class="built_in">setMat</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"><span class="comment">//此时我们还需要打开深度测试：</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))&#123;</span><br><span class="line">    <span class="comment">//另外在每次渲染循环前需要清空深度缓冲</span></span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h3><p>在OpenGL中模拟摄像机，我们需要他在世界空间中的位置、观察的方向、指向他右侧的向量以及指向他上方的向量；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);<span class="comment">//设置摄像机位置；</span></span><br><span class="line"></span><br><span class="line">glm::vec3 cameraTarget = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraDirection = glm::<span class="built_in">normalize</span>(cameraPos - cameraTarget);</span><br><span class="line"><span class="comment">//设置摄像机方向，我们指定摄像机指向场景原点，目标点和摄像机位置相减得到方向向量(和实际方向相反)；</span></span><br><span class="line"></span><br><span class="line">glm::vec3 up = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>); </span><br><span class="line">glm::vec3 cameraRight = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(up, cameraDirection));</span><br><span class="line"><span class="comment">//先设置一个向上的向量，使其和方向向量叉乘得到右向量(交换叉乘顺序会得到相反的左向量，叉乘可以看做右手系中第一个参数为x轴，第二个参数为y轴，求z轴)；</span></span><br><span class="line"></span><br><span class="line">glm::vec3 cameraUp = glm::<span class="built_in">cross</span>(cameraDirection, cameraRight);</span><br><span class="line"><span class="comment">//最后用方向向量和右向量叉乘就得到了最后的上向量；</span></span><br></pre></td></tr></table></figure>

<p>使用这些向量，我们可以构建一个LookAt矩阵；</p>
<p><strong>使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。</strong>这正是<strong>LookAt</strong>矩阵所做的：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221125144306333.png" alt="image-20221125144306333"></p>
<p>其中<strong>R</strong>是右向量，<strong>U</strong>是上向量，<strong>D</strong>是方向向量，<strong>P</strong>是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个LookAt矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), <span class="comment">//摄像机位置；</span></span><br><span class="line">           glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), <span class="comment">//目标位置；</span></span><br><span class="line">           glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));<span class="comment">//世界空间中向上的向量；</span></span><br><span class="line"><span class="comment">//使用glm的函数，我们可以快速得到LookAt矩阵；</span></span><br></pre></td></tr></table></figure>

<h4 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h4><p>图形程序和游戏通常会跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，<strong>如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间</strong>。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。</p>
<h4 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h4><p>使用鼠标改变视角，我们就需要根据鼠标输入改变<strong>cameraFront</strong>向量；</p>
<p><img src="https://learnopengl-cn.github.io/img/01/09/camera_pitch.png" alt="img"></p>
<p><img src="https://learnopengl-cn.github.io/img/01/09/camera_yaw.png" alt="img"></p>
<p>我们可以用鼠标的横向移动来模拟表示yaw的值，用鼠标的纵向移动来代表pitch的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::<span class="built_in">radian</span>(pitch)) * <span class="built_in">cos</span>(glm::<span class="built_in">radian</span>(yaw));</span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::<span class="built_in">radian</span>(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::<span class="built_in">radian</span>(pitch)) * <span class="built_in">sin</span>(glm::<span class="built_in">radian</span>(yaw));</span><br><span class="line"><span class="comment">//这样就得到了新的direction</span></span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过鼠标的回调函数来控制摄像机：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在你的鼠标移动进窗口的那一刻，鼠标回调函数就会被调用，这时候的xpos和ypos会等于鼠标刚刚进入屏幕的那个位置。这通常是一个距离屏幕中心很远的地方，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个bool变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为xpos和ypos值；</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> xoffset = xpos - lastX;<span class="comment">//计算偏移值</span></span><br><span class="line">    <span class="type">float</span> yoffset = lastY - ypos;<span class="comment">//OpenGL中y原点为窗口底部</span></span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> sensitivity = <span class="number">0.05</span>;<span class="comment">//灵敏度</span></span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    yaw   += xoffset;<span class="comment">//将其累加至偏移角</span></span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)<span class="comment">//限制偏移角度</span></span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line"></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::<span class="built_in">radians</span>(yaw)) * <span class="built_in">cos</span>(glm::<span class="built_in">radians</span>(pitch));</span><br><span class="line">    cameraFront = glm::<span class="built_in">normalize</span>(front);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时，fov代表可以看到场景中多大的范围，当视野变小，投影得到的空间就会变小，视觉上即场景放大了；</span></span><br><span class="line"><span class="comment">//因此通过使用滚轮回调来控制fov实现缩放：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xoffset, <span class="type">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov -= yoffset;<span class="comment">//yoffset代表竖直滚动的大小；</span></span><br><span class="line">  <span class="comment">//限制缩放程度</span></span><br><span class="line">  <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    fov = <span class="number">1.0f</span>;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>众所周知，我们在现实生活中看到某一物体的颜色并不是这个物体真正拥有的颜色，而是它所反射的(Reflected)颜色。</p>
<p>白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色。它仅反射了代表物体颜色的部分，被反射颜色的组合就是我们所感知到的颜色；</p>
<p>在图形学中，我们会给光源一个颜色，再给物体一个颜色，当我们把光源和物体的颜色值相乘，得到的就是物体反射的颜色：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;<span class="comment">//白光</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor; <span class="comment">// = (1.0f, 0.5f, 0.31f);</span></span><br><span class="line"></span><br><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;<span class="comment">//绿光</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor; <span class="comment">// = (0.0f, 0.5f, 0.0f);，吸收了一部分绿色，也反射了一半绿色；现在物体变成了绿色；因为红蓝分量没有被反射；</span></span><br></pre></td></tr></table></figure>

<h3 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h3><p>Phong光照模型：环境光+漫反射+高光反射</p>
<p><img src="https://learnopengl-cn.github.io/img/02/02/basic_lighting_phong.png" alt="img"></p>
<ul>
<li>环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li>
<li>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。</li>
<li>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core<span class="comment">//片元着色器</span></span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">uniform vec3 objectColor;</span><br><span class="line">uniform vec3 lightColor;</span><br><span class="line">uniform vec3 lightPos;</span><br><span class="line">in vec3 FragPos;</span><br><span class="line">in vec3 Normal;</span><br><span class="line">uniform vec3 viewPos;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> ambientStrength = <span class="number">0.1</span>;<span class="comment">//环境光系数</span></span><br><span class="line">    <span class="type">float</span> specularStrength = <span class="number">0.5</span>;<span class="comment">//高光系数</span></span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line">    <span class="comment">////在片元着色器中定义一个环境光因子，乘以物体的颜色输出来模拟环境光；</span></span><br><span class="line"></span><br><span class="line">    vec3 norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    vec3 lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);<span class="comment">//入射方向</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);<span class="comment">//入射方向和法线的夹角cos值和漫反射光强度成正比</span></span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line"></span><br><span class="line">    vec3 viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);<span class="comment">//视角方向</span></span><br><span class="line">    vec3 reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);<span class="comment">//计算反射方向(reflect函数要求第一个参数是光源指向物体方向因此我们取反)</span></span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);<span class="comment">//反射方向和视角方向夹角越小，高光就越明显</span></span><br><span class="line">    vec3 specular = specularStrength * spec * lightColor;</span><br><span class="line"></span><br><span class="line">    vec3 result = (diffuse + ambient + specular) * objectColor;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，我们希望在同一坐标空间下计算光照，因此法线也应该变换到世界空间下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core<span class="comment">//顶点着色器</span></span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 aNormal;</span><br><span class="line"></span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line">out vec3 FragPos;</span><br><span class="line">out vec3 Normal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FragPos = <span class="built_in">vec3</span>(model * <span class="built_in">vec4</span>(aPos,<span class="number">1.0</span>));<span class="comment">//计算世界坐标；</span></span><br><span class="line">   Normal = <span class="built_in">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br><span class="line">   <span class="comment">//由于法线直接使用Model矩阵转换可能无法保证垂直，因此经过数学推导，我们使用模型矩阵的逆转置矩阵来变换即可；</span></span><br><span class="line"></span><br><span class="line">   gl_Position = projection * view * model * <span class="built_in">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h3><p>当描述一个表面时，我们可以分别为三个光照分量定义一个材质颜色(Material Color)：环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting)。通过为每个分量指定一个颜色，我们就能够对表面的颜色输出有细粒度的控制了。现在，我们再添加一个反光度(Shininess)分量，结合上述的三个颜色，我们就有了全部所需的材质属性了：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">struct Material &#123;<span class="comment">//在片段着色器中，我们创建一个结构体(Struct)来储存物体的材质属性。</span></span><br><span class="line">    <span class="type">vec3</span> ambient;<span class="comment">//定义了在环境光照下这个表面反射的是什么颜色，通常与表面的颜色相同。</span></span><br><span class="line">    <span class="type">vec3</span> diffuse;<span class="comment">//定义了在漫反射光照下表面的颜色。也被设置为我们期望的物体颜色</span></span><br><span class="line">    <span class="type">vec3</span> specular;<span class="comment">//设置的是表面上镜面高光的颜色</span></span><br><span class="line">    <span class="type">float</span> shininess;<span class="comment">//影响镜面高光的散射/半径</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br></pre></td></tr></table></figure>

<p>与此同时，我们还需要一个强度值来限制三个光照分量；一个光源对它的ambient、diffuse和specular光照分量有着不同的强度。环境光照通常被设置为一个比较低的强度，因为我们不希望环境光颜色太过主导。光源的漫反射分量通常被设置为我们希望光所具有的那个颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为<code>vec3(1.0)</code>，以最大强度发光：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Light light;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> ambient  = light.ambient * material.ambient;</span><br><span class="line"><span class="type">vec3</span> diffuse  = light.diffuse * (diff * material.diffuse);</span><br><span class="line"><span class="type">vec3</span> specular = light.specular * (spec * material.specular);</span><br></pre></td></tr></table></figure>

<p>接下来，通过调整材质参数，我们可以获得不同颜色的各种类型物体的效果：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221129153439914.png" alt="image-20221129153439914"></p>
<p><img src="https://learnopengl-cn.github.io/img/02/03/materials_real_world.png" alt="img"></p>
<h3 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h3><p>在实际场景中，往往某个物体的不同部位拥有着不同的材质；我们希望对物体的每个片段单独设置反射颜色，因此我们需要光照贴图；</p>
<h4 id="漫反射贴图"><a href="#漫反射贴图" class="headerlink" title="漫反射贴图"></a>漫反射贴图</h4><p><img src="https://learnopengl-cn.github.io/img/02/04/container2.png" alt="img"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Material &#123;</span><br><span class="line">    <span class="type">sampler2D</span> diffuse;</span><br><span class="line"><span class="comment">//使用sampler2D来存储纹理，也移除了环境光材质颜色向量，因为环境光颜色在几乎所有情况下都等于漫反射颜色，所以我们不需要将它们分开储存</span></span><br><span class="line"><span class="comment">//注意sampler2D是所谓的不透明类型(Opaque Type)，也就是说我们不能将它实例化，只能通过uniform来定义它。如果我们使用除uniform以外的方法（比如函数的参数）实例化这个结构体，GLSL会抛出一些奇怪的错误。这同样也适用于任何封装了不透明类型的结构体。</span></span><br><span class="line">    <span class="type">vec3</span>  specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"><span class="comment">//接下来只需要在片元着色器中将材质颜色更换为采样得到的颜色值即可；</span></span><br></pre></td></tr></table></figure>

<h4 id="镜面光贴图"><a href="#镜面光贴图" class="headerlink" title="镜面光贴图"></a>镜面光贴图</h4><p>我们同样可以使用一个专门用于镜面高光的纹理贴图。这也就意味着我们需要生成一个<strong>黑白的</strong>（如果你想得话也可以是彩色的）纹理，来定义物体每部分的镜面光强度:</p>
<p><img src="https://learnopengl-cn.github.io/img/02/04/container2_specular.png" alt="img"></p>
<p>镜面高光的强度可以通过图像每个像素的亮度来获取。镜面光贴图上的每个像素都可以由一个颜色向量来表示，比如说黑色代表颜色向量<code>vec3(0.0)</code>，灰色代表颜色向量<code>vec3(0.5)</code>。在片段着色器中，我们接下来会<strong>取样对应的颜色值并将它乘以光源的镜面强度</strong>。一个像素越「白」，乘积就会越大，物体的镜面光分量就会越亮。</p>
<p>由于箱子大部分都由木头所组成，而且木头材质应该没有镜面高光，所以漫反射纹理的整个木头部分全部都转换成了黑色。箱子钢制边框的镜面光强度是有细微变化的，钢铁本身会比较容易受到镜面高光的影响，而裂缝则不会。</p>
<h3 id="投光物"><a href="#投光物" class="headerlink" title="投光物"></a>投光物</h3><p>将光<strong>投射</strong>(Cast)到物体的光源叫做投光物(Light Caster)。投光物有着几种不同的类型：定向光(Directional Light)，点光源(Point Light)，聚光(Spotlight)；</p>
<h4 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h4><p>当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行。不论物体和&#x2F;或者观察者的位置，看起来好像所有的光都来自于同一个方向。当我们使用一个假设光源处于<strong>无限</strong>远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="comment">// vec3 position; // 使用定向光就不再需要了</span></span><br><span class="line">    <span class="type">vec3</span> direction;<span class="comment">//我们输入一个从光源出发的方向向量；</span></span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(-light.direction);<span class="comment">//计算需要的是片元到光源的向量，所以取反；</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h4><p>点光源会从他的光源位置开始朝着所有方向散射光线；之前实现的光源与之类似，但是我们忽略了<strong>衰减</strong>；</p>
<p>随着光线传播距离的增长逐渐削减光的强度通常叫做衰减(Attenuation)。下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20221130163510254.png" alt="image-20221130163510254"></p>
<p>在这里d代表了片段距光源的距离。接下来为了计算衰减值，我们定义3个（可配置的）项：常数项Kc、一次项Kl和二次项Kq。</p>
<ul>
<li>常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。</li>
<li>一次项会与距离值相乘，以线性的方式减少强度。</li>
<li>二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。</li>
</ul>
<p>正确地设定它们的值取决于很多因素：环境、希望光覆盖的距离、光的类型等。在大多数情况下，这都是经验的问题，以及适量的调整。下面这个表格显示了模拟一个（大概）真实的，覆盖特定半径（距离）的光源时，这些项可能取的一些值。第一列指定的是在给定的三项时光所能覆盖的距离。</p>
<table>
<thead>
<tr>
<th align="left">距离</th>
<th align="left">常数项</th>
<th align="left">一次项</th>
<th align="left">二次项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7</td>
<td align="left">1.0</td>
<td align="left">0.7</td>
<td align="left">1.8</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">1.0</td>
<td align="left">0.35</td>
<td align="left">0.44</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">1.0</td>
<td align="left">0.22</td>
<td align="left">0.20</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">1.0</td>
<td align="left">0.14</td>
<td align="left">0.07</td>
</tr>
<tr>
<td align="left">50</td>
<td align="left">1.0</td>
<td align="left">0.09</td>
<td align="left">0.032</td>
</tr>
<tr>
<td align="left">65</td>
<td align="left">1.0</td>
<td align="left">0.07</td>
<td align="left">0.017</td>
</tr>
<tr>
<td align="left">100</td>
<td align="left">1.0</td>
<td align="left">0.045</td>
<td align="left">0.0075</td>
</tr>
<tr>
<td align="left">160</td>
<td align="left">1.0</td>
<td align="left">0.027</td>
<td align="left">0.0028</td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">1.0</td>
<td align="left">0.022</td>
<td align="left">0.0019</td>
</tr>
<tr>
<td align="left">325</td>
<td align="left">1.0</td>
<td align="left">0.014</td>
<td align="left">0.0007</td>
</tr>
<tr>
<td align="left">600</td>
<td align="left">1.0</td>
<td align="left">0.007</td>
<td align="left">0.0002</td>
</tr>
<tr>
<td align="left">3250</td>
<td align="left">1.0</td>
<td align="left">0.0014</td>
<td align="left">0.000007</td>
</tr>
</tbody></table>
<p>所以我们要更新片元着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;  </span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;<span class="comment">//常数项</span></span><br><span class="line">    <span class="type">float</span> linear;<span class="comment">//一次项</span></span><br><span class="line">    <span class="type">float</span> quadratic;<span class="comment">//二次项</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h4><p>聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。</p>
<p>OpenGL中聚光是用一个世界空间位置、一个方向和一个切光角(Cutoff Angle)来表示的，切光角指定了聚光的半径（译注：是圆锥的半径不是距光源距离那个半径）。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。下面这张图会让你明白聚光是如何工作的：</p>
<p><img src="https://learnopengl-cn.github.io/img/02/05/light_casters_spotlight_angles.png" alt="img"></p>
<ul>
<li><code>LightDir</code>：从片段指向光源的向量。</li>
<li><code>SpotDir</code>：聚光所指向的方向。</li>
<li><code>Phi</code>ϕ：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。</li>
<li><code>Theta</code>θ：LightDir向量和SpotDir向量之间的夹角。在聚光内部的话θθ值应该比ϕϕ值小。</li>
</ul>
<p>所以我们要做的就是<strong>计算LightDir向量和SpotDir向量之间的点积，并将它与切光角ϕ值对比</strong>。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span>  position;<span class="comment">//聚光位置</span></span><br><span class="line">    <span class="type">vec3</span>  direction;<span class="comment">//聚光方向</span></span><br><span class="line">    <span class="type">float</span> cutOff;<span class="comment">//切光角</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> theta = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(theta &gt; light.cutOff) </span><br><span class="line">&#123;       </span><br><span class="line">  <span class="comment">// 执行光照计算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">// 否则，使用环境光，让场景在聚光之外时不至于完全黑暗</span></span><br><span class="line">  FragColor = <span class="type">vec4</span>(light.ambient * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords)), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure>

<p>为了创建一种看起来边缘平滑的聚光，我们需要<strong>模拟聚光有一个内圆锥(Inner Cone)和一个外圆锥(Outer Cone)<strong>。我们可以将内圆锥设置为上一部分中的那个圆锥，但我们也需要一个外圆锥，来</strong>让光从内圆锥逐渐减暗，直到外圆锥的边界</strong>。</p>
<p>为了创建一个外圆锥，我们只需要再定义一个余弦值来代表聚光方向向量和外圆锥向量（等于它的半径）的夹角。然后，如果一个片段处于内外圆锥之间，将会给它计算出一个0.0到1.0之间的强度值。如果片段在内圆锥之内，它的强度就是1.0，如果在外圆锥之外强度值就是0.0。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们通过角度距离插值得到强度值，再乘到漫反射和高光反射上以得到平滑过渡的结果</span></span><br><span class="line"><span class="type">float</span> theta     = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line"><span class="type">float</span> epsilon   = light.cutOff - light.outerCutOff;</span><br><span class="line"><span class="type">float</span> intensity = <span class="built_in">clamp</span>((theta - light.outerCutOff) / epsilon, <span class="number">0.0</span>, <span class="number">1.0</span>);    </span><br><span class="line">...</span><br><span class="line"><span class="comment">// 将不对环境光做出影响，让它总是能有一点光</span></span><br><span class="line">diffuse  *= intensity;</span><br><span class="line">specular *= intensity;</span><br></pre></td></tr></table></figure>

<h3 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h3><p>为了在场景中使用多个光源，我们希望将光照计算封装到GLSL函数中。这样做的原因是，每一种光源都需要一种不同的计算方法，而一旦我们想对多个光源进行光照计算时，代码很快就会变得非常复杂。如果我们只在main函数中进行所有的这些计算，代码很快就会变得难以理解。</p>
<p>当我们在场景中使用多个光源时，通常使用以下方法：我们需要有一个单独的颜色向量代表片段的输出颜色。对于每一个光源，它对片段的贡献颜色将会加到片段的输出颜色向量上。所以场景中的每个光源都会计算它们各自对片段的影响，并结合为一个最终的输出颜色。大体的结构会像是这样：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 定义一个输出颜色值</span></span><br><span class="line">  <span class="type">vec3</span> output;</span><br><span class="line">  <span class="comment">// 将定向光的贡献加到输出中</span></span><br><span class="line">  output += someFunctionToCalculateDirectionalLight();</span><br><span class="line">  <span class="comment">// 对所有的点光源也做相同的事情</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr_of_point_lights; i++)</span><br><span class="line">    output += someFunctionToCalculatePointLight();</span><br><span class="line">  <span class="comment">// 也加上其它的光源（比如聚光）</span></span><br><span class="line">  output += someFunctionToCalculateSpotLight();</span><br><span class="line"></span><br><span class="line">  FragColor = <span class="type">vec4</span>(output, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对每个光照类型都创建一个不同的函数：平行光、点光源和聚光灯。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">struct Material &#123;<span class="comment">//在片段着色器中，我们创建一个结构体(Struct)来储存物体的材质属性。</span></span><br><span class="line">    <span class="type">sampler2D</span> diffuse;<span class="comment">//漫反射纹理，由于环境光的颜色和漫反射基本一致，因此我们统一储存；</span></span><br><span class="line">    <span class="type">sampler2D</span> specular;<span class="comment">//设置的是表面上镜面高光的颜色</span></span><br><span class="line">    <span class="type">float</span> shininess;<span class="comment">//影响镜面高光的散射/半径</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">struct DirLight &#123;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">uniform</span> DirLight dirLight;</span><br><span class="line"></span><br><span class="line">struct PointLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//衰减参数</span></span><br><span class="line">    <span class="type">float</span> constant;<span class="comment">//常数项</span></span><br><span class="line">    <span class="type">float</span> linear;<span class="comment">//一次项</span></span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="meta">#define NR_POINT_LIGHTS 4//定义了点光源数量</span></span><br><span class="line"><span class="keyword">uniform</span> PointLight pointLights[NR_POINT_LIGHTS];</span><br><span class="line"></span><br><span class="line">struct SpotLight&#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line">    <span class="type">float</span> cutOff;<span class="comment">//切光角</span></span><br><span class="line">    <span class="type">float</span> outerCutOff;<span class="comment">//外切光角</span></span><br><span class="line">    <span class="comment">//衰减</span></span><br><span class="line">    <span class="type">float</span> constant;<span class="comment">//常数项</span></span><br><span class="line">    <span class="type">float</span> linear;<span class="comment">//一次项</span></span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> SpotLight spotLight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir);<span class="comment">//平行光计算</span></span><br><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir);<span class="comment">//点光源计算</span></span><br><span class="line"><span class="type">vec3</span> CalcSpotLight(SpotLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir);<span class="comment">//聚光灯计算</span></span><br><span class="line"><span class="comment">//接下来只需要在main函数中调用计算不同光照的函数，分别计算光照并相加即可；</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：定向光照</span></span><br><span class="line">    <span class="type">vec3</span> result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class="line">    <span class="comment">// 第二阶段：点光源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span><br><span class="line">        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);  </span><br><span class="line">    <span class="comment">// 第三阶段：聚光</span></span><br><span class="line">    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h2><p>对于实际场景中用到的模型，我们无法像之前的箱子一样手工定义所以的顶点、法线和纹理坐标；我们需要将这些模型导入到程序中；</p>
<h3 id="Assimp"><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h3><p>一个非常流行的模型导入库是<a target="_blank" rel="noopener" href="http://assimp.org/">Assimp</a>，它是<strong>Open Asset Import Library</strong>（开放的资产导入库）的缩写。Assimp能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至Assimp的通用数据结构中。当Assimp加载完模型之后，我们就能够从Assimp的数据结构中提取我们所需的所有数据了。由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。</p>
<p>Assimp数据结构的（简化）模型如下：</p>
<p><img src="https://learnopengl-cn.github.io/img/03/01/assimp_structure.png" alt="img"></p>
<ul>
<li>和材质和网格(Mesh)一样，所有的场景&#x2F;模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</li>
<li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</li>
<li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</li>
<li>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的（见[你好，三角形](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;04 Hello Triangle&#x2F;)）。</li>
<li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</li>
</ul>
<p>所以，我们需要做的第一件事是将一个物体加载到Scene对象中，遍历节点，获取对应的Mesh对象（我们需要递归搜索每个节点的子节点），并处理每个Mesh对象来获取顶点数据、索引以及它的材质属性。最终的结果是一系列的网格数据，我们会将它们包含在一个<code>Model</code>对象中。</p>
<h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>通过使用Assimp，我们可以加载不同的模型到程序中，但是载入后它们都被储存为Assimp的数据结构。我们最终仍要将这些数据转换为OpenGL能够理解的格式，这样才能渲染这个物体。我们从上一节中学到，网格(Mesh)代表的是单个的可绘制实体，我们现在先来定义一个我们自己的网格类。</p>
<p>一个网格应该至少需要一系列的顶点，每个顶点包含一个位置向量、一个法向量和一个纹理坐标向量。一个网格还应该包含用于索引绘制的索引以及纹理形式的材质数据（漫反射&#x2F;镜面光贴图）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义顶点结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;<span class="comment">//储存需要的向量</span></span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec3 Normal;</span><br><span class="line">    glm::vec2 TexCoords;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义纹理结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Texture</span> &#123;<span class="comment">//储存了纹理的id以及它的类型，比如是漫反射贴图或者是镜面光贴图</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> id;</span><br><span class="line">    string type;</span><br><span class="line">    string path;<span class="comment">//我们储存纹理的路径用于与其他纹理进行比较</span></span><br><span class="line">    <span class="comment">//在下一节中调整该部分：每当我们想加载一个纹理的时候，首先去检查它有没有被加载过。如果有的话，我们会直接使用那个纹理，并跳过整个加载流程，来为我们省下很多处理能力。为了能够比较纹理，我们还需要储存它们的路径：</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mesh</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/*  网格数据  */</span></span><br><span class="line">        vector&lt;Vertex&gt; vertices;</span><br><span class="line">        vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices;</span><br><span class="line">        vector&lt;Texture&gt; textures;</span><br><span class="line">        <span class="comment">/*  函数  */</span></span><br><span class="line">        <span class="built_in">Mesh</span>(vector&lt;Vertex&gt; vertices, vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices, vector&lt;Texture&gt; textures) &#123;<span class="comment">//将所有数据赋予网格</span></span><br><span class="line">        	<span class="keyword">this</span>-&gt;vertices = vertices;</span><br><span class="line">        	<span class="keyword">this</span>-&gt;indices = indices;</span><br><span class="line">        	<span class="keyword">this</span>-&gt;textures = textures;</span><br><span class="line"></span><br><span class="line">        	<span class="built_in">setupMesh</span>();<span class="comment">//初始化缓冲</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span></span>;</span><br><span class="line">   		<span class="comment">//将一个着色器传入了Draw函数中，将着色器传入网格类中可以让我们在绘制之前设置一些uniform（像是链接采样器到纹理单元）</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/*  渲染数据  */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> VAO, VBO, EBO;</span><br><span class="line">        <span class="comment">/*  函数  */</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setupMesh</span><span class="params">()</span></span>;<span class="comment">//初始化顶点数据，指针，索引;内部代码见VS</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++结构体有一个很棒的特性，它们的内存布局是连续的(Sequential)。也就是说，如果我们将结构体作为一个数据数组使用，那么它将会以顺序排列结构体的变量，这将会直接转换为我们在数组缓冲中所需要的float（实际上是字节）数组。比如说，如果我们有一个填充后的Vertex结构体，那么它的内存布局将会等于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vertex vertex;</span><br><span class="line">vertex.Position  = glm::<span class="built_in">vec3</span>(<span class="number">0.2f</span>, <span class="number">0.4f</span>, <span class="number">0.6f</span>);</span><br><span class="line">vertex.Normal    = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">vertex.TexCoords = glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f];</span></span><br><span class="line"><span class="comment">//由于有了这个有用的特性，我们能够直接传入一大列的Vertex结构体的指针作为缓冲的数据，它们将会完美地转换为glBufferData所能用的参数：</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, vertices.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(Vertex), &amp;vertices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">//自然sizeof运算也可以用在结构体上来计算它的字节大小。这个应该是32字节的（8个float * 每个4字节）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体的另外一个很好的用途是它的预处理指令offsetof(s, m)，它的第一个参数是一个结构体，第二个参数是这个结构体中变量的名字。这个宏会返回那个变量距结构体头部的字节偏移量(Byte Offset)。这正好可以用在定义glVertexAttribPointer函数中的偏移参数：</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="built_in">sizeof</span>(Vertex), (<span class="type">void</span>*)<span class="built_in">offsetof</span>(Vertex, Normal)); </span><br></pre></td></tr></table></figure>

<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>在真正渲染这个网格之前，我们需要在调用glDrawElements函数之前先绑定相应的纹理。然而，这实际上有些困难，我们一开始并不知道这个网格（如果有的话）有多少纹理、纹理是什么类型的。所以我们该如何在着色器中设置纹理单元和采样器呢？</p>
<p>为了解决这个问题，我们需要设定一个命名标准：每个漫反射纹理被命名为<code>texture_diffuseN</code>，每个镜面光纹理应该被命名为<code>texture_specularN</code>，其中<code>N</code>的范围是1到纹理采样器最大允许的数字。比如说我们对某一个网格有3个漫反射纹理，2个镜面光纹理，它们的纹理采样器应该之后会被调用：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_diffuse1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_diffuse2;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_diffuse3;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_specular1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture_specular2;</span><br></pre></td></tr></table></figure>

<p>根据这个标准，我们可以在着色器中定义任意需要数量的纹理采样器，如果一个网格真的包含了（这么多）纹理，我们也能知道它们的名字是什么。根据这个标准，我们也能在一个网格中处理任意数量的纹理，开发者也可以自由选择需要使用的数量，他只需要定义正确的采样器就可以了（虽然定义少的话会有点浪费绑定和uniform调用）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span> </span>&#123;<span class="comment">//绘制网格</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> diffuseNr = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> specularNr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; textures.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">glActiveTexture</span>(GL_TEXTURE0 + i);<span class="comment">//绑定前激活相应的纹理单元</span></span><br><span class="line">        <span class="comment">//获取纹理序号</span></span><br><span class="line">        string number;</span><br><span class="line">        string name = textures[i].type;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="string">&quot;texture_diffuse&quot;</span>)</span><br><span class="line">            number = std::<span class="built_in">to_string</span>(diffuseNr++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (name == <span class="string">&quot;texture_specular&quot;</span>)</span><br><span class="line">            number = std::<span class="built_in">to_string</span>(specularNr++);</span><br><span class="line">        shader.<span class="built_in">setInt</span>((<span class="string">&quot;material.&quot;</span> + name + number).<span class="built_in">c_str</span>(), i);</span><br><span class="line">        <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[i].id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//绘制网格</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line">    <span class="built_in">glDrawElements</span>(GL_TRIANGLES, indices.<span class="built_in">size</span>(), GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先计算了每个纹理类型的N-分量，并将其拼接到纹理类型字符串上，来获取对应的uniform名称。接下来我们查找对应的采样器，将它的位置值设置为当前激活的纹理单元，并绑定纹理。这也是我们在Draw函数中需要着色器的原因。我们也将<code>&quot;material.&quot;</code>添加到了最终的uniform名称中，因为我们希望将纹理储存在一个材质结构体中（这在每个实现中可能都不同）。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>现在是时候接触Assimp并创建实际的加载和转换代码了。这个教程的目标是创建另一个类来完整地表示一个模型，或者说是包含多个网格，甚至是多个物体的模型。一个包含木制阳台、塔楼、甚至游泳池的房子可能仍会被加载为一个模型。我们会使用Assimp来加载模型，并将它转换(Translate)至多个在上一节中创建的Mesh对象。</p>
<p>实际上使用Assimp加载模型是非常容易的。困难的是之后使用返回的场景对象将加载的数据转换到一个Mesh对象的数组。</p>
<p>Model类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mosel</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/*  函数   */</span></span><br><span class="line">        <span class="built_in">Model</span>(<span class="type">char</span> *path)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">loadModel</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shader shader)</span></span>&#123;<span class="comment">//遍历所有的网格，然后调用它们各自的Draw函数</span></span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; meshes.<span class="built_in">size</span>(); i++)</span><br><span class="line">        		meshes[i].<span class="built_in">Draw</span>(shader);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">/*  模型数据  */</span></span><br><span class="line">        vector&lt;Mesh&gt; meshes;</span><br><span class="line">        string directory;</span><br><span class="line">        <span class="comment">/*  函数   */</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">loadModel</span><span class="params">(string path)</span></span>&#123;</span><br><span class="line">            <span class="comment">//Assimp很棒的一点在于，它抽象掉了加载不同文件格式的所有技术细节，只需要一行代码就能完成所有的工作：</span></span><br><span class="line">            Assimp::Importer importer;<span class="comment">//声明Assimp命名空间内的一个Importer</span></span><br><span class="line">            <span class="type">const</span> aiScene *scene = importer.<span class="built_in">ReadFile</span>(path, aiProcess_Triangulate | aiProcess_FlipUVs);</span><br><span class="line">            <span class="comment">//调用Importer的ReadFile函数，这个函数需要一个文件路径，它的第二个参数是一些后期处理(Post-processing)的选项。</span></span><br><span class="line">            <span class="comment">//通过设定aiProcess_Triangulate，我们告诉Assimp，如果模型不是（全部）由三角形组成，它需要将模型所有的图元形状变换为三角形。aiProcess_FlipUVs将在处理的时候翻转y轴的纹理坐标</span></span><br><span class="line">            <span class="keyword">if</span>(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) &#123;</span><br><span class="line">                <span class="comment">//检查场景和根节点不为null，同时检查标记判断返回的数据是否完整；</span></span><br><span class="line">        		cout &lt;&lt; <span class="string">&quot;ERROR::ASSIMP::&quot;</span> &lt;&lt; <span class="keyword">import</span>.<span class="built_in">GetErrorString</span>() &lt;&lt; endl;<span class="comment">//否则报告错误；</span></span><br><span class="line">        		<span class="keyword">return</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    		directory = path.<span class="built_in">substr</span>(<span class="number">0</span>, path.<span class="built_in">find_last_of</span>(<span class="string">&#x27;/&#x27;</span>));<span class="comment">//获取文件路径的目录路径</span></span><br><span class="line">    		<span class="built_in">processNode</span>(scene-&gt;mRootNode, scene);<span class="comment">//将根节点传入递归的processNode函数来处理场景中所有节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用Assimp来加载模型至Assimp的一个叫做scene的数据结构中，这是Assimp数据接口的根对象。一旦我们有了这个场景对象，我们就能访问到加载后的模型中所有所需的数据了；</span></span><br><span class="line">    	<span class="comment">//实际上，我们完全可以直接遍历场景对象的所有网格，索引节点的原因是我们希望将网格之间定义一个父子关系，这样我们就可以移动父网格的时候带动子网格；然而我们现在并没有使用这种系统，毕竟现在类节点的关系由模型作者定义；</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">processNode</span><span class="params">(aiNode *node, <span class="type">const</span> aiScene *scene)</span></span>&#123;</span><br><span class="line">        	<span class="comment">// 处理节点所有的网格（如果有的话）</span></span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumMeshes; i++)&#123;</span><br><span class="line">        		aiMesh *mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]];<span class="comment">//节点的Meshes数组存储的是场景真正Meshes数组的索引 </span></span><br><span class="line">        		meshes.<span class="built_in">push_back</span>(<span class="built_in">processMesh</span>(mesh, scene));<span class="comment">//将获取到的网格传入processMesh函数中，该函数返回一个Mesh对象，我们将其存储在该Model类的成员数组中；</span></span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="comment">// 接下来对它的所有子节点重复这一过程</span></span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; node-&gt;mNumChildren; i++)&#123;</span><br><span class="line">        		<span class="built_in">processNode</span>(node-&gt;mChildren[i], scene);</span><br><span class="line">    		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Mesh <span class="title">processMesh</span><span class="params">(aiMesh* mesh, <span class="type">const</span> aiScene* scene)</span> </span>&#123;<span class="comment">//该函数将一个aiMesh对象转化为我们自己定义的网格对象；</span></span><br><span class="line">        	vector&lt;Vertex&gt; vertices;</span><br><span class="line">        	vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; indices;</span><br><span class="line">        	vector&lt;Texture&gt; textures;</span><br><span class="line"></span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumVertices; i++) &#123;</span><br><span class="line">            	Vertex vertex;</span><br><span class="line">            	<span class="comment">//处理顶点位置、法线和纹理坐标</span></span><br><span class="line">            	<span class="comment">//顶点位置</span></span><br><span class="line">            	glm::vec3 vector;</span><br><span class="line">            	vector.x = mesh-&gt;mVertices[i].x;</span><br><span class="line">            	vector.y = mesh-&gt;mVertices[i].y;</span><br><span class="line">            	vector.z = mesh-&gt;mVertices[i].z;</span><br><span class="line">            	vertex.Position = vector;</span><br><span class="line">            	<span class="comment">//法线</span></span><br><span class="line">            	vector.x = mesh-&gt;mNormals[i].x;</span><br><span class="line">            	vector.y = mesh-&gt;mNormals[i].y;</span><br><span class="line">            	vector.z = mesh-&gt;mNormals[i].z;</span><br><span class="line">            	vertex.Normal = vector;</span><br><span class="line">            	<span class="comment">//材质</span></span><br><span class="line">            	<span class="keyword">if</span> (mesh-&gt;mTextureCoords[<span class="number">0</span>]) &#123; <span class="comment">// 网格是否有纹理坐标？</span></span><br><span class="line">                	glm::vec2 vec;</span><br><span class="line">                	vec.x = mesh-&gt;mTextureCoords[<span class="number">0</span>][i].x;</span><br><span class="line">                	vec.y = mesh-&gt;mTextureCoords[<span class="number">0</span>][i].y;</span><br><span class="line">                	vertex.TexCoords = vec;</span><br><span class="line">            	&#125;</span><br><span class="line">                <span class="keyword">else</span> vertex.TexCoords = glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">            	vertices.<span class="built_in">push_back</span>(vertex);</span><br><span class="line">        		&#125;</span><br><span class="line">        	<span class="comment">//处理索引</span></span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mesh-&gt;mNumFaces; i++) &#123;</span><br><span class="line">            	aiFace face = mesh-&gt;mFaces[i];</span><br><span class="line">            	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; face.mNumIndices; j++)</span><br><span class="line">                	indices.<span class="built_in">push_back</span>(face.mIndices[j]);<span class="comment">//Assimp中每个网格都有一个face数组，一个face包含了多个索引，用来定义绘制哪个顶点以及顺序；</span></span><br><span class="line">        	&#125;</span><br><span class="line">        <span class="comment">//处理材质</span></span><br><span class="line">        	<span class="keyword">if</span> (mesh-&gt;mMaterialIndex &gt;= <span class="number">0</span>) &#123;<span class="comment">//类似节点，网格只包含了索引，要获取真正的材质需要访问场景的mMaterials数组</span></span><br><span class="line">            	aiMaterial* material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex];</span><br><span class="line">            	vector&lt;Texture&gt; diffuseMaps = <span class="built_in">loadMaterialTextures</span>(material, aiTextureType_DIFFUSE, <span class="string">&quot;texture_diffuse&quot;</span>);<span class="comment">//使用该函数获取纹理，并存储在textures的尾部</span></span><br><span class="line">            	textures.<span class="built_in">insert</span>(textures.<span class="built_in">end</span>(), diffuseMaps.<span class="built_in">begin</span>(), diffuseMaps.<span class="built_in">end</span>());</span><br><span class="line">            	vector&lt;Texture&gt; specularMaps = <span class="built_in">loadMaterialTextures</span>(material, aiTextureType_SPECULAR, <span class="string">&quot;texture_specular&quot;</span>);</span><br><span class="line">            	textures.<span class="built_in">insert</span>(textures.<span class="built_in">end</span>(), specularMaps.<span class="built_in">begin</span>(), specularMaps.<span class="built_in">end</span>());</span><br><span class="line">        	&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Mesh</span>(vertices, indices, textures);</span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="function">vector&lt;Texture&gt; <span class="title">loadMaterialTextures</span><span class="params">(aiMaterial* mat, aiTextureType type, string typeName)</span> </span>&#123;<span class="comment">//该函数用于从材质中获取纹理，它将会返回一个存储Texture结构体的vector</span></span><br><span class="line">        vector&lt;Texture&gt; textures;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; mat-&gt;<span class="built_in">GetTextureCount</span>(type); i++) &#123;<span class="comment">//用GetTextureCount函数检查储存在材质中指定类型纹理的数量</span></span><br><span class="line">            aiString str;</span><br><span class="line">            mat-&gt;<span class="built_in">GetTexture</span>(type, i, &amp;str);<span class="comment">//使用GetTexture获取每个纹理的文件位置，将结果储存在str中</span></span><br><span class="line">            <span class="type">bool</span> skip = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; textures_loaded.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (std::<span class="built_in">strcmp</span>(textures_loaded[j].path.<span class="built_in">data</span>(), str.<span class="built_in">C_Str</span>()) == <span class="number">0</span>) &#123;<span class="comment">//判断当前纹理的路径是否与已经加载过的相同</span></span><br><span class="line">                    textures.<span class="built_in">push_back</span>(textures_loaded[j]);</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;<span class="comment">//如果该纹理没有被加载过，则加载</span></span><br><span class="line">                Texture texture;</span><br><span class="line">                texture.id = <span class="built_in">TextureFromFile</span>(str.<span class="built_in">C_Str</span>(), directory);<span class="comment">//该函数将用stb_image.h加载一个纹理并返回该纹理的ID；</span></span><br><span class="line">                texture.type = typeName;</span><br><span class="line">                texture.path = str.<span class="built_in">C_Str</span>();</span><br><span class="line">                textures.<span class="built_in">push_back</span>(texture);</span><br><span class="line">                textures_loaded.<span class="built_in">push_back</span>(texture);<span class="comment">//添加到已加载的纹理中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textures;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">TextureFromFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> string&amp; directory)</span> </span>&#123;</span><br><span class="line">        string filename = <span class="built_in">string</span>(path);</span><br><span class="line">        filename = directory + <span class="string">&#x27;/&#x27;</span> + filename;</span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> textureID;</span><br><span class="line">        <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> width, height, nrComponents;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* data = <span class="built_in">stbi_load</span>(filename.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrComponents, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            GLenum format;</span><br><span class="line">            <span class="keyword">if</span> (nrComponents == <span class="number">1</span>)</span><br><span class="line">                format = GL_RED;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nrComponents == <span class="number">3</span>)</span><br><span class="line">                format = GL_RGB;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nrComponents == <span class="number">4</span>)</span><br><span class="line">                format = GL_RGBA;</span><br><span class="line">            <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureID);</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, format, width, height, <span class="number">0</span>, format, GL_UNSIGNED_BYTE, data);</span><br><span class="line">            <span class="built_in">glGenerateMipmap</span>(GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">            <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">            <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">            <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Texture failed to load at path: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> textureID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ReadFile函数一些其他后期处理参数：</p>
<ul>
<li>aiProcess_GenNormals：如果模型不包含法向量的话，就为每个顶点创建法线。</li>
<li>aiProcess_SplitLargeMeshes：将比较大的网格分割成更小的子网格，如果你的渲染有最大顶点数限制，只能渲染较小的网格，那么它会非常有用。</li>
<li>aiProcess_OptimizeMeshes：和上个选项相反，它会将多个小网格拼接为一个大的网格，减少绘制调用从而进行优化。</li>
<li><a target="_blank" rel="noopener" href="https://assimp.sourceforge.net/lib_html/postprocess_8h.html">https://assimp.sourceforge.net/lib_html/postprocess_8h.html</a> 全部后期处理指令</li>
</ul>
<h3 id="编译上的问题"><a href="#编译上的问题" class="headerlink" title="编译上的问题"></a>编译上的问题</h3><p>不应该将#define STB_IMAGE_IMPLEMENTATION放在头文件中，而是将它们放在使用它们的源文件中。如果将#define STB_IMAGE_IMPLEMENTATION放在标头中，则会在包含该标头的所有文件中对其进行定义，从而导致重复符号错误，因为定义该标头时会重新实现stb_image。</p>
<h2 id="高级OpenGL"><a href="#高级OpenGL" class="headerlink" title="高级OpenGL"></a>高级OpenGL</h2><h3 id="深度测试"><a href="#深度测试" class="headerlink" title="深度测试"></a>深度测试</h3><p>深度缓冲就像颜色缓冲一样，在每个片元中储存了信息；深度缓冲是窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值；在大部分的系统中，深度缓冲的精度都是24位的；</p>
<p>当深度测试启用，OpenGL会将一个片元的深度值与深度缓冲的内容进行对比；OpenGL会执行一个深度测试，如果这个测试通过，深度缓冲将会更新为新的深度值；若深度测试失败，片元将会不被渲染；</p>
<p>深度缓冲是在片元着色器运行之后(以及模板测试运行之后)在屏幕空间运行的；屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且<strong>可以直接用GLSL内建变量gl_FragCoord从片元着色器中直接访问</strong>；gl_FragCoord的x和y分量代表了片元的屏幕空间坐标((0,0)位于左下角)；gl_FragCoord包含了一个z分量，包含了片元真正的深度值；z值就是需要与深度缓冲对比的值；</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230114150134304.png" alt="image-20230114150134304"></p>
<p>如果你启用了深度缓冲，你还应该在每个渲染迭代之前使用GL_DEPTH_BUFFER_BIT来清除深度缓冲，否则你会仍在使用上一次渲染迭代中的写入的深度值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure>

<p>在某些情况下你会需要对所有片元都执行深度测试并丢弃相应的片元，但<strong>不</strong>希望更新深度缓冲。基本上来说，你在使用一个只读的(Read-only)深度缓冲。OpenGL允许我们禁用深度缓冲的写入，只需要设置它的深度掩码(Depth Mask)设置为<code>GL_FALSE</code>就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDepthMask(GL_FALSE);</span><br></pre></td></tr></table></figure>

<h4 id="深度测试函数"><a href="#深度测试函数" class="headerlink" title="深度测试函数"></a>深度测试函数</h4><p>OpenGL允许我们修改深度测试的比较内容，让我们可以控制什么时候该通过或丢弃一个片元，什么时候去更新深度缓冲；我们可以使用glDepthFunc函数来设置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDepthFunc</span>(GL_LESS);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GL_ALWAYS	永远通过深度测试</span></span><br><span class="line"><span class="comment">GL_NEVER	永远不通过深度测试</span></span><br><span class="line"><span class="comment">GL_LESS		在片段深度值小于缓冲的深度值时通过测试</span></span><br><span class="line"><span class="comment">GL_EQUAL	在片段深度值等于缓冲区的深度值时通过测试</span></span><br><span class="line"><span class="comment">GL_LEQUAL	在片段深度值小于等于缓冲区的深度值时通过测试</span></span><br><span class="line"><span class="comment">GL_GREATER	在片段深度值大于缓冲区的深度值时通过测试</span></span><br><span class="line"><span class="comment">GL_NOTEQUAL	在片段深度值不等于缓冲区的深度值时通过测试</span></span><br><span class="line"><span class="comment">GL_GEQUAL	在片段深度值大于等于缓冲区的深度值时通过测试</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h4><p>深度缓冲包含了一个[0,1]的深度值，他将会与观察者视角所看见的场景中所有物体的z值进行比较；<strong>观察空间的z值可能是投影平截头体近平面到远平面之间的任何值</strong>；因此我们需要一种方式来将这些值变换到[0,1]范围；其中一种方式就是线性变换：<br>$$<br>F_{depth}&#x3D;\frac{z-near}{far-near}<br>$$<br>不过在实践中，我们永远不会使用这样的线性深度缓冲；要想有正确的投影性质，需要使用一个非线性的深度方程，它是与1&#x2F;z成正比的；<strong>在z值很小的时候提供非常高的精度，而在z值很远的时候提供更少的精度</strong>；因为我们不需要对1000单位远的深度值和只有1深度值的充满细节的物体使用相同的精度；</p>
<p>由于非线性方程与 1&#x2F;z 成正比，在1.0和2.0之间的z值将会变换至1.0到0.5之间的深度值，这就是一个float提供给我们的一半精度了，这在z值很小的情况下提供了非常大的精度。在50.0和100.0之间的z值将会只占2%的float精度，这正是我们所需要的。这样的一个考虑了远近距离的方程是这样的：<br>$$<br>F_{depth}&#x3D;\frac{1&#x2F;z-1&#x2F;near}{1&#x2F;far-1&#x2F;near}<br>$$<br>因此深度缓冲中的值<strong>在屏幕空间中不是线性的</strong>（在<strong>透视矩阵应用之前</strong>在观察空间中是<strong>线性的</strong>）</p>
<p>z值和最终的深度缓冲值之间的非线性关系：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230114163303147.png" alt="image-20230114163303147"></p>
<p>深度值很大一部分是由很小的z值所决定的，这给了近处的物体很大的深度精度。<strong>这个（从观察者的视角）变换z值的方程是嵌入在投影矩阵中的，所以当我们想将一个顶点坐标从观察空间至裁剪空间的时候这个非线性方程就被应用了</strong>。</p>
<p>更多细节：<a target="_blank" rel="noopener" href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p>
<h4 id="深度缓冲的可视化"><a href="#深度缓冲的可视化" class="headerlink" title="深度缓冲的可视化"></a>深度缓冲的可视化</h4><p>数学推导详见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/128028758%EF%BC%9B">https://zhuanlan.zhihu.com/p/128028758；</a></p>
<h4 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h4><p>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，<strong>深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序</strong>，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</p>
<p>深度冲突是深度缓冲的一个常见问题，当物体在远处时效果会更明显（因为深度缓冲在z值比较大的时候有着更小的精度）。深度冲突不能够被完全避免，但一般会有一些技巧有助于在你的场景中减轻或者完全避免深度冲突：</p>
<ul>
<li><strong>不要把多个物体摆的太近</strong>，以至于它们的一些三角形会重叠；例如将物体向上移动一个用户无法注意到的偏移值，让他不要和地面紧贴；</li>
<li><strong>将近平面设置远一些</strong>，精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。</li>
<li>牺牲一些性能，<strong>使用更高精度的深度缓冲</strong>。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</li>
</ul>
<h3 id="模板测试"><a href="#模板测试" class="headerlink" title="模板测试"></a>模板测试</h3><p>当片元着色器处理完一个片元后，<strong>模板测试会在深度测试之前执行；模板测试是根据模板缓冲来进行的</strong>，我们可以在渲染的时候更新它来获得一些很有意思的效果；</p>
<p>（通常）每个模板值(Stencil Value)是8位的。所以每个像素&#x2F;片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230115142747883.png" alt="image-20230115142747883"></p>
<p>模板缓冲的一个简单的例子如下：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230115142832372.png" alt="image-20230115142832372"></p>
<p>模板缓冲首先会被清除为0，之后在模板缓冲中使用1填充了一个空心矩形。场景中的片段将会只在片段的模板值为1的时候会被渲染（其它的都被丢弃了）。</p>
<p>模板缓冲操作允许我们在渲染片段时将模板缓冲设定为一个特定的值。通过在渲染时修改模板缓冲的内容，我们<strong>写入</strong>了模板缓冲。在同一个（或者接下来的）渲染迭代中，我们可以<strong>读取</strong>这些值，来决定丢弃还是保留某个片段。使用模板缓冲的时候你可以尽情发挥，但大体的步骤如下：</p>
<ul>
<li>启用模板缓冲的写入。</li>
<li>渲染物体，更新模板缓冲的内容。</li>
<li>禁用模板缓冲的写入。</li>
<li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li>
</ul>
<p>所以，通过使用模板缓冲，我们可以根据场景中已绘制的其它物体的片段，来决定是否丢弃特定的片段。</p>
<p>可以启用GL_STENCIL_TEST来启用模板测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_STENCIL_TEST);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<span class="comment">//同理，每次迭代之前需要清除模板缓冲</span></span><br></pre></td></tr></table></figure>

<p>类似深度测试的glDepthMask，模板缓冲也有设置位掩码的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位掩码会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>); <span class="comment">// 每一位写入模板缓冲时都保持原样</span></span><br><span class="line"><span class="built_in">glStencilMask</span>(<span class="number">0x00</span>); <span class="comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span></span><br></pre></td></tr></table></figure>

<h4 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h4><p>配置模板测试的两个函数：glStencilFunc，glStencilOp;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glStencilFunc</span>(GLenum func, GLint ref, GLuint mask);</span><br><span class="line"><span class="comment">//func:设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。</span></span><br><span class="line"><span class="comment">//ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</span></span><br><span class="line"><span class="comment">//mask: 设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glStencilFunc</span>(GL_EQUAL,<span class="number">1</span>,<span class="number">0xFF</span>);<span class="comment">//只要片元的模板值等于参考值1，片元将通过测试，否则丢弃；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glStencilOp</span>(GLenum sfail, GLenum dpfail, GLenum dppass);</span><br><span class="line"><span class="comment">//sfail: 模板测试失败时采取的行为；</span></span><br><span class="line"><span class="comment">//dpfail: 模板测试失败，蛋深度测试失败时采取的行为；</span></span><br><span class="line"><span class="comment">//dppass: 模板测试和深度测试都通过时采取的行为；</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">行为：</span></span><br><span class="line"><span class="comment">GL_KEEP	保持当前储存的模板值</span></span><br><span class="line"><span class="comment">GL_ZERO	将模板值设置为0</span></span><br><span class="line"><span class="comment">GL_REPLACE	将模板值设置为glStencilFunc函数设置的ref值</span></span><br><span class="line"><span class="comment">GL_INCR	如果模板值小于最大值则将模板值加1</span></span><br><span class="line"><span class="comment">GL_INCR_WRAP	与GL_INCR一样，但如果模板值超过了最大值则归零</span></span><br><span class="line"><span class="comment">GL_DECR	如果模板值大于最小值则将模板值减1</span></span><br><span class="line"><span class="comment">GL_DECR_WRAP	与GL_DECR一样，但如果模板值小于0则将其设置为最大值</span></span><br><span class="line"><span class="comment">GL_INVERT	按位翻转当前的模板缓冲值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//默认情况下设置为(GL_KEEP,GL_KEEP,GL_KEEP)</span></span><br></pre></td></tr></table></figure>

<h4 id="物体轮廓"><a href="#物体轮廓" class="headerlink" title="物体轮廓"></a>物体轮廓</h4><p>我们将会为每个（或者一个）物体在它的周围创建一个很小的有色边框。当你想要在策略游戏中选中一个单位进行操作的，想要告诉玩家选中的是哪个单位的时候，这个效果就非常有用了。为物体创建轮廓的步骤如下：</p>
<ol>
<li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。</li>
<li>渲染物体。</li>
<li>禁用模板写入以及深度测试。</li>
<li>将每个物体缩放一点点。</li>
<li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li>
<li>再次绘制物体，但只在它们片段的模板值不等于1时才绘制。</li>
<li>再次启用模板写入和深度测试。</li>
</ol>
<p>这个过程将每个物体的片段的模板缓冲设置为1，当我们想要绘制边框的时候，我们主要绘制放大版本的物体中模板测试通过的部分，也就是物体的边框的位置。我们主要使用模板缓冲丢弃了放大版本中属于原物体片段的部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">glEnable</span>(GL_STENCIL_TEST);</span><br><span class="line"><span class="built_in">glStencilFunc</span>(GL_NOTEQUAL, <span class="number">1</span>, <span class="number">0xFF</span>);</span><br><span class="line"><span class="built_in">glStencilOp</span>(GL_KEEP, GL_KEEP, GL_REPLACE);<span class="comment">//当模板和深度测试都通过时将模板值设置为ref值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">    <span class="type">float</span> currentFrame = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">glfwGetTime</span>());</span><br><span class="line">    deltaTime = currentFrame - lastFrame;</span><br><span class="line">    lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processInput</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    shaderNor.<span class="built_in">use</span>();</span><br><span class="line">    glm::mat4 model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    glm::mat4 view = camera.<span class="built_in">GetViewMatrix</span>();</span><br><span class="line">    glm::mat4 projection = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(camera.Zoom), (<span class="type">float</span>)SCR_WIDTH / (<span class="type">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.f</span>);</span><br><span class="line">    shaderNor.<span class="built_in">setMat</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    shaderNor.<span class="built_in">setMat</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">    shader.<span class="built_in">use</span>();</span><br><span class="line">    shader.<span class="built_in">setMat</span>(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    shader.<span class="built_in">setMat</span>(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glStencilMask</span>(<span class="number">0x00</span>);<span class="comment">//关闭模板缓冲写入</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(planeVAO);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, floorTexture);</span><br><span class="line">    shader.<span class="built_in">setMat</span>(<span class="string">&quot;model&quot;</span>, glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>));</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);<span class="comment">//绘制地板</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glStencilFunc</span>(GL_ALWAYS, <span class="number">1</span>, <span class="number">0xFF</span>);<span class="comment">//片元会永远通过模板测试，在绘制片元的地方，模板缓冲会更新为参考值</span></span><br><span class="line">    <span class="built_in">glStencilMask</span>(<span class="number">0xFF</span>);<span class="comment">//启用模板缓冲写入</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, cubeTexture);</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line">    shader.<span class="built_in">setMat</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    shader.<span class="built_in">setMat</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);<span class="comment">//绘制两个箱子</span></span><br><span class="line">    <span class="comment">//现在绘制箱子的地方模板缓冲都更新为1了</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glStencilFunc</span>(GL_NOTEQUAL, <span class="number">1</span>, <span class="number">0xFF</span>);<span class="comment">//只绘制模板缓冲不等于1的片元</span></span><br><span class="line">    </span><br><span class="line">    shaderNor.<span class="built_in">use</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(cubeVAO);</span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, cubeTexture);</span><br><span class="line">    model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>));</span><br><span class="line">    model = glm::<span class="built_in">scale</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">1.1f</span>, <span class="number">1.1f</span>, <span class="number">1.1f</span>));</span><br><span class="line">    shaderNor.<span class="built_in">setMat</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    model = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    model = glm::<span class="built_in">scale</span>(model, glm::<span class="built_in">vec3</span>(<span class="number">1.1f</span>, <span class="number">1.1f</span>, <span class="number">1.1f</span>));</span><br><span class="line">    shaderNor.<span class="built_in">setMat</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);<span class="comment">//绘制边框</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">    <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><p>OpenGL中，混合(blending)通常是实现物体透明度的一种技术；即一个物体的颜色是物体本身的颜色和他背后其他物体颜色的不同强度混合：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230116142621521.png" alt="image-20230116142621521"></p>
<p>一个物体的透明度是通过它颜色的alpha值来决定的。Alpha颜色值是颜色向量的第四个分量。在这个教程之前我们都将这个第四个分量设置为1.0，让这个物体的透明度为0.0，而当alpha值为0.0时物体将会是完全透明的。当alpha值为0.5时，物体的颜色有50%是来自物体自身的颜色，50%来自背后物体的颜色。</p>
<h4 id="丢弃片段"><a href="#丢弃片段" class="headerlink" title="丢弃片段"></a>丢弃片段</h4><p>有些图片并不需要半透明，只需要根据纹理的颜色值，显示一部分，或者不显示一部分，没有中间情况，比如这个草：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/03/grass.png" alt="img"></p>
<p>如果想不太费劲地创建草这种东西，你需要将一个草的纹理贴在一个2D四边形(Quad)上，然后将这个四边形放到场景中。然而，草的形状和2D四边形的形状并不完全相同，所以你只想显示草纹理的某些部分，而忽略剩下的部分。</p>
<p>要想加载有alpha值的纹理并不复杂，stb_image在纹理有alpha通道的时候会自动加载，但我们仍要在纹理生成过程中告诉OpenGL，我们的纹理现在使用alpha通道了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样，需要在片元着色器中获取纹理的全部四个颜色分量，而不仅仅是RGB分量；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// FragColor = vec4(vec3(texture(texture1, TexCoords)), 1.0);</span></span><br><span class="line">    FragColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是OpenGL默认不知道如何处理alpha值，也不知道何时丢弃片元，我们会得到这样的结果：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230116152150958.png" alt="image-20230116152150958"></p>
<p>因此需要我们使用着色器的<strong>discard</strong>命令：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">vec4</span> texColor = <span class="built_in">texture</span>(texture1, TexCoords);</span><br><span class="line">    <span class="keyword">if</span>(texColor.a &lt; <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">discard</span>;<span class="comment">//调用该命令后片元不会被进一步处理</span></span><br><span class="line">    FragColor = texColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230116152540241.png" alt="image-20230116152540241"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当使用alpha纹理时，设置为GL_CLAMP_TO_EDGE，否则纹理图像顶部将会与底部边缘的纯色之进行插值，得到一个半透明的有色边框；</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, format == GL_RGBA ? GL_CLAMP_TO_EDGE : GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, format == GL_RGBA ? GL_CLAMP_TO_EDGE : GL_REPEAT);</span><br></pre></td></tr></table></figure>

<h4 id="混合-1"><a href="#混合-1" class="headerlink" title="混合"></a>混合</h4><p>要想渲染有多个透明度级别的图像，我们需要启用混合(blend)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_BLEND);</span><br></pre></td></tr></table></figure>

<p>OpenGL中的混合通过如下方程实现：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230116153338650.png" alt="image-20230116153338650"></p>
<p><strong>当片元着色器运行完成，并且所有测试都通过后，这个混合方程才会应用</strong>到片元颜色输出与当前颜色缓冲的值上；而源因子和目标因子值可以自定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBlendFunc</span>(GLenum sfactor, GLenum dfactor);</span><br><span class="line"><span class="comment">//两个参数分别设置源和目标因子，参数列表如下；</span></span><br><span class="line"><span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line"><span class="comment">//通常使用源颜色向量的alpha作为源因子，使用1−alpha作为目标因子；</span></span><br><span class="line"><span class="built_in">glBlendFuncSeparate</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);</span><br><span class="line"><span class="comment">//这个函数允许我们为RGB和alpha通道设置不同的选项</span></span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230116153657793.png" alt="image-20230116153657793"></p>
<p>与此同时，OpenGL甚至给了我们更多的灵活性，<strong>允许我们改变方程中源和目标部分的运算符</strong>。当前源和目标是相加的，但如果愿意的话，我们也可以让它们相减。glBlendEquation(GLenum mode)允许我们设置运算符，它提供了三个选项：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230116154427035.png" alt="image-20230116154427035"></p>
<h4 id="渲染半透明纹理"><a href="#渲染半透明纹理" class="headerlink" title="渲染半透明纹理"></a>渲染半透明纹理</h4><p>我们打开混合设置，将草换成玻璃的纹理：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230116155213013.png" alt="image-20230116155213013"></p>
<p>此时我们发现玻璃不正常的挡住了后面的玻璃；这是因为深度测试和混合一起使用造成的问题；</p>
<p>当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。</p>
<p>因此我们<strong>必须保证渲染的时候首先渲染最远的窗户，这样他才不会被深度测试所抛弃</strong>；</p>
<p>如图，同一场景，反过来观察就正常了，因为前面(现在在后面)的窗户先被渲染了；</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230116155458899.png" alt="如果反过来观察则正常；"></p>
<h4 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h4><p>当绘制一个有不透明和透明物体的场景时，大致原则如下：</p>
<ol>
<li>先绘制所有不透明的物体。</li>
<li>对所有透明的物体排序。</li>
<li>按顺序绘制所有透明的物体。</li>
</ol>
<p>排序透明物体的一种方法是，<strong>从观察者视角获取物体的距离。这可以通过计算摄像机位置向量和物体的位置向量之间的距离所获得</strong>。接下来我们把距离和它对应的位置向量存储到一个STL库的map数据结构中。<strong>map会自动根据键值(Key)对它的值排序</strong>，所以只要我们添加了所有的位置，并以它的距离作为键，它们就会自动根据距离值排序了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">float</span>, glm::vec3&gt; sorted;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; windows.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> distance = glm::<span class="built_in">length</span>(camera.Position - windows[i]);<span class="comment">//计算摄像机到每个窗户的位置；</span></span><br><span class="line">    sorted[distance] = windows[i];</span><br><span class="line">&#125;<span class="comment">//我们得到了一个排序后的容器，根据距离从低到高储存了每个窗户的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(std::map&lt;<span class="type">float</span>,glm::vec3&gt;::reverse_iterator it = sorted.<span class="built_in">rbegin</span>(); it != sorted.<span class="built_in">rend</span>(); ++it) </span><br><span class="line">&#123;</span><br><span class="line">    model = glm::<span class="built_in">mat4</span>();</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, it-&gt;second);              </span><br><span class="line">    shader.<span class="built_in">setMat4</span>(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">&#125;<span class="comment">//渲染时我们由远至近绘制对应的窗户；</span></span><br></pre></td></tr></table></figure>

<p>虽然按照距离排序物体这种方法对我们这个场景能够正常工作，但它并没有考虑旋转、缩放或者其它的变换，奇怪形状的物体需要一个不同的计量，而不是仅仅一个位置向量。比如一个物体自己的一部分遮挡了自己另一部分的情况；</p>
<p>在场景中排序物体是一个很困难的技术，很大程度上由你场景的类型所决定，更别说它额外需要消耗的处理能力了。完整渲染一个包含不透明和透明物体的场景并不是那么容易。更高级的技术还有次序无关透明度(Order Independent Transparency, OIT)等；</p>
<h3 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h3><p>OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们，而丢弃那些背向(Back Facing)的面；这样能节省我们很多的片元着色器调用；</p>
<p>但我们仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，**分析顶点数据的环绕顺序(Winding Order)**。</p>
<h4 id="环绕顺序"><a href="#环绕顺序" class="headerlink" title="环绕顺序"></a>环绕顺序</h4><p>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，我们会从三角形中间来看，为这3个顶点设定一个环绕顺序。</p>
<p><img src="https://learnopengl-cn.github.io/img/04/04/faceculling_windingorder.png" alt="img"></p>
<p>每组组成三角形图元的三个顶点就包含了一个环绕顺序。<strong>OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形</strong>。默认情况下，<strong>逆时针顶点所定义的三角形将会被处理为正向三角形</strong>。</p>
<p>当你定义顶点顺序的时候，你应该想象对应的三角形是面向你的，所以<strong>你定义的三角形从正面看去应该是逆时针的</strong>。这样定义顶点很棒的一点是，实际的环绕顺序是在光栅化阶段进行的，也就是顶点着色器运行之后。这些顶点就是从<strong>观察者视角</strong>所见的了。</p>
<p>观察者所面向的所有三角形顶点就是我们所指定的正确环绕顺序了，而立方体另一面的三角形顶点则是以相反的环绕顺序所渲染的。这样的结果就是，我们所面向的三角形将会是正向三角形，而背面的三角形则是背向三角形。</p>
<p><img src="https://learnopengl-cn.github.io/img/04/04/faceculling_frontback.png" alt="img"></p>
<p>在顶点数据中，我们将两个三角形都以逆时针顺序定义（正面的三角形是1、2、3，背面的三角形也是1、2、3（如果我们从正面看这个三角形的话））。然而，如果从观察者当前视角使用1、2、3的顺序来绘制的话，从观察者的方向来看，背面的三角形将会是以顺时针顺序渲染的。虽然背面的三角形是以逆时针定义的，它现在是以顺时针顺序渲染的了。这正是我们想要剔除（Cull，丢弃）的不可见面了！</p>
<h4 id="面剔除-1"><a href="#面剔除-1" class="headerlink" title="面剔除"></a>面剔除</h4><p>要想启用面剔除，我们只需要启用OpenGL的GL_CULL_FACE选项：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_CULL_FACE);</span><br></pre></td></tr></table></figure>

<p>从这一句代码之后，所有背向面都将被丢弃；</p>
<p>但注意<strong>这只对像立方体这样的封闭形状有效</strong>。当我们想要绘制之前的草时，我们必须要再次禁用面剔除，因为它们的正向面和背向面都应该是可见的。</p>
<p>OpenGL允许我们改变需要剔除的面的类型。也允许我们自行定义正向面；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"><span class="comment">/*GL_BACK：只剔除背向面。</span></span><br><span class="line"><span class="comment">GL_FRONT：只剔除正向面。</span></span><br><span class="line"><span class="comment">GL_FRONT_AND_BACK：剔除正向面和背向面。*/</span></span><br><span class="line"><span class="built_in">glFrontFace</span>(GL_CCW);</span><br><span class="line"><span class="comment">/*GL_CCW: 逆时针是正向面</span></span><br><span class="line"><span class="comment">GL_CW: 顺时针是正向面*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到，面剔除是一个提高OpenGL程序性能的很棒的工具。但你需要记住哪些物体能够从面剔除中获益，而哪些物体不应该被剔除。</p>
<p><strong>因此如果想使用面剔除，如果是手动定义顶点，必须提前规定好方向；</strong>如果使用软件，3D建模软件自动生成的,它们的顶点顺序生成时就可以保证了是逆时针的了；</p>
<h3 id="帧缓冲"><a href="#帧缓冲" class="headerlink" title="帧缓冲"></a>帧缓冲</h3><p>用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。**这些缓冲结合起来叫做帧缓冲(Framebuffer)**，它被储存在内存中。OpenGL允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。</p>
<p>我们<strong>目前所做的所有操作都是在默认帧缓冲的渲染缓冲上进行的。默认的帧缓冲是在你创建窗口的时候生成和配置的</strong>（GLFW帮我们做了这些）。有了我们自己的帧缓冲，我们就能够有更多方式来渲染了。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fbo;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;fbo);<span class="comment">//创建</span></span><br><span class="line"><span class="built_in">glBinFramebuffer</span>(GL_FRAMEBUFFER, fbo);<span class="comment">//绑定为激活的帧缓冲</span></span><br><span class="line"><span class="comment">//此后所有读取和写入帧缓冲的操作会影响当前绑定的帧缓冲；</span></span><br><span class="line"><span class="comment">//也可以使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER参数，将一个帧缓冲分别绑定到读取目标或写入目标。</span></span><br><span class="line"><span class="comment">//绑定到GL_READ_FRAMEBUFFER的帧缓冲将会使用在所有像是glReadPixels的读取操作中，而绑定到GL_DRAW_FRAMEBUFFER的帧缓冲将会被用作渲染、清除等写入操作的目标。</span></span><br></pre></td></tr></table></figure>

<p>不过当前帧缓冲还不能被使用，因为他不完整，一个完整的帧缓冲需要满足以下条件：</p>
<ul>
<li>附加至少一个缓冲(颜色、深度或模板)；</li>
<li>至少有一个颜色附件(Attachment)；</li>
<li>所有的附件都必须是完整的(保留了内存)；</li>
<li>每个缓冲都应该有相同的样本数；(抗锯齿一节中会提到)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)</span><br><span class="line"><span class="comment">//完成条件后可以这样检查帧缓冲是否完整，这个函数会检测当前绑定的帧缓冲；</span></span><br></pre></td></tr></table></figure>

<p>因此我们需要为帧缓冲创建一些附件并附加到帧缓冲上；之后的所有渲染操作会渲染到当前绑定帧缓冲的附件中；<strong>附件是一个内存位置，它能够作为帧缓冲的一个缓冲，可以将它想象为一个图像</strong>。当创建一个附件的时候我们有两个选项：**纹理或渲染缓冲对象(Renderbuffer Object)**。</p>
<p>由于我们的帧缓冲不是默认帧缓冲，渲染指令不会影响窗口的视觉输出；**渲染到不同的帧缓冲被叫做离屏渲染(Off-screen Rendering)**；</p>
<p>要保证所有的渲染操作在主窗口中有视觉效果，我们需要再次激活默认帧缓冲，将它绑定到<code>0</code>。</p>
<p>(个人理解：帧缓冲是作为默认帧缓冲的一种辅助效果来使用，不会直接取代真正的渲染结果而是附加在之上)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//在完成所有的帧缓冲操作之后，不要忘记删除这个帧缓冲对象：</span></span><br><span class="line"><span class="built_in">glDeleteFramebuffers</span>(<span class="number">1</span>, &amp;fbo);</span><br></pre></td></tr></table></figure>

<h4 id="纹理附件"><a href="#纹理附件" class="headerlink" title="纹理附件"></a>纹理附件</h4><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入这个纹理中，使用纹理的优点是，<strong>所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它</strong>。</p>
<p>为帧缓冲创建一个纹理和创建一个普通的纹理差不多：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texture;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//主要区别在于我们把维度设置为了屏幕大小，并且data参数处传递了NULL，这代表我们仅分配了内存而没有填充他；</span></span><br><span class="line"><span class="comment">//填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="number">0</span>);<span class="comment">//将纹理附加到帧缓冲上；</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数的参数列表：</span></span><br><span class="line"><span class="comment">target：帧缓冲的目标（绘制、读取或者两者皆有）</span></span><br><span class="line"><span class="comment">attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。我们将在之后的教程中提到。</span></span><br><span class="line"><span class="comment">textarget：你希望附加的纹理类型</span></span><br><span class="line"><span class="comment">texture：要附加的纹理本身</span></span><br><span class="line"><span class="comment">level：多级渐远纹理的级别。我们将它保留为0。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230118154846675.png" alt="image-20230118154846675"></p>
<p>除了颜色附件之外，我们还可以附加一个深度和模板缓冲纹理到帧缓冲对象中。要附加深度缓冲的话，我们将附件类型设置为GL_DEPTH_ATTACHMENT。注意纹理的格式(Format)和内部格式(Internalformat)类型将变为GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。要附加模板缓冲的话，你要将第二个参数设置为GL_STENCIL_ATTACHMENT，并将纹理的格式设定为GL_STENCIL_INDEX。</p>
<p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每32位数值将包含24位的深度信息和8位的模板信息。要将深度和模板缓冲附加为一个纹理的话，我们使用GL_DEPTH_STENCIL_ATTACHMENT类型，并配置纹理的格式，让它包含合并的深度和模板值。将一个深度和模板缓冲附加为一个纹理到帧缓冲的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(</span><br><span class="line">  GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, </span><br><span class="line">  GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="渲染缓冲对象附件"><a href="#渲染缓冲对象附件" class="headerlink" title="渲染缓冲对象附件"></a>渲染缓冲对象附件</h4><p>渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到OpenGL中，作为一个可用的帧缓冲附件类型的，所以在过去纹理是唯一可用的附件。和纹理图像一样，<strong>渲染缓冲对象是一个真正的缓冲</strong>，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，<strong>它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的</strong>。</p>
<p>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用glReadPixels来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。</p>
<p>因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。<strong>我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现</strong>：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rbo;</span><br><span class="line"><span class="built_in">glGenRenderbuffers</span>(<span class="number">1</span>, &amp;rbo);<span class="comment">//创建一个渲染缓冲对象</span></span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, rbo);<span class="comment">//绑定渲染缓冲对象，让之后所有的渲染缓冲操作影响当前的rbo;</span></span><br></pre></td></tr></table></figure>

<p>由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为<strong>大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试</strong>。我们<strong>需要</strong>深度和模板值用于测试，但不需要对它们进行<strong>采样</strong>，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p>
<p><strong>创建一个深度和模板渲染缓冲对象</strong>可以通过调用glRenderbufferStorage函数来完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个渲染缓冲对象和纹理对象类似，不同的是这个对象是专门被设计作为帧缓冲附件使用的，而不是纹理那样的通用数据缓冲(General Purpose Data Buffer)。这里我们选择GL_DEPTH24_STENCIL8作为内部格式，它封装了24位的深度和8位的模板缓冲。</p>
<p>最后一件事就是附加这个渲染缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);</span><br></pre></td></tr></table></figure>

<p>渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，<strong>如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件</strong>。性能方面它不会产生非常大的影响的。</p>
<h4 id="渲染到纹理"><a href="#渲染到纹理" class="headerlink" title="渲染到纹理"></a>渲染到纹理</h4><p>我们将会<strong>将场景渲染到一个附加到帧缓冲对象上的颜色纹理中</strong>，之后将在一个<strong>横跨整个屏幕的四边形</strong>上绘制这个纹理。这样视觉输出和没使用帧缓冲时是完全一样的，但这次是打印到了一个四边形上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> framebuffer;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;framebuffer);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, framebuffer);<span class="comment">//创建并绑定帧缓冲对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> texColorBuffer;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texColorBuffer);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texColorBuffer);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, <span class="number">800</span>, <span class="number">600</span>, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, <span class="number">0</span>);<span class="comment">//创建并绑定一个纹理；</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, <span class="number">0</span>);<span class="comment">// 将它附加到当前绑定的帧缓冲对象</span></span><br></pre></td></tr></table></figure>

<p>另外我们还要添加一个深度附件到帧缓冲中，因为我们不需要采样深度缓冲，因此渲染缓冲对象是更好的选择：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> rbo;</span><br><span class="line"><span class="built_in">glGenRenderbuffers</span>(<span class="number">1</span>, &amp;rbo);</span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, rbo);<span class="comment">//创建绑定渲染缓冲对象</span></span><br><span class="line"><span class="built_in">glRenderbufferStorage</span>(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="number">800</span>, <span class="number">600</span>);<span class="comment">//创建深度和模板附件，使用GL_DEPTH24_STENCIL8的精度</span></span><br><span class="line"><span class="built_in">glBindRenderbuffer</span>(GL_RENDERBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glFramebufferRenderbuffer</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<span class="comment">//将渲染缓冲对象附加到帧缓冲的深度和模板附件上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)<span class="comment">//检查帧缓冲是否完整</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ERROR::FRAMEBUFFER:: Framebuffer is not complete!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);<span class="comment">//解绑帧缓冲，保证不会渲染到错误的帧缓冲上</span></span><br></pre></td></tr></table></figure>

<p>所以，要想绘制场景到一个纹理上，我们需要采取以下的步骤：</p>
<ol>
<li>将新的帧缓冲绑定为激活的帧缓冲，和往常一样渲染场景</li>
<li>绑定默认的帧缓冲</li>
<li>绘制一个横跨整个屏幕的四边形，将帧缓冲的颜色缓冲作为它的纹理。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一处理阶段(Pass)</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, framebuffer);</span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="comment">// 我们现在不使用模板缓冲</span></span><br><span class="line"><span class="built_in">glEnable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">DrawScene</span>();    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二处理阶段</span></span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>); <span class="comment">// 返回默认</span></span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>); </span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">screenShader.<span class="built_in">use</span>();  </span><br><span class="line"><span class="built_in">glBindVertexArray</span>(quadVAO);</span><br><span class="line"><span class="built_in">glDisable</span>(GL_DEPTH_TEST);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textureColorbuffer);</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);  </span><br></pre></td></tr></table></figure>

<p>个人遇到问题：别忘了给新的shader设置新的顶点着色器，因为只渲染一个平面，使用矩阵会导致错误；</p>
<h3 id="后期处理"><a href="#后期处理" class="headerlink" title="后期处理"></a>后期处理</h3><p>既然整个场景都被渲染到了一个纹理上，我们可以简单地通过修改纹理数据创建出一些非常有意思的效果。</p>
<h4 id="反相"><a href="#反相" class="headerlink" title="反相"></a>反相</h4><p>我们现在能够访问渲染输出的每个颜色，所以在（译注：屏幕的）片段着色器中返回这些颜色的反相(Inversion)并不是很难。我们将会从屏幕纹理中取颜色值，然后用1.0减去它，对它进行反相：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="type">vec3</span>(<span class="number">1.0</span> - <span class="built_in">texture</span>(screenTexture, TexCoords)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230119164059623.png" alt="image-20230119164059623"></p>
<h4 id="灰度"><a href="#灰度" class="headerlink" title="灰度"></a>灰度</h4><p>移除场景中除了黑白灰以外所有的颜色，让整个图像灰度化(Grayscale)。很简单的实现方式是，取所有的颜色分量，将它们平均化：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(screenTexture, TexCoords);</span><br><span class="line">    <span class="type">float</span> average = <span class="number">0.2126</span> * FragColor.r + <span class="number">0.7152</span> * FragColor.g + <span class="number">0.0722</span> * FragColor.b;</span><br><span class="line">    <span class="comment">//人眼会对绿色更加敏感一些，而对蓝色不那么敏感，所以为了获取物理上更精确的效果，我们需要使用加权的(Weighted)通道</span></span><br><span class="line">    FragColor = <span class="type">vec4</span>(average, average, average, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230119164234502.png" alt="image-20230119164234502"></p>
<h4 id="核效果"><a href="#核效果" class="headerlink" title="核效果"></a>核效果</h4><p>在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。我们可以结合它们创建出很有意思的效果。</p>
<p>核(Kernel)（或卷积矩阵(Convolution Matrix)）是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。所以，基本上我们是在对当前像素周围的纹理坐标添加一个小的偏移量，并根据核将结果合并。下面是核的一个例子：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230119164335736.png" alt="image-20230119164335736"></p>
<p>这个核取了8个周围像素值，将它们乘以2，而把当前的像素乘以-15。这个核的例子将周围的像素乘上了一个权重，并将当前像素乘以一个比较大的负权重来平衡结果。</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230119164349112.png" alt="image-20230119164349112"></p>
<p>核是后期处理一个非常有用的工具，它们使用和实验起来都很简单，网上也能找到很多例子。我们需要稍微修改一下片段着色器，让它能够支持核。我们假设使用的核都是3x3核（实际上大部分核都是）：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> <span class="keyword">offset</span> = <span class="number">1.0</span> / <span class="number">300.0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> offsets[<span class="number">9</span>] = <span class="type">vec2</span>[](</span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>,  <span class="keyword">offset</span>), <span class="comment">// 左上</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,    <span class="keyword">offset</span>), <span class="comment">// 正上</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>,  <span class="keyword">offset</span>), <span class="comment">// 右上</span></span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>,  <span class="number">0.0</span>f),   <span class="comment">// 左</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,    <span class="number">0.0</span>f),   <span class="comment">// 中</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>,  <span class="number">0.0</span>f),   <span class="comment">// 右</span></span><br><span class="line">        <span class="type">vec2</span>(-<span class="keyword">offset</span>, -<span class="keyword">offset</span>), <span class="comment">// 左下</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="number">0.0</span>f,   -<span class="keyword">offset</span>), <span class="comment">// 正下</span></span><br><span class="line">        <span class="type">vec2</span>( <span class="keyword">offset</span>, -<span class="keyword">offset</span>)  <span class="comment">// 右下</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> kernel[<span class="number">9</span>] = <span class="type">float</span>[](</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>,  <span class="number">9</span>, <span class="number">-1</span>,</span><br><span class="line">        <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> sampleTex[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sampleTex[i] = <span class="type">vec3</span>(<span class="built_in">texture</span>(screenTexture, TexCoords.st + offsets[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">vec3</span> col = <span class="type">vec3</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        col += sampleTex[i] * kernel[i];</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(col, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中是一个锐化(Sharpen)核，它会采样周围的所有像素，锐化每个颜色值。最后，在采样时我们将每个偏移量加到当前纹理坐标上，获取需要采样的纹理，之后将这些纹理值乘以加权的核值，并将它们加到一起：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230119164538374.png" alt="image-20230119164538374"></p>
<p>此外，<strong>模糊和边缘检测</strong>的效果也可以通过这种方式来实现，在图像处理中又被称为<strong>卷积</strong>；</p>
<p>像是Photoshop这样的图像修改工具&#x2F;滤镜使用的也是这样的核。因为显卡处理片段的时候有着极强的并行处理能力，我们可以很轻松地在实时的情况下逐像素对图像进行处理。所以图像编辑工具在图像处理的时候会更倾向于使用显卡。</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230119164931787.png" alt="image-20230119164931787"></p>
<h3 id="立方体贴图"><a href="#立方体贴图" class="headerlink" title="立方体贴图"></a>立方体贴图</h3><p>立方体贴图就是一个包含了6个2D纹理的纹理，每个2D纹理都组成了立方体的一个面：一个有纹理的立方体。</p>
<p>立方体贴图有一个非常有用的特性，它可以通过一个方向向量来进行索引&#x2F;采样。假设我们有一个1x1x1的单位立方体，方向向量的原点位于它的中心。使用一个橘黄色的方向向量来从立方体贴图上采样一个纹理值会像是这样：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/06/cubemaps_sampling.png" alt="img"></p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230125161438184.png" alt="image-20230125161438184"></p>
<p>如果我们假设将这样的立方体贴图应用到一个立方体上，采样立方体贴图所使用的方向向量将和立方体（插值的）顶点位置非常相像。这样子，<strong>只要立方体的中心位于原点，我们就能使用立方体的实际位置向量来对立方体贴图进行采样</strong>了。接下来，我们可以将所有顶点的纹理坐标当做是立方体的顶点位置。最终得到的结果就是可以访问立方体贴图上正确面(Face)纹理的一个纹理坐标。</p>
<h4 id="创建立方体贴图"><a href="#创建立方体贴图" class="headerlink" title="创建立方体贴图"></a>创建立方体贴图</h4><p>立方体贴图是和其它纹理一样的，所以如果想创建一个立方体贴图的话，我们需要生成一个纹理，并将其绑定到纹理目标上，之后再做其它的纹理操作。这次要绑定到GL_TEXTURE_CUBE_MAP：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> textureID;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br></pre></td></tr></table></figure>

<p>因为立方体贴图包含有6个纹理，每个面一个，我们需要调用glTexImage2D函数6次，参数和之前教程中很类似。但这一次我们将纹理目标(<strong>target</strong>)参数设置为立方体贴图的一个特定的面，告诉OpenGL我们在对立方体贴图的哪一个面创建纹理。这就意味着我们需要对立方体贴图的每一个面都调用一次glTexImage2D。</p>
<p>由于我们有6个面，OpenGL给我们提供了6个特殊的纹理目标，专门对应立方体贴图的一个面。</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230125170407206.png" alt="image-20230125170407206"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> width, height, nrChannels;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *data;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; textures_faces.<span class="built_in">size</span>(); i++)<span class="comment">//textures_faces存储了所有纹理的路径</span></span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="built_in">stbi_load</span>(textures_faces[i].<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(</span><br><span class="line">        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="comment">//它们背后的Int是线性递增的</span></span><br><span class="line">        <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设定环绕和过滤方式：</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="comment">//为纹理的R坐标设置了环绕方式，它对应的是纹理的第三个维度</span></span><br><span class="line"><span class="comment">//环绕方式设置为GL_CLAMP_TO_EDGE，这是因为正好处于两个面之间的纹理坐标可能不能击中一个面（由于一些硬件限制），所以通过使用GL_CLAMP_TO_EDGE，OpenGL将在我们对两个面之间采样的时候，永远返回它们的边界值。</span></span><br></pre></td></tr></table></figure>

<p>在片段着色器中，我们使用了一个不同类型的采样器，<code>samplerCube</code>，我们将使用texture函数使用它进行采样，但这次我们将使用一个<code>vec3</code>的方向向量而不是<code>vec2</code>。使用立方体贴图的片段着色器会像是这样的：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core//顶点着色器</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    TexCoords = aPos;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，顶点着色器中很有意思的部分是，我们将输入的位置向量作为输出给片段着色器的纹理坐标。片段着色器会将它作为输入来采样samplerCube：</span></span><br><span class="line"><span class="meta">#version 330 core//片元着色器</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;    </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(skybox, TexCoords);</span><br><span class="line">&#125;<span class="comment">//我们将顶点属性的位置向量作为纹理的方向向量，并使用它从立方体贴图中采样纹理值(这是因为我们立方体的中心位于原点，因此顶点的位置向量就能代表方向向量)。</span></span><br></pre></td></tr></table></figure>

<h4 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h4><p>天空盒是一个包含了整个场景的（大）立方体，它包含周围环境的6个图像，让玩家以为他处在一个比实际大得多的环境当中。立方体贴图能完美满足天空盒的需求：我们有一个6面的立方体，每个面都需要一个纹理。</p>
<p>为了加载天空盒，我们将使用下面的函数，它接受一个包含6个纹理路径的vector：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;std::string&gt; faces</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;right.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;left.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;top.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bottom.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;front.jpg&quot;</span>,</span><br><span class="line">    <span class="string">&quot;back.jpg&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cubemapTexture = <span class="built_in">loadCubemap</span>(faces);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">loadCubemap</span><span class="params">(vector&lt;std::string&gt; faces)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> textureID;</span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;textureID);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, textureID);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *data = <span class="built_in">stbi_load</span>(faces[i].<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">glTexImage2D</span>(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, </span><br><span class="line">                         <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Cubemap texture failed to load at path: &quot;</span> &lt;&lt; faces[i] &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> textureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>目前我们是首先渲染天空盒，之后再渲染场景中的其它物体。这样子能够工作，但不是非常高效。如果我们先渲染天空盒，我们就会对屏幕上的每一个像素运行一遍片段着色器，即便只有一小部分的天空盒最终是可见的。可以使用**提前深度测试(Early Depth Testing)**轻松丢弃掉的片段能够节省我们很多宝贵的带宽。</p>
<p>所以，我们将会最后渲染天空盒，以获得轻微的性能提升。这样子的话，深度缓冲就会填充满所有物体的深度值了，我们只需要在提前深度测试通过的地方渲染天空盒的片段就可以了，很大程度上减少了片段着色器的调用。问题是，天空盒很可能会渲染在所有其他对象之上，因为它只是一个1x1x1的立方体（译注：意味着距离摄像机的距离也只有1），会通过大部分的深度测试。不用深度测试来进行渲染不是解决方案，因为天空盒将会复写场景中的其它物体。我们需要欺骗深度缓冲，让它认为天空盒有着最大的深度值1.0，只要它前面有一个物体，深度测试就会失败。</p>
<p>在[坐标系统](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;08 Coordinate Systems&#x2F;)小节中我们说过，<strong>透视除法</strong>是在顶点着色器运行之后执行的，将gl_Position的<code>xyz</code>坐标除以w分量。我们又从[深度测试](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/04">https://learnopengl-cn.github.io/04</a> Advanced OpenGL&#x2F;01 Depth testing&#x2F;)小节中知道，相除结果的z分量等于顶点的深度值。使用这些信息，我们可以将输出位置的z分量等于它的w分量，让z分量永远等于1.0，这样子的话，当透视除法执行之后，z分量会变为<code>w / w = 1.0</code>。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    TexCoords = aPos;</span><br><span class="line">    <span class="type">vec4</span> pos = projection * view * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_Position</span> = pos.xyww;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的<strong>标准化设备坐标</strong>将永远会有一个等于1.0的z值：最大的深度值。结果就是天空盒只会在没有可见物体的地方渲染了（只有这样才能通过深度测试，其它所有的东西都在天空盒前面）。</p>
<p>我们还要改变一下深度函数，将它从默认的GL_LESS改为GL_LEQUAL。深度缓冲将会填充上天空盒的1.0值，所以我们需要保证天空盒在值小于或等于深度缓冲而不是小于时通过深度测试。</p>
<h4 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h4><p>我们现在将整个环境映射到了一个纹理对象上了，能利用这个信息的不仅仅只有天空盒。通过使用环境的立方体贴图，我们可以给物体反射和折射的属性。这样使用环境立方体贴图的技术叫做**环境映射(Environment Mapping)**，其中最流行的两个是反射(Reflection)和折射(Refraction)。</p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>反射这个属性表现为物体（或物体的一部分）反射它周围环境，即根据观察者的视角，物体的颜色或多或少等于它的环境。镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。</p>
<p><img src="https://learnopengl-cn.github.io/img/04/06/cubemaps_reflection_theory.png" alt="img"></p>
<p>我们根据观察方向向量和物体的法向量，来计算反射向量。我们可以使用GLSL内建的reflect函数来计算这个反射向量。最终的向量将会作为索引&#x2F;采样立方体贴图的方向向量，返回环境的颜色值。最终的结果是物体看起来反射了天空盒。</p>
<p>因为我们已经在场景中配置好天空盒了，创建反射效果并不会很难。我们将会改变箱子的片段着色器，让箱子有反射性：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core//片元着色器</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> cameraPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> skybox;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">vec3</span> I = <span class="built_in">normalize</span>(Position - cameraPos);</span><br><span class="line">    <span class="type">vec3</span> R = <span class="built_in">reflect</span>(I, <span class="built_in">normalize</span>(Normal));</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="built_in">texture</span>(skybox, R).rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们先计算了观察/摄像机方向向量I，并使用它来计算反射向量R，之后我们将使用R来从天空盒立方体贴图中采样。注意，我们现在又有了片段的插值Normal和Position变量，所以我们需要更新一下顶点着色器。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#version 330 core//顶点着色器</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br><span class="line">    <span class="comment">//我们现在使用了一个法向量，所以我们将再次使用法线矩阵(Normal Matrix)来变换它们。</span></span><br><span class="line">    Position = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    <span class="comment">//Position输出向量是一个世界空间的位置向量。顶点着色器的这个Position输出将用来在片段着色器内计算观察方向向量。</span></span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230126163457826.png" alt="image-20230126163457826"></p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230126163843841.png" alt="image-20230126163843841"></p>
<h5 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h5><p>环境映射的另一种形式是折射，它和反射很相似。折射是光线由于传播介质的改变而产生的方向变化。在常见的类水表面上所产生的现象就是折射，光线不是直直地传播，而是弯曲了一点。将你的半只胳膊伸进水里，观察出来的就是这种效果。</p>
<p>折射是通过<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Snell's_law">斯涅尔定律</a>(Snell’s Law)来描述的，使用环境贴图的话看起来像是这样：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/06/cubemaps_refraction_theory.png" alt="img"></p>
<p>同样，我们有一个观察向量，一个法向量，而这次是折射向量。可以看到，观察向量的方向轻微弯曲了。弯折后的向量将会用来从立方体贴图中采样。</p>
<p>折射可以使用GLSL的内建refract函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive Index)。</p>
<p>折射率决定了材质中光线弯曲的程度，每个材质都有自己的折射率。一些最常见的折射率可以在下表中找到：</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230126163931297.png" alt="image-20230126163931297"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们已经绑定了立方体贴图，提供了顶点数据和法线，并设置了摄像机位置的uniform。唯一要修改的就是片段着色器</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="type">float</span> ratio = <span class="number">1.00</span> / <span class="number">1.52</span>;</span><br><span class="line">    <span class="type">vec3</span> I = <span class="built_in">normalize</span>(Position - cameraPos);</span><br><span class="line">    <span class="type">vec3</span> R = <span class="built_in">refract</span>(I, <span class="built_in">normalize</span>(Normal), ratio);</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="built_in">texture</span>(skybox, R).rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="动态环境贴图"><a href="#动态环境贴图" class="headerlink" title="动态环境贴图"></a>动态环境贴图</h5><p>现在我们使用的都是静态图像的组合来作为天空盒，看起来很不错，但它没有在场景中包括可移动的物体。我们一直都没有注意到这一点，因为我们只使用了一个物体。如果我们有一个镜子一样的物体，周围还有多个物体，镜子中可见的只有天空盒，看起来就像它是场景中唯一一个物体一样。</p>
<p><strong>通过使用帧缓冲，我们能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中</strong>。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做<strong>动态环境映射(Dynamic Environment Mapping)<strong>，因为我们</strong>动态创建了物体周围的立方体贴图，并将其用作环境贴图</strong>。</p>
<p>虽然它看起来很棒，但它有一个很大的缺点：我们<strong>需要为使用环境贴图的物体渲染场景6次，这是对程序是非常大的性能开销</strong>。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。</p>
<h3 id="高级数据"><a href="#高级数据" class="headerlink" title="高级数据"></a>高级数据</h3><p>OpenGL中的缓冲只是一个管理特定内存块的对象，没有其它更多的功能了。在我们将它绑定到一个缓冲目标(Buffer Target)时，我们才赋予了其意义。当我们绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲，但我们也可以很容易地将其绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。</p>
<p>到目前为止，我们一直是调用glBufferData函数来填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的<code>data</code>参数设置为<code>NULL</code>，那么这个函数将只会分配内存，但不进行填充。这在我们需要<strong>预留</strong>(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。</p>
<p>除了使用一次函数调用填充整个缓冲之外，我们也可以<strong>使用glBufferSubData，填充缓冲的特定区域</strong>。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们<strong>可以提供一个偏移量，指定从何处开始填充这个缓冲</strong>。这<strong>能够让我们插入或者更新缓冲内存的某一部分</strong>。要注意的是，缓冲需要有足够的已分配内存，<strong>所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">24</span>, <span class="built_in">sizeof</span>(data), &amp;data); <span class="comment">// 范围： [24, 24 + sizeof(data)]</span></span><br></pre></td></tr></table></figure>

<p>将数据导入缓冲的<strong>另外一种方法</strong>是，请求缓冲内存的指针，直接将数据复制到缓冲当中。通过调用glMapBuffer函数，OpenGL会返回当前绑定缓冲的内存指针，供我们操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> data[] = &#123;</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">-0.35f</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="comment">// 获取指针</span></span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">glMapBuffer</span>(GL_ARRAY_BUFFER, GL_WRITE_ONLY);</span><br><span class="line"><span class="comment">// 复制数据到内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(ptr, data, <span class="built_in">sizeof</span>(data));</span><br><span class="line"><span class="comment">// 记得告诉OpenGL我们不再需要这个指针了</span></span><br><span class="line"><span class="built_in">glUnmapBuffer</span>(GL_ARRAY_BUFFER);</span><br></pre></td></tr></table></figure>

<p>当我们使用glUnmapBuffer函数，告诉OpenGL我们已经完成指针操作之后，OpenGL就会知道你已经完成了。在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将您的数据映射到缓冲中，这个函数将会返回GL_TRUE。</p>
<p>如果要直接映射数据到缓冲，而不事先将其存储到临时内存中，glMapBuffer这个函数会很有用。比如说，你可以从文件中读取数据，并直接将它们复制到缓冲内存中。</p>
<h4 id="分批顶点属性"><a href="#分批顶点属性" class="headerlink" title="分批顶点属性"></a>分批顶点属性</h4><p>通过使用glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。在顶点数组缓冲中，我们对属性进行了<strong>交错(Interleave)处理</strong>，也就是说，我们将每一个顶点的位置、法线和&#x2F;或纹理坐标紧密放置在一起。既然我们现在已经对缓冲有了更多的了解，我们可以采取另一种方式。</p>
<p>我们可以做的是，将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存。与交错布局123123123123不同，我们将采用分批(Batched)的方式111122223333。</p>
<p>当从文件中加载顶点数据的时候，你通常获取到的是一个位置数组、一个法线数组和&#x2F;或一个纹理坐标数组。我们需要花点力气才能将这些数组转化为一个大的交错数据数组。<strong>使用分批的方式会是更简单的解决方案，我们可以很容易使用glBufferSubData函数实现</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> positions[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> normals[] = &#123; ... &#125;;</span><br><span class="line"><span class="type">float</span> tex[] = &#123; ... &#125;;</span><br><span class="line"><span class="comment">// 填充缓冲</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, <span class="built_in">sizeof</span>(positions), &amp;positions);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions), <span class="built_in">sizeof</span>(normals), &amp;normals);</span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals), <span class="built_in">sizeof</span>(tex), &amp;tex);</span><br><span class="line"><span class="comment">//这样子我们就能直接将属性数组作为一个整体传递给缓冲，而不需要事先处理它们了。我们仍可以将它们合并为一个大的数组，再使用glBufferData来填充缓冲，但对于这种工作，使用glBufferSubData会更合适一点。</span></span><br><span class="line"><span class="comment">//我们还需要更新顶点属性指针来反映这些改变：</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">0</span>);<span class="comment">//这里的location依旧对应顶点着色器的layout</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions)));  </span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)(<span class="built_in">sizeof</span>(positions) + <span class="built_in">sizeof</span>(normals)));</span><br></pre></td></tr></table></figure>

<p>这给了我们设置顶点属性的另一种方法。使用哪种方法都不会对OpenGL有什么立刻的好处，它只是设置顶点属性的一种更整洁的方式。具体使用的方法将完全取决于你的喜好与程序类型。</p>
<h4 id="复制缓冲"><a href="#复制缓冲" class="headerlink" title="复制缓冲"></a>复制缓冲</h4><p>当你的缓冲已经填充好数据之后，你可能会想与其它的缓冲共享其中的数据，或者想要将缓冲的内容复制到另一个缓冲当中。glCopyBufferSubData能够让我们相对容易地从一个缓冲中复制数据到另一个缓冲中。这个函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">glCopyBufferSubData</span><span class="params">(GLenum readtarget, GLenum writetarget, GLintptr readoffset,GLintptr writeoffset, GLsizeiptr size)</span></span>;</span><br><span class="line"><span class="comment">//readtarget和writetarget参数需要填入复制源和复制目标的缓冲目标。比如说，我们可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</span></span><br></pre></td></tr></table></figure>

<p>但如果我们想读写数据的<strong>两个不同缓冲都为顶点数组缓冲</strong>该怎么办呢？我们不能同时将两个缓冲绑定到同一个缓冲目标上。正是出于这个原因，OpenGL提供给我们<strong>另外两个缓冲目标，叫做GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER</strong>。我们接下来就可以将需要的缓冲绑定到这两个缓冲目标上，并将这两个目标作为<code>readtarget</code>和<code>writetarget</code>参数。</p>
<p>接下来glCopyBufferSubData会从<code>readtarget</code>中读取<code>size</code>大小的数据，并将其写入<code>writetarget</code>缓冲的<code>writeoffset</code>偏移量处。下面这个例子展示了如何复制两个顶点数组缓冲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_READ_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们也可以只将writetarget缓冲绑定为新的缓冲目标类型之一：</span></span><br><span class="line"><span class="type">float</span> vertexData[] = &#123; ... &#125;;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo1);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_COPY_WRITE_BUFFER, vbo2);</span><br><span class="line"><span class="built_in">glCopyBufferSubData</span>(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(vertexData));</span><br></pre></td></tr></table></figure>

<p>有了这些关于如何操作缓冲的额外知识，我们已经能够以更有意思的方式使用它们了。当你越深入OpenGL时，这些新的缓冲方法将会变得更加有用。</p>
<h3 id="高级GLSL"><a href="#高级GLSL" class="headerlink" title="高级GLSL"></a>高级GLSL</h3><h4 id="glsl的内建变量"><a href="#glsl的内建变量" class="headerlink" title="glsl的内建变量"></a>glsl的内建变量</h4><p>GLSL定义了几个以<code>gl_</code>为前缀的变量，它们能提供给我们更多的方式来读取&#x2F;写入数据，比如顶点着色器的输出向量gl_Position和片元着色器的gl_FragCoord；</p>
<h5 id="顶点着色器变量"><a href="#顶点着色器变量" class="headerlink" title="顶点着色器变量"></a>顶点着色器变量</h5><p>gl_Position是顶点着色器的裁剪空间输出位置向量；如果想在屏幕上输出东西，设置该变量是必须的步骤；</p>
<p><strong>gl_PointSize</strong></p>
<p>我们能够渲染的一种图元是GL_POINTS，他会渲染单个点，我们可以修改gl_PointSize来修改点的大小；</p>
<p>GLSL定义了一个叫做gl_PointSize输出变量，它是一个float变量，你可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。</p>
<p>在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用OpenGL的GL_PROGRAM_POINT_SIZE：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_PROGRAM_POINT_SIZE);</span><br><span class="line"><span class="comment">//一个简单的例子就是将点的大小设置为裁剪空间位置的z值，也就是顶点距观察者的距离。点的大小会随着观察者距顶点距离变远而增大。</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    <span class="built_in">gl_PointSize</span> = <span class="built_in">gl_Position</span>.z;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，对每个顶点使用不同的点大小，会在粒子生成之类的技术中很有意思。</p>
<p><strong>gl_VertexID</strong></p>
<p>gl_Position和gl_PointSize都是<strong>输出变量</strong>，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器还为我们提供了一个有趣的<strong>输入变量</strong>，我们只能对它进行读取，它叫做gl_VertexID。</p>
<p>整型变量gl_VertexID储存了正在绘制顶点的当前ID。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</p>
<p>虽然现在它没有什么具体的用途，但知道我们能够访问这个信息总是好的。</p>
<h5 id="片元着色器变量"><a href="#片元着色器变量" class="headerlink" title="片元着色器变量"></a>片元着色器变量</h5><p><strong>gl_FragCoord</strong></p>
<p>gl_FragCoord的z分量等于对应片段的深度值。然而，我们也能使用它的x和y分量来实现一些有趣的效果。</p>
<p>gl_FragCoord的x和y分量是片元的<strong>窗口空间(Window-space)坐标</strong>，其原点为窗口的左下角。我们已经使用glViewport设定了一个800x600的窗口了，所以片段窗口空间坐标的x分量将在0到800之间，y分量在0到600之间。</p>
<p>通过利用片段着色器，我们可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">gl_FragCoord</span>.x &lt; <span class="number">400</span>)<span class="comment">//对于我们设置的宽为800的情况</span></span><br><span class="line">        FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://learnopengl-cn.github.io/img/04/08/advanced_glsl_fragcoord.png" alt="img"></p>
<p><strong>gl_FrontFacing</strong></p>
<p>如果我们不（启用GL_FACE_CULL来）使用面剔除，那么gl_FrontFacing将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分。举例来说，我们能够对正向面计算出不同的颜色。</p>
<p>gl_FrontFacing变量是一个bool，如果当前片段是正向面的一部分那么就是<code>true</code>，否则就是<code>false</code>。比如说，我们可以这样子创建一个立方体，在内部和外部使用不同的纹理：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> frontTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> backTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">gl_FrontFacing</span>)</span><br><span class="line">        FragColor = <span class="built_in">texture</span>(frontTexture, TexCoords);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FragColor = <span class="built_in">texture</span>(backTexture, TexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://learnopengl-cn.github.io/img/04/08/advanced_glsl_frontfacing.png" alt="img"></p>
<p>注意，如果你开启了面剔除，你就看不到箱子内部的面了，所以现在再使用gl_FrontFacing就没有意义了。</p>
<p><strong>gl_FragDepth</strong></p>
<p>GLSL提供给我们一个叫做gl_FragDepth的输出变量，我们可以使用它来在着色器内设置片段的深度值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl_FragDepth = 0.0; // 这个片段现在的深度值为 0.0</span><br></pre></td></tr></table></figure>

<p>如果着色器没有写入值到gl_FragDepth，它会自动取用<code>gl_FragCoord.z</code>的值。</p>
<p>然而，由我们自己设置深度值有一个很大的缺点，只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会（像[深度测试](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/04">https://learnopengl-cn.github.io/04</a> Advanced OpenGL&#x2F;01 Depth testing&#x2F;)小节中讨论的那样）禁用所有的提前深度测试(Early Depth Testing)。它被禁用的原因是，OpenGL无法在片段着色器运行<strong>之前</strong>得知片段将拥有的深度值，因为片段着色器可能会完全修改这个深度值。</p>
<p>然而，从OpenGL 4.2起，我们仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/08%20Advanced%20GLSL/">https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/08%20Advanced%20GLSL/</a></p>
<h4 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h4><p>到目前为止，每当我们希望从顶点着色器向片段着色器发送数据时，我们都声明了几个对应的输入&#x2F;输出变量。将它们一个一个声明是着色器间发送数据最简单的方式了，但当程序变得更大时，你希望发送的可能就不只是几个变量了，它还可能包括数组和结构体。</p>
<p>为了帮助我们管理这些变量，GLSL为我们提供了一个叫做接口块(Interface Block)的东西，来方便我们组合这些变量。接口块的声明和struct的声明有点相像，不同的是，现在根据它是一个输入还是输出块(Block)，使用in或out关键字来定义的。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//之后，我们还需要定义一个输入接口块。块名(Block Name)应该是和着色器中一样的（VS_OUT），但实例名(Instance Name)（顶点着色器中用的是vs_out）可以是随意的，但要避免使用误导性的名称，比如对实际上包含输入变量的接口块命名为vs_out。</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> <span class="built_in">texture</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(<span class="built_in">texture</span>, fs_in.TexCoords);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Uniform缓冲对象"><a href="#Uniform缓冲对象" class="headerlink" title="Uniform缓冲对象"></a>Uniform缓冲对象</h4><p>OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的<strong>全局</strong>Uniform变量。当使用Uniform缓冲对象的时候，我们只需要设置相关的uniform<strong>一次</strong>。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。</p>
<p>因为Uniform缓冲对象仍是一个缓冲，我们可以使用glGenBuffers来创建它，将它绑定到GL_UNIFORM_BUFFER缓冲目标，并将所有相关的uniform数据存入缓冲。在Uniform缓冲对象中储存数据是有一些规则的，我们将会在之后讨论它。首先，我们将使用一个简单的顶点着色器，将projection和view矩阵存储到所谓的Uniform块(Uniform Block)中：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> Matrices<span class="comment">//它的意思是说，当前定义的Uniform块对它的内容使用一个特定的内存布局。这个语句设置了Uniform块布局(Uniform Block Layout)。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> projection;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接下来，我们在OpenGL代码中将这些矩阵值存入缓冲中，每个声明了这个Uniform块的着色器都能够访问这些矩阵。</span></span><br></pre></td></tr></table></figure>

<h4 id="Uniform块布局"><a href="#Uniform块布局" class="headerlink" title="Uniform块布局"></a>Uniform块布局</h4><p>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。</p>
<p>假设着色器中有以下的这个Uniform块：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> ExampleBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">    <span class="type">vec3</span>  vector;</span><br><span class="line">    <span class="type">mat4</span>  matrix;</span><br><span class="line">    <span class="type">float</span> values[<span class="number">3</span>];</span><br><span class="line">    <span class="type">bool</span>  boolean;</span><br><span class="line">    <span class="type">int</span>   integer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许<strong>硬件能够在它认为合适的位置放置变量</strong>。比如说，一些硬件可能会将一个vec3放置在float边上。不是所有的硬件都能这样处理，<strong>可能会在附加这个float之前，先将vec3填充(Pad)为一个4个float的数组。这个特性本身很棒，但是会对我们造成麻烦</strong>。</p>
<p>默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是<strong>共享</strong>并一致的。使用共享布局时，GLSL是可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变。因为我们无法知道每个uniform变量的偏移量，我们也就<strong>不知道如何准确地填充我们的Uniform缓冲</strong>了。我们这时候只能使用glGetUniformIndices这样的函数来查询信息；但是这会产生非常多的工程量，因此即使<strong>共享布局</strong>给了我们很多<strong>节省空间的优化</strong>，我们目前也不会使用他；</p>
<p>通常的做法是，不使用共享布局，而是使用<strong>std140布局</strong>。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这<strong>显式地</strong>声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。</p>
<p>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量<strong>必须</strong>等于基准对齐量的倍数。</p>
<p>我们将会在下面列出最常见的规则。GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个<code>N</code>来表示。</p>
<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230203150824128.png" alt="image-20230203150824128"></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> ExampleBlock</span><br><span class="line">&#123;</span><br><span class="line">                     <span class="comment">// 基准对齐量       // 对齐偏移量</span></span><br><span class="line">    <span class="type">float</span> value;     <span class="comment">// 4               // 0 </span></span><br><span class="line">    <span class="type">vec3</span> vector;     <span class="comment">// 16              // 16  (必须是16的倍数，所以 4-&gt;16)</span></span><br><span class="line">    <span class="type">mat4</span> matrix;     <span class="comment">// 16              // 32  (列 0)</span></span><br><span class="line">                     <span class="comment">// 16              // 48  (列 1)</span></span><br><span class="line">                     <span class="comment">// 16              // 64  (列 2)</span></span><br><span class="line">                     <span class="comment">// 16              // 80  (列 3)</span></span><br><span class="line">    <span class="type">float</span> values[<span class="number">3</span>]; <span class="comment">// 16              // 96  (values[0])</span></span><br><span class="line">                     <span class="comment">// 16              // 112 (values[1])</span></span><br><span class="line">                     <span class="comment">// 16              // 128 (values[2])</span></span><br><span class="line">    <span class="type">bool</span> boolean;    <span class="comment">// 4               // 144(也许是需要同时满足是当前和上一个元素的基准对齐量的倍数？)</span></span><br><span class="line">    <span class="type">int</span> integer;     <span class="comment">// 4               // 148</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="使用Uniform缓冲"><a href="#使用Uniform缓冲" class="headerlink" title="使用Uniform缓冲"></a>使用Uniform缓冲</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uboExampleBlock;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;uboExampleBlock);<span class="comment">//创建一个Uniform缓冲对象</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);<span class="comment">//绑定到GL_UNIFORM_BUFFER目标</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_UNIFORM_BUFFER, <span class="number">152</span>, <span class="literal">NULL</span>, GL_STATIC_DRAW); <span class="comment">// 分配152字节的内存</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>现在，每当我们需要对缓冲更新或者插入数据，我们都会绑定到uboExampleBlock，并使用<strong>glBufferSubData来更新它的内存</strong>。我们只需要更新这个Uniform缓冲一次，所有使用这个缓冲的着色器就都使用的是更新后的数据了。但是，如何才能<strong>让OpenGL知道哪个Uniform缓冲对应的是哪个Uniform块</strong>呢？</p>
<p>在OpenGL上下文中，定义了一些绑定点(Binding Point)，我们可以将一个Uniform缓冲链接至它。在创建Uniform缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的Uniform块绑定到相同的绑定点，把它们连接到一起。下面的这个图示展示了这个：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/08/advanced_glsl_binding_points.png" alt="img"></p>
<p>我们可以绑定多个Uniform缓冲到不同的绑定点上。因为着色器A和着色器B都有一个链接到绑定点0的Uniform块，它们的Uniform块将会共享相同的uniform数据，uboMatrices，前提条件是两个着色器都定义了相同的Matrices Uniform块。</p>
<p>为了将Uniform块绑定到一个特定的绑定点中，我们需要调用glUniformBlockBinding函数，它的第一个参数是一个程序对象，之后是一个Uniform块索引和链接到的绑定点。Uniform块索引(Uniform Block Index)是着色器中已定义Uniform块的位置值索引。这可以通过调用glGetUniformBlockIndex来获取，它接受一个程序对象和Uniform块的名称。我们可以用以下方式将图示中的Lights Uniform块链接到绑定点2：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> lights_index = <span class="built_in">glGetUniformBlockIndex</span>(shaderA.ID, <span class="string">&quot;Lights&quot;</span>);   </span><br><span class="line"><span class="built_in">glUniformBlockBinding</span>(shaderA.ID, lights_index, <span class="number">2</span>);<span class="comment">//注意我们需要对每个着色器重复这一步骤。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来，我们还需要绑定Uniform缓冲对象到相同的绑定点上，这可以使用glBindBufferBase或glBindBufferRange来完成。</span></span><br><span class="line"><span class="built_in">glBindBufferBase</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock); </span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">glBindBufferRange</span>(GL_UNIFORM_BUFFER, <span class="number">2</span>, uboExampleBlock, <span class="number">0</span>, <span class="number">152</span>);</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230203152520131.png" alt="image-20230203152520131"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要我们需要，就可以使用glBufferSubData函数，用一个字节数组添加所有的数据，或者更新缓冲的一部分。要想更新uniform变量boolean，我们可以用以下方式更新Uniform缓冲对象：</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, uboExampleBlock);</span><br><span class="line"><span class="type">int</span> b = <span class="literal">true</span>; <span class="comment">// GLSL中的bool是4字节的，所以我们将它存为一个integer</span></span><br><span class="line"><span class="built_in">glBufferSubData</span>(GL_UNIFORM_BUFFER, <span class="number">144</span>, <span class="number">4</span>, &amp;b); <span class="comment">//填充了例中的bool变量</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_UNIFORM_BUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h3><p>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换。然而，几何着色器最有趣的地方在于，它能够将（这一组）顶点变换为完全不同的图元，并且还能生成比原来更多的顶点。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;<span class="comment">//输入图元</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">line_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">2</span>) <span class="keyword">out</span>;<span class="comment">//输出图元，同时设定最大顶点数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在几何着色器的顶部，我们需要声明从顶点着色器输入的图元类型。这需要在in关键字前声明一个布局修饰符(Layout Qualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值：</p>
<ul>
<li><code>points</code>：绘制GL_POINTS图元时（1）。</li>
<li><code>lines</code>：绘制GL_LINES或GL_LINE_STRIP时（2）</li>
<li><code>lines_adjacency</code>：GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY（4）</li>
<li><code>triangles</code>：GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN（3）</li>
<li><code>triangles_adjacency</code>：GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY（6）</li>
</ul>
<p>以上是能提供给glDrawArrays渲染函数的几乎所有图元了。如果我们想要将顶点绘制为GL_TRIANGLES，我们就要将输入修饰符设置为<code>triangles</code>。括号内的数字表示的是一个图元所包含的最小顶点数。</p>
<p>接下来，我们还需要指定几何着色器输出的图元类型，这需要在out关键字前面加一个布局修饰符。和输入布局修饰符一样，输出布局修饰符也可以接受几个图元值：</p>
<ul>
<li><code>points</code></li>
<li><code>line_strip</code></li>
<li><code>triangle_strip</code></li>
</ul>
<p>有了这3个输出修饰符，我们就可以使用输入图元创建几乎任意的形状了。要生成一个三角形的话，我们将输出定义为<code>triangle_strip</code>，并输出3个顶点。</p>
<p>几何着色器同时希望我们设置一个它最大能够输出的顶点数量（如果你超过了这个值，OpenGL将不会绘制<strong>多出的</strong>顶点），这个也可以在out关键字的布局修饰符中设置。在这个例子中，我们将输出一个<code>line_strip</code>(线条)，并将最大顶点数设置为2个。</p>
<p>如果你不知道什么是线条(Line Strip)：线条连接了一组点，形成一条连续的线，它最少要由两个点来组成。在渲染函数中每多加一个点，就会在这个点与前一个点之间形成一条新的线。在下面这张图中，我们有5个顶点：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/09/geometry_shader_line_strip.png" alt="img"></p>
<p>如果使用的是上面定义的着色器，那么这将只能输出一条线段，因为最大顶点数等于2。</p>
<p>为了生成更有意义的结果，我们需要某种方式来获取前一着色器阶段的输出。GLSL提供给我们一个内建(Built-in)变量，在内部看起来（可能）是这样的：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">gl_Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span>  <span class="built_in">gl_Position</span>;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">gl_PointSize</span>;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">gl_ClipDistance</span>[];</span><br><span class="line">&#125; <span class="built_in">gl_in</span>[];</span><br></pre></td></tr></table></figure>

<p>这里，它被声明为一个接口块，它包含了几个很有意思的变量，其中最有趣的一个是gl_Position，它是和顶点着色器输出非常相似的一个向量。</p>
<p>要注意的是，它被声明为一个数组，因为大多数的渲染图元包含多于1个的顶点，而几何着色器的输入是一个图元的<strong>所有</strong>顶点。</p>
<p>有了之前顶点着色器阶段的顶点数据，我们就可以使用<strong>2个几何着色器函数，EmitVertex和EndPrimitive</strong>，来生成新的数据了。几何着色器希望你能够生成并输出至少一个定义为输出的图元。在我们的例子中，我们需要至少生成一个线条图元。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>(<span class="number">-0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>); </span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span> + <span class="type">vec4</span>( <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>每次我们调用EmitVertex时，gl_Position中的向量会被添加到图元中来。</strong>当EndPrimitive被调用时，所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。在一个或多个EmitVertex调用之后重复调用EndPrimitive能够生成多个图元。在这个例子中，我们发射了两个顶点，它们从原始顶点位置平移了一段距离，之后调用了EndPrimitive，将这两个顶点合成为一个包含两个顶点的线条。</p>
<p><img src="https://learnopengl-cn.github.io/img/04/09/geometry_shader_lines.png" alt="img"></p>
<p>这是例中绘制四个点的结果；</p>
<h4 id="使用几何着色器"><a href="#使用几何着色器" class="headerlink" title="使用几何着色器"></a>使用几何着色器</h4><p>和顶点与片段着色器一样，几何着色器也需要编译和链接，但这次在创建着色器时我们将会使用GL_GEOMETRY_SHADER作为着色器类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">geometryShader = <span class="built_in">glCreateShader</span>(GL_GEOMETRY_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(geometryShader, <span class="number">1</span>, &amp;gShaderCode, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(geometryShader);  </span><br><span class="line">...</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, geometryShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br></pre></td></tr></table></figure>

<p>现在假如我们希望使用一个顶点绘制一个房子：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/09/geometry_shader_house.png" alt="img"></p>
<p>变为几何着色器是这样的：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">points</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangle_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">5</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> build_house(<span class="type">vec4</span> position)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>(<span class="number">-0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 1:左下</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();   </span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 2:右下</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>(<span class="number">-0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 3:左上</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 4:右上</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.0</span>,  <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 5:顶部</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;    </span><br><span class="line">    build_house(<span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们为房子添加颜色：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们在顶点数据中加入颜色信息</span></span><br><span class="line"><span class="type">float</span> <span class="keyword">points</span>[] = &#123;</span><br><span class="line">    <span class="number">-0.5</span>f,  <span class="number">0.5</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="comment">// 左上</span></span><br><span class="line">     <span class="number">0.5</span>f,  <span class="number">0.5</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5</span>f, <span class="number">-0.5</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5</span>f, <span class="number">-0.5</span>f, <span class="number">1.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f  <span class="comment">// 左下</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后我们更新顶点着色器，使用一个接口块将颜色属性发送到几何着色器中：</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> color;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, <span class="number">0.0</span>, <span class="number">1.0</span>); </span><br><span class="line">    vs_out.color = aColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在几何着色器中接收接口块信息：</span></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> color;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;<span class="comment">//设置颜色输出</span></span><br><span class="line">fColor = gs_in[<span class="number">0</span>].color; <span class="comment">// gs_in[0] 因为只有一个输入顶点</span></span><br><span class="line"><span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>(<span class="number">-0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 1:左下  </span></span><br><span class="line"><span class="built_in">EmitVertex</span>();   </span><br><span class="line"><span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.2</span>, <span class="number">-0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 2:右下</span></span><br><span class="line"><span class="built_in">EmitVertex</span>();</span><br><span class="line"><span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>(<span class="number">-0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 3:左上</span></span><br><span class="line"><span class="built_in">EmitVertex</span>();</span><br><span class="line"><span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.2</span>,  <span class="number">0.2</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 4:右上</span></span><br><span class="line"><span class="built_in">EmitVertex</span>();</span><br><span class="line"><span class="built_in">gl_Position</span> = position + <span class="type">vec4</span>( <span class="number">0.0</span>,  <span class="number">0.4</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 5:顶部</span></span><br><span class="line"><span class="built_in">EmitVertex</span>();</span><br><span class="line"><span class="built_in">EndPrimitive</span>();  </span><br></pre></td></tr></table></figure>

<h4 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h4><p>当我们说<strong>爆破</strong>一个物体时，我们并不是指要将宝贵的顶点集给炸掉，我们是要将每个三角形沿着法向量的方向移动一小段时间。效果就是，整个物体看起来像是沿着每个三角形的法线向量<strong>爆炸</strong>一样。爆炸三角形的效果在纳米装模型上看起来像是这样的：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/09/geometry_shader_explosion.png" alt="img"></p>
<p>这样的几何着色器效果的一个好处就是，无论物体有多复杂，它都能够应用上去。</p>
<p>因为我们想要沿着三角形的法向量位移每个顶点，我们首先需要计算这个法向量。我们所要做的是计算垂直于三角形表面的向量，仅使用我们能够访问的3个顶点。你可能还记得在[变换](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01">https://learnopengl-cn.github.io/01</a> Getting started&#x2F;07 Transformations&#x2F;)小节中，我们使用叉乘来获取垂直于其它两个向量的一个向量。如果我们能够获取两个平行于三角形表面的向量a和b，我们就能够对这两个向量进行叉乘来获取法向量了。下面这个几何着色器函数做的正是这个，来使用3个输入顶点坐标来获取法向量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> GetNormal()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">vec3</span> a = <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">0</span>].<span class="built_in">gl_Position</span>) - <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">1</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">   <span class="type">vec3</span> b = <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">2</span>].<span class="built_in">gl_Position</span>) - <span class="type">vec3</span>(<span class="built_in">gl_in</span>[<span class="number">1</span>].<span class="built_in">gl_Position</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">normalize</span>(<span class="built_in">cross</span>(a, b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//既然知道了如何计算法向量了，我们就能够创建一个explode函数了，它使用法向量和顶点位置向量作为参数。这个函数会返回一个新的向量，它是位置向量沿着法线向量进行位移之后的结果：</span></span><br><span class="line"><span class="type">vec4</span> explode(<span class="type">vec4</span> position, <span class="type">vec3</span> normal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> magnitude = <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">vec3</span> direction = normal * ((<span class="built_in">sin</span>(time) + <span class="number">1.0</span>) / <span class="number">2.0</span>) * magnitude; </span><br><span class="line">    <span class="keyword">return</span> position + <span class="type">vec4</span>(direction, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sin函数接收一个time参数，它根据时间返回一个-1.0到1.0之间的值。因为我们不想让物体向内爆炸(Implode)，我们将sin值变换到了[0, 1]的范围内。最终的结果会乘以normal向量，并且最终的direction向量会被加到位置向量上。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230206164335407.png" alt="image-20230206164335407"></p>
<h4 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h4><p>当编写光照着色器时，你可能会最终会得到一些奇怪的视觉输出，但又很难确定导致问题的原因。光照错误很常见的原因就是法向量错误，这可能是由于不正确加载顶点数据、错误地将它们定义为顶点属性或在着色器中不正确地管理所导致的。我们想要的是使用某种方式来检测提供的法向量是正确的。检测法向量是否正确的一个很好的方式就是对它们进行可视化，几何着色器正是实现这一目的非常有用的工具。</p>
<p>思路是这样的：我们首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。伪代码看起来会像是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawScene</span>();</span><br><span class="line">normalDisplayShader.<span class="built_in">use</span>();</span><br><span class="line"><span class="built_in">DrawScene</span>();</span><br></pre></td></tr></table></figure>

<p>这次在几何着色器中，我们会使用模型提供的顶点法线，而不是自己生成，为了适配（观察和模型矩阵的）缩放和旋转，我们在将法线变换到观察空间坐标之前，先使用法线矩阵变换一次（几何着色器接受的位置向量是观察空间坐标，所以我们应该将法向量变换到相同的空间中）。这可以在顶点着色器中完成：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> normal;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); </span><br><span class="line">    <span class="type">mat3</span> normalMatrix = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(view * model)));</span><br><span class="line">    vs_out.normal = <span class="built_in">normalize</span>(<span class="type">vec3</span>(<span class="type">vec4</span>(normalMatrix * aNormal, <span class="number">0.0</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变换后的观察空间法向量会以接口块的形式传递到下个着色器阶段。接下来，几何着色器会接收每一个顶点（包括一个位置向量和一个法向量），并在每个位置向量处绘制一个法线向量：</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangles</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">line_strip</span>, <span class="keyword">max_vertices</span> = <span class="number">6</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> normal;</span><br><span class="line">&#125; gs_in[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> MAGNITUDE = <span class="number">0.4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> GenerateLine(<span class="type">int</span> <span class="keyword">index</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * <span class="built_in">gl_in</span>[<span class="keyword">index</span>].<span class="built_in">gl_Position</span>;</span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * (<span class="built_in">gl_in</span>[<span class="keyword">index</span>].<span class="built_in">gl_Position</span> + </span><br><span class="line">                                <span class="type">vec4</span>(gs_in[<span class="keyword">index</span>].normal, <span class="number">0.0</span>) * MAGNITUDE);<span class="comment">//通过沿着法线方向移动得到另一个点来装配出线段；MAGNITUDE向量用来限制显示出的法向量大小(否则会有些大)；</span></span><br><span class="line">    <span class="built_in">EmitVertex</span>();</span><br><span class="line">    <span class="built_in">EndPrimitive</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    GenerateLine(<span class="number">0</span>); <span class="comment">// 第一个顶点法线</span></span><br><span class="line">    GenerateLine(<span class="number">1</span>); <span class="comment">// 第二个顶点法线</span></span><br><span class="line">    GenerateLine(<span class="number">2</span>); <span class="comment">// 第三个顶点法线</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为法线的可视化通常都是用于调试目的，我们可以使用片段着色器，将它们显示为单色的线：</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://heptagramv-blog.oss-cn-beijing.aliyuncs.com/img/image-20230206171323502.png" alt="image-20230206171323502"></p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>假设你有一个绘制了很多模型的场景，而大部分的模型包含的是同一组顶点数据，只不过进行的是不同的世界空间变换。想象一个充满草的场景：每根草都是一个包含几个三角形的小模型。你可能会需要绘制很多根草，最终在每帧中你可能会需要渲染上千或者上万根草。因为每一根草仅仅是由几个三角形构成，渲染几乎是瞬间完成的，但上千个渲染函数调用却会极大地影响性能。</p>
<p>如果我们需要渲染大量物体时，代码看起来会像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; amount_of_models_to_draw; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DoSomePreparations</span>(); <span class="comment">// 绑定VAO，绑定纹理，设置uniform等</span></span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, amount_of_vertices);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果像这样绘制模型的大量实例(Instance)，你很快就会因为绘制调用过多而达到性能瓶颈。与绘制顶点本身相比，使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在<strong>相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）</strong>。所以，<strong>即便渲染顶点非常快，命令GPU去渲染却未必</strong>。</p>
<p><strong>如果我们能够将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，就会更方便了。这就是实例化(Instancing)。</strong></p>
<p>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来<strong>节省每次绘制物体时CPU -&gt; GPU的通信</strong>，它只需要一次即可。如果想使用实例化渲染，我们只需要将glDrawArrays和glDrawElements的渲染调用分别改为glDrawArraysInstanced和glDrawElementsInstanced就可以了。这些渲染函数的<strong>实例化</strong>版本需要一个额外的参数，叫做实例数量(Instance Count)，它能够设置我们需要渲染的实例个数。这样我们只需要将必须的数据发送到GPU一次，然后使用一次函数调用告诉GPU它应该如何绘制这些实例。GPU将会直接渲染这些实例，而不用不断地与CPU进行通信。</p>
<p>这个函数本身并没有什么用。渲染同一个物体一千次对我们并没有什么用处，每个物体都是完全相同的，而且还在同一个位置。我们只能看见一个物体！处于这个原因，GLSL在顶点着色器中嵌入了另一个内建变量，gl_InstanceID。</p>
<p>在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。比如说，我们正在渲染第43个实例，那么顶点着色器中它的gl_InstanceID将会是42。<strong>因为每个实例都有唯一的ID，我们可以建立一个数组，将ID与位置值对应起来，将每个实例放置在世界的不同位置。</strong></p>
<p>为了体验一下实例化绘制，我们将会在标准化设备坐标系中使用一个渲染调用，绘制100个2D四边形。我们会索引一个包含100个偏移向量的uniform数组，将偏移值加到每个实例化的四边形上。最终的结果是一个排列整齐的四边形网格：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/10/instancing_quads.png" alt="img"></p>
<p>片元着色器没有什么新内容，但是顶点着色器需要修改：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> offsets[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//这里我们定义了一个叫做offsets的数组，它包含100个偏移向量。在顶点着色器中，我们会**使用gl_InstanceID来索引offsets数组**，获取每个实例的偏移向量。如果我们要实例化绘制100个四边形，仅使用这个顶点着色器我们就能得到100个位于不同位置的四边形。</span></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = offsets[<span class="built_in">gl_InstanceID</span>];</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos + <span class="keyword">offset</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前，我们仍要设置这些偏移位置，我们会在进入渲染循环之前使用一个嵌套for循环计算：</span></span><br><span class="line">glm::<span class="type">vec2</span> translations[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> <span class="keyword">offset</span> = <span class="number">0.1</span>f;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">-10</span>; y &lt; <span class="number">10</span>; y += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">-10</span>; x &lt; <span class="number">10</span>; x += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        glm::<span class="type">vec2</span> translation;</span><br><span class="line">        translation.x = (<span class="type">float</span>)x / <span class="number">10.0</span>f + <span class="keyword">offset</span>;</span><br><span class="line">        translation.y = (<span class="type">float</span>)y / <span class="number">10.0</span>f + <span class="keyword">offset</span>;</span><br><span class="line">        translations[<span class="keyword">index</span>++] = translation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里，我们创建100个位移向量，表示10x10网格上的所有位置。除了生成translations数组之外，我们还需要将数据转移到顶点着色器的uniform数组中：</span></span><br><span class="line">shader.use();</span><br><span class="line"><span class="keyword">for</span>(unsigned <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;<span class="comment">//我们将for循环的计数器i转换为一个string，我们可以用它来动态创建位置值的字符串，用于uniform位置值的索引。接下来，我们会对offsets uniform数组中的每一项设置对应的位移向量。</span></span><br><span class="line">    stringstream ss;</span><br><span class="line">    string <span class="keyword">index</span>;</span><br><span class="line">    ss &lt;&lt; i; </span><br><span class="line">    <span class="keyword">index</span> = ss.str(); </span><br><span class="line">    shader.setVec2((&quot;offsets[&quot; + <span class="keyword">index</span> + &quot;]&quot;).c_str(), translations[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于实例化渲染，我们使用glDrawArraysInstanced或glDrawElementsInstanced。</span></span><br><span class="line">glBindVertexArray(quadVAO);</span><br><span class="line">glDrawArraysInstanced(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//glDrawArraysInstanced的参数和glDrawArrays完全一样，除了最后多了个参数用来设置需要绘制的实例数量。因为我们想要在10x10网格中显示100个四边形，我们将它设置为100.运行代码之后，你应该能得到熟悉的100个五彩的四边形。</span></span><br></pre></td></tr></table></figure>

<h4 id="实例化数组"><a href="#实例化数组" class="headerlink" title="实例化数组"></a>实例化数组</h4><p>虽然之前的实现在目前的情况下能够正常工作，但是如果我们要渲染远超过100个实例的时候（这其实非常普遍），我们最终会超过最大能够发送至着色器的uniform数据大小<a target="_blank" rel="noopener" href="http://www.opengl.org/wiki/Uniform_(GLSL)#Implementation_limits">上限</a>。它的一个代替方案是**实例化数组(Instanced Array)**，它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</p>
<p>使用顶点属性时，顶点着色器的每次运行都会让GLSL获取新一组适用于当前顶点的属性。而当我们将顶点属性定义为一个实例化数组时，顶点着色器就只需要对每个实例，而不是每个顶点，更新顶点属性的内容了。这允许我们对逐顶点的数据使用普通的顶点属性，而对逐实例的数据使用实例化数组。</p>
<p>为了给你一个实例化数组的例子，我们将使用之前的例子，并将偏移量uniform数组设置为一个实例化数组。我们需要在顶点着色器中再添加一个顶点属性：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> fColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos + aOffset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们不再使用gl_InstanceID，现在不需要索引一个uniform数组就能够直接使用offset属性了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为实例化数组和position与color变量一样，都是顶点属性，我们还需要将它的内容存在顶点缓冲对象中，并且配置它的属性指针。我们首先将（上一部分的）translations数组存到一个新的缓冲对象中：</span></span><br><span class="line"></span><br><span class="line">unsigned <span class="type">int</span> instanceVBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;instanceVBO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(glm::<span class="type">vec2</span>) * <span class="number">100</span>, &amp;translations[<span class="number">0</span>], GL_STATIC_DRAW);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//之后我们还需要设置它的顶点属性指针，并启用顶点属性：</span></span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);</span><br><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span> * sizeof(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);   </span><br><span class="line">glVertexAttribDivisor(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//glVertexAttribDivisor这个函数告诉了OpenGL该什么时候更新顶点属性的内容至新一组数据。它的第一个参数是需要的顶点属性，第二个参数是属性除数(Attribute Divisor)。默认情况下，属性除数是0，告诉OpenGL我们需要在顶点着色器的每次迭代时更新顶点属性。将它设置为1时，我们告诉OpenGL我们希望在渲染一个新实例的时候更新顶点属性。而设置为2时，我们希望每2个实例更新一次属性，以此类推。我们将属性除数设置为1，是在告诉OpenGL，处于位置值2的顶点属性是一个实例化数组。</span></span><br></pre></td></tr></table></figure>

<p>如果我们现在使用glDrawArraysInstanced，再次渲染四边形，会得到以下输出：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/10/instancing_quads.png" alt="img"></p>
<p>这和之前的例子是完全一样的，但这次是使用实例化数组实现的，这让我们能够传递更多的数据到顶点着色器（只要内存允许）来用于实例化绘制。</p>
<p>我们也可以使用gl_InstanceID，从右上到左下逐渐缩小四边形：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> pos = aPos * (<span class="built_in">gl_InstanceID</span> / <span class="number">100.0</span>);</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(pos + aOffset, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果就是，第一个四边形的实例会非常小，随着绘制实例的增加，gl_InstanceID会越来越接近100，四边形也就越来越接近原始大小。像这样将实例化数组与gl_InstanceID结合使用是完全可行的。</p>
<h4 id="小行星带"><a href="#小行星带" class="headerlink" title="小行星带"></a>小行星带</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> amount = <span class="number">1000</span>;</span><br><span class="line">glm::mat4 *modelMatrices;</span><br><span class="line">modelMatrices = <span class="keyword">new</span> glm::mat4[amount];</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">glfwGetTime</span>()); <span class="comment">// 初始化随机种子    </span></span><br><span class="line"><span class="type">float</span> radius = <span class="number">50.0</span>;</span><br><span class="line"><span class="type">float</span> offset = <span class="number">2.5f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; amount; i++)</span><br><span class="line">&#123;</span><br><span class="line">    glm::mat4 model;</span><br><span class="line">    <span class="comment">// 1. 位移：分布在半径为 &#x27;radius&#x27; 的圆形上，偏移的范围是 [-offset, offset]</span></span><br><span class="line">    <span class="type">float</span> angle = (<span class="type">float</span>)i / (<span class="type">float</span>)amount * <span class="number">360.0f</span>;</span><br><span class="line">    <span class="type">float</span> displacement = (<span class="built_in">rand</span>() % (<span class="type">int</span>)(<span class="number">2</span> * offset * <span class="number">100</span>)) / <span class="number">100.0f</span> - offset;</span><br><span class="line">    <span class="type">float</span> x = <span class="built_in">sin</span>(angle) * radius + displacement;</span><br><span class="line">    displacement = (<span class="built_in">rand</span>() % (<span class="type">int</span>)(<span class="number">2</span> * offset * <span class="number">100</span>)) / <span class="number">100.0f</span> - offset;</span><br><span class="line">    <span class="type">float</span> y = displacement * <span class="number">0.4f</span>; <span class="comment">// 让行星带的高度比x和z的宽度要小</span></span><br><span class="line">    displacement = (<span class="built_in">rand</span>() % (<span class="type">int</span>)(<span class="number">2</span> * offset * <span class="number">100</span>)) / <span class="number">100.0f</span> - offset;</span><br><span class="line">    <span class="type">float</span> z = <span class="built_in">cos</span>(angle) * radius + displacement;</span><br><span class="line">    model = glm::<span class="built_in">translate</span>(model, glm::<span class="built_in">vec3</span>(x, y, z));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 缩放：在 0.05 和 0.25f 之间缩放</span></span><br><span class="line">    <span class="type">float</span> scale = (<span class="built_in">rand</span>() % <span class="number">20</span>) / <span class="number">100.0f</span> + <span class="number">0.05</span>;</span><br><span class="line">    model = glm::<span class="built_in">scale</span>(model, glm::<span class="built_in">vec3</span>(scale));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 旋转：绕着一个（半）随机选择的旋转轴向量进行随机的旋转</span></span><br><span class="line">    <span class="type">float</span> rotAngle = (<span class="built_in">rand</span>() % <span class="number">360</span>);</span><br><span class="line">    model = glm::<span class="built_in">rotate</span>(model, rotAngle, glm::<span class="built_in">vec3</span>(<span class="number">0.4f</span>, <span class="number">0.6f</span>, <span class="number">0.8f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加到矩阵的数组中</span></span><br><span class="line">    modelMatrices[i] = model;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们将小行星的<code>x</code>和<code>z</code>位置变换到了一个半径为radius的圆形上，并且在半径的基础上偏移了-offset到offset。我们让<code>y</code>偏移的影响更小一点，让小行星带更扁平一点。接下来，我们应用了缩放和旋转变换，并将最终的变换矩阵储存在modelMatrices中，这个数组的大小是amount。这里，我们一共生成1000个模型矩阵，每个小行星一个。</p>
<p>现在，我们来尝试使用实例化渲染来渲染。我们首先对顶点着色器进行一点修改：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">3</span>) <span class="keyword">in</span> <span class="type">mat4</span> instanceMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * instanceMatrix * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); </span><br><span class="line">    TexCoords = aTexCoords;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们不再使用模型uniform变量，改为一个mat4的顶点属性，让我们能够存储一个实例化数组的变换矩阵。然而，当我们顶点属性的类型大于vec4时，就要多进行一步处理了。顶点属性最大允许的数据大小等于一个vec4。因为一个mat4本质上是4个vec4，我们需要为这个矩阵预留4个顶点属性。因为我们将它的位置值设置为3，矩阵每一列的顶点属性位置值就是3、4、5和6。</span></span><br></pre></td></tr></table></figure>

<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> buffer;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;buffer);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, buffer);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, amount * <span class="built_in">sizeof</span>(glm::mat4), &amp;modelMatrices[<span class="number">0</span>], GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<p>这里我发现如果将加载模型的代码放在这部分之后，模型就会出现问题，目前原因未知；</p>
<h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p><img src="https://learnopengl-cn.github.io/img/04/11/anti_aliasing_zoomed.png" alt="img"></p>
<p>这种现象被称之为走样(Aliasing)。有很多种抗锯齿（Anti-aliasing，也被称为反走样）的技术能够帮助我们缓解这种现象，从而产生更<strong>平滑</strong>的边缘。</p>
<p>最开始我们有一种叫做超采样抗锯齿(Super Sample Anti-aliasing, SSAA)的技术，它会使用比正常分辨率更高的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率。这些<strong>额外的</strong>分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的性能开销。所以这项技术只拥有了短暂的辉煌。</p>
<p>然而，在这项技术的基础上也诞生了更为现代的技术，叫做多重采样抗锯齿(Multisample Anti-aliasing, MSAA)。它借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿。</p>
<h4 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h4><p>光栅器是位于最终处理过的顶点之后到片元着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片元。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片元之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片元&#x2F;屏幕坐标。</p>
<p><img src="https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization.png" alt="img"></p>
<p>这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点(Sample Point)，它会被用来决定这个三角形是否遮盖了某个像素。图中红色的采样点被三角形所遮盖，<strong>在每一个遮住的像素处都会生成一个片元</strong>。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形<strong>内部</strong>所遮盖，所以它们不会受到片元着色器的影响。</p>
<p>完整渲染后的三角形在屏幕上会是这样的：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_filled.png" alt="img"></p>
<p>由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。</p>
<p>多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。<strong>我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。</strong></p>
<p><img src="https://learnopengl-cn.github.io/img/04/11/anti_aliasing_sample_points.png" alt="img"></p>
<p>对于图中的例子，我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。</p>
<p>MSAA的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行<strong>一次</strong>片段着色器。片段着色器所使用的顶点数据会插值到每个像素的<strong>中心</strong>，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。</p>
<p>这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_samples.png" alt="img"></p>
<p>这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被遮盖，所以片段着色器的结果将只会储存到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所储存的颜色来决定。</p>
<p>简单来说，一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下的效果：</p>
<p><img src="https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_samples_filled.png" alt="img"></p>
<p>对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。</p>
<p>不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>
<p>（可以简单看看知乎上<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/edliu/answers">@文刀秋二</a>对抗锯齿技术的<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20236638/answer/14438218">精彩介绍</a>）</p>
<h4 id="OpenGL中的MSAA"><a href="#OpenGL中的MSAA" class="headerlink" title="OpenGL中的MSAA"></a>OpenGL中的MSAA</h4><p>如果我们想要在OpenGL中使用MSAA，我们必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample Buffer)。</p>
<p>大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。GLFW同样给了我们这个功能，我们所要做的只是<strong>提示</strong>(Hint) GLFW，我们希望使用一个包含N个样本的多重采样缓冲。这可以在创建窗口之前调用<strong>glfwWindowHint</strong>来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwWindowHint</span>(GLFW_SAMPLES, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>现在再调用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会使用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。</p>
<p>现在我们已经向GLFW请求了多重采样缓冲，我们还需要调用glEnable并启用GL_MULTISAMPLE，来启用多重采样。<strong>在大多数OpenGL的驱动上，多重采样都是默认启用的，所以这个调用可能会有点多余，但显式地调用一下会更保险一点。</strong>这样子不论是什么OpenGL的实现都能够正常启用多重采样了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_MULTISAMPLE);</span><br></pre></td></tr></table></figure>

<p>只要默认的帧缓冲有了多重采样缓冲的附件，我们所要做的只是调用glEnable来启用多重采样。因为多重采样的算法都在OpenGL驱动的光栅器中实现了，我们不需要再多做什么。</p>
<h4 id="离屏MSAA"><a href="#离屏MSAA" class="headerlink" title="离屏MSAA"></a>离屏MSAA</h4><p>由于GLFW负责了创建多重采样缓冲，启用MSAA非常简单。然而，如果我们想要<strong>使用我们自己的帧缓冲来进行离屏渲染，那么我们就必须要自己动手生成多重采样缓冲了。</strong></p>
<p>有两种方式可以创建多重采样缓冲，将其作为帧缓冲的附件：纹理附件和渲染缓冲附件，这和在[帧缓冲](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/04">https://learnopengl-cn.github.io/04</a> Advanced OpenGL&#x2F;05 Framebuffers&#x2F;)教程中所讨论的普通附件很相似。</p>
<h5 id="多重采样纹理附件"><a href="#多重采样纹理附件" class="headerlink" title="多重采样纹理附件"></a>多重采样纹理附件</h5><p>为了创建一个支持储存多个采样点的纹理，我们使用glTexImage2DMultisample来替代glTexImage2D，它的纹理目标是GL_TEXTURE_2D_MULTISAPLE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_MULTISAMPLE, tex);</span><br><span class="line"><span class="built_in">glTexImage2DMultisample</span>(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D_MULTISAMPLE, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。</span></span><br><span class="line"><span class="comment">//我们使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是GL_TEXTURE_2D_MULTISAMPLE。</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//当前绑定的帧缓冲现在就有了一个纹理图像形式的多重采样颜色缓冲。</span></span><br></pre></td></tr></table></figure>

<h5 id="多重采样渲染缓冲对象"><a href="#多重采样渲染缓冲对象" class="headerlink" title="多重采样渲染缓冲对象"></a>多重采样渲染缓冲对象</h5><p>和纹理类似，创建一个多重采样渲染缓冲对象并不难。我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将glRenderbufferStorage的调用改为glRenderbufferStorageMultisample就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glRenderbufferStorageMultisample</span>(GL_RENDERBUFFER, <span class="number">4</span>, GL_DEPTH24_STENCIL8, width, height);</span><br><span class="line"><span class="comment">//函数中，渲染缓冲对象后的参数我们将设定为样本的数量，在当前的例子中是4。</span></span><br></pre></td></tr></table></figure>

<h5 id="渲染到多重采样帧缓冲"><a href="#渲染到多重采样帧缓冲" class="headerlink" title="渲染到多重采样帧缓冲"></a>渲染到多重采样帧缓冲</h5><p>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及&#x2F;或深度和模板缓冲。<strong>因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</strong></p>
<p><strong>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。</strong>多重采样帧缓冲的还原通常是通过<strong>glBlitFramebuffer</strong>来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</p>
<p>glBlitFramebuffer会将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中。你可能记得在[帧缓冲](<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/04">https://learnopengl-cn.github.io/04</a> Advanced OpenGL&#x2F;05 Framebuffers&#x2F;)教程中，当我们绑定到GL_FRAMEBUFFER时，我们是同时绑定了读取和绘制的帧缓冲目标。我们也可以将帧缓冲分开绑定至GL_READ_FRAMEBUFFER与GL_DRAW_FRAMEBUFFER。glBlitFramebuffer函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，我们可以将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, multisampledFBO);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br></pre></td></tr></table></figure>

<p>但如果我们想要使用多重采样帧缓冲的纹理输出来做像是后期处理这样的事情呢？我们不能直接在片段着色器中使用多重采样的纹理。但我们能做的是将多重采样缓冲位块传送到一个没有使用多重采样纹理附件的FBO中。然后用这个普通的颜色附件来做后期处理，从而达到我们的目的。然而，这也意味着我们需要生成一个新的FBO，作为中介帧缓冲对象，将多重采样缓冲还原为一个能在着色器中使用的普通2D纹理。这个过程的伪代码是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> msFBO = <span class="built_in">CreateFBOWithMultiSampledAttachments</span>();</span><br><span class="line"><span class="comment">// 使用普通的纹理颜色附件创建一个新的FBO</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, screenTexture, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(msFBO);</span><br><span class="line">    <span class="built_in">ClearFrameBuffer</span>();</span><br><span class="line">    <span class="built_in">DrawScene</span>();</span><br><span class="line">    <span class="comment">// 将多重采样缓冲还原到中介FBO上</span></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, msFBO);</span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, intermediateFBO);</span><br><span class="line">    <span class="built_in">glBlitFramebuffer</span>(<span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);</span><br><span class="line">    <span class="comment">// 现在场景是一个2D纹理缓冲，可以将这个图像用来后期处理</span></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ClearFramebuffer</span>();</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, screenTexture);</span><br><span class="line">    <span class="built_in">DrawPostProcessingQuad</span>();  </span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将多重采样与离屏渲染结合起来，我们需要自己负责一些额外的细节。但所有的这些细节都是值得额外的努力的，因为多重采样能够显著提升场景的视觉质量。当然，要注意，如果使用的采样点非常多，启用多重采样会显著降低程序的性能。</p>
<h5 id="自定义抗锯齿算法"><a href="#自定义抗锯齿算法" class="headerlink" title="自定义抗锯齿算法"></a>自定义抗锯齿算法</h5><p>将一个多重采样的纹理图像不进行还原直接传入着色器也是可行的。GLSL提供了这样的选项，让我们能够对纹理图像的每个子样本进行采样，所以我们可以创建我们自己的抗锯齿算法。在大型的图形应用中通常都会这么做。</p>
<p>要想获取每个子样本的颜色值，你需要将纹理uniform采样器设置为sampler2DMS，而不是平常使用的sampler2D：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2DMS</span> screenTextureMS;</span><br></pre></td></tr></table></figure>

<p>使用texelFetch函数就能够获取每个子样本的颜色值了：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> colorSample = <span class="built_in">texelFetch</span>(screenTextureMS, TexCoords, <span class="number">3</span>);  <span class="comment">// 第4个子样本</span></span><br></pre></td></tr></table></figure>

<h2 id="高级光照"><a href="#高级光照" class="headerlink" title="高级光照"></a>高级光照</h2><h3 id="Blinn-Phong"><a href="#Blinn-Phong" class="headerlink" title="Blinn-Phong"></a>Blinn-Phong</h3><p>冯氏光照不仅对真实光照有很好的近似，而且性能也很高。但是它的镜面反射会在一些情况下出现问题，特别是物体反光度很低时，会导致大片（粗糙的）高光区域。下面这张图展示了当反光度为1.0时地板会出现的效果：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/01/advanced_lighting_phong_limit.png" alt="img"></p>
<p>可以看到，在镜面高光区域的边缘出现了一道很明显的断层。出现这个问题的原因是观察向量和反射向量间的夹角不能大于90度。如果点积的结果为负数，镜面光分量会变为0.0。你可能会觉得，当光线与视线夹角大于90度时你应该不会接收到任何光才对，所以这不是什么问题。</p>
<p>然而，这种想法仅仅只适用于漫反射分量。当考虑漫反射光的时候，如果法线和光源夹角大于90度，光源会处于被照表面的下方，这个时候光照的漫反射分量的确是为0.0。但是，在考虑镜面高光时，我们测量的角度并不是光源与法线的夹角，而是视线与反射光线向量的夹角。看一下下面这两张图：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/01/advanced_lighting_over_90.png" alt="img"></p>
<p>现在问题就应该很明显了。左图中是我们熟悉的冯氏光照中的反射向量，其中$\theta$角小于90度。而右图中，视线与反射方向之间的夹角明显大于90度，这种情况下镜面光分量会变为0.0。这在大多数情况下都不是什么问题，因为观察方向离反射方向都非常远。然而，<strong>当物体的反光度非常小时，它产生的镜面高光半径足以让这些相反方向的光线对亮度产生足够大的影响。在这种情况下就不能忽略它们对镜面光分量的贡献了。</strong></p>
<p>1977年，James F. Blinn在冯氏着色模型上加以拓展，引入了Blinn-Phong着色模型。Blinn-Phong模型与冯氏模型非常相似，但是它对镜面光模型的处理上有一些不同，让我们能够解决之前提到的问题。<strong>Blinn-Phong模型不再依赖于反射向量，而是采用了所谓的半程向量(Halfway Vector)，即光线与视线夹角一半方向上的一个单位向量。</strong>当半程向量与法线向量越接近时，镜面光分量就越大。</p>
<p><img src="https://learnopengl-cn.github.io/img/05/01/advanced_lighting_halfway_vector.png" alt="img"></p>
<p>当视线正好与（现在不需要的）反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。</p>
<p>现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与冯氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。</p>
<p>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> lightDir   = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> viewDir    = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);</span><br><span class="line"><span class="comment">//接下来，镜面光分量的实际计算只不过是对表面法线和半程向量进行一次约束点乘(Clamped Dot Product)，让点乘结果不为负，从而获取它们之间夹角的余弦值，之后我们对这个值取反光度次方：</span></span><br><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), shininess);</span><br><span class="line"><span class="type">vec3</span> specular = lightColor * spec;</span><br></pre></td></tr></table></figure>

<p>除此之外Blinn-Phong模型就没什么好说的了，Blinn-Phong与冯氏模型唯一的区别就是，Blinn-Phong测量的是法线与半程向量之间的夹角，而冯氏模型测量的是观察方向与反射向量间的夹角。</p>
<p>在引入半程向量之后，我们现在应该就不会再看到冯氏光照中高光断层的情况了。下面两个图片展示的是两种方法在镜面光分量为0.5时的对比：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/01/advanced_lighting_comparrison.png" alt="img"></p>
<p>除此之外，冯氏模型与Blinn-Phong模型也有一些细微的差别：<strong>半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和冯氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。</strong>通常我们会选择冯氏着色时反光度分量的2到4倍。</p>
<p>下面是冯氏着色反光度为8.0，Blinn-Phong着色反光度为32.0时的一个对比：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/01/advanced_lighting_comparrison2.png" alt="img"></p>
<p>Blinn-Phong的镜面光分量会比冯氏模型更锐利一些。为了得到与冯氏模型类似的结果，你可能会需要不断进行一些微调，但Blinn-Phong模型通常会产出更真实的结果。</p>
<h3 id="Gamma校正"><a href="#Gamma校正" class="headerlink" title="Gamma校正"></a>Gamma校正</h3><p>当我们计算出场景中所有像素的最终颜色以后，我们就必须把它们显示在监视器上。过去，大多数监视器是阴极射线管显示器（CRT）。这些监视器有一个物理特性就是两倍的输入电压产生的不是两倍的亮度。输入电压产生约为输入电压的2.2次幂的亮度，这叫做监视器Gamma。</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230211141355932.png" alt="image-20230211141355932"></p>
<p>人类所感知的亮度恰好和CRT所显示出来相似的指数关系非常匹配。为了更好的理解所有含义，请看下面的图片：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/02/gamma_correction_brightness.png" alt="img"></p>
<p>第一行是人眼所感知到的正常的灰阶，亮度要增加一倍（比如从0.1到0.2）你才会感觉比原来变亮了一倍（译注：我们在看颜色值从0到1（从黑到白）的过程中，亮度要增加一倍，我们才会感受到明显的颜色变化（变亮一倍）。打个比方：颜色值从0.1到0.2，我们会感受到一倍的颜色变化，而从0.4到0.8我们才能感受到相同程度（变亮一倍）的颜色变化。</p>
<p>然而，当我们谈论光的物理亮度，比如光源发射光子的数量的时候，底部（第二行）的灰阶显示出的才是物理世界真实的亮度。如底部的灰阶显示，亮度加倍时返回的也是真实的物理亮度（译注：这里亮度是指光子数量和正相关的亮度，即物理亮度，前面讨论的是人的感知亮度；物理亮度和感知亮度的区别在于，物理亮度基于光子数量，感知亮度基于人的感觉，比如第二个灰阶里亮度0.1的光子数量是0.2的二分之一），但是由于这与我们的眼睛感知亮度不完全一致（对比较暗的颜色变化更敏感），所以它看起来有差异。</p>
<p>因为人眼看到颜色的亮度更倾向于顶部的灰阶，监视器使用的也是一种指数关系（电压的2.2次幂），所以物理亮度通过监视器能够被映射到顶部的非线性亮度；因此看起来效果不错（译注：CRT亮度是是电压的2.2次幂而人眼相当于2次幂，因此CRT这个缺陷正好能满足人的需要）。</p>
<p>监视器的这个非线性映射的确可以让亮度在我们眼中看起来更好，但当渲染图像时，会产生一个问题：我们在应用中配置的亮度和颜色是基于监视器所看到的，这样所有的配置实际上是非线性的亮度&#x2F;颜色配置。请看下图：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/02/gamma_correction_gamma_curves.png" alt="img"></p>
<p>点线代表线性颜色&#x2F;亮度值（译注：这表示的是理想状态，Gamma为1），实线代表监视器显示的颜色。如果我们把一个点线线性的颜色翻一倍，结果就是这个值的两倍。比如，光的颜色向量(0.5,0.0,0.0)代表的是暗红色。如果我们在线性空间中把它翻倍，就会变成(1.0,0.0,0.0)，就像你在图中看到的那样。然而，由于我们定义的颜色仍然需要输出的监视器上，监视器上显示的实际颜色就会是 (0.218,0.0,0.0)。在这儿问题就出现了：当我们将理想中直线上的那个暗红色翻一倍时，在监视器上实际上亮度翻了4.5倍以上！</p>
<p>直到现在，我们还一直假设我们所有的工作都是在线性空间中进行的（译注：Gamma为1），但最终还是要把所有的颜色输出到监视器上，所以我们配置的所有颜色和光照变量从物理角度来看都是不正确的，在我们的监视器上很少能够正确地显示。出于这个原因，我们（以及艺术家）通常将光照值设置得比本来更亮一些（由于监视器会将其亮度显示的更暗一些），如果不是这样，在线性空间里计算出来的光照就会不正确。同时，还要记住，监视器所显示出来的图像和线性图像的最小亮度是相同的，它们最大的亮度也是相同的；只是中间亮度部分会被压暗。</p>
<p>因为所有中间亮度都是线性空间计算出来的（译注：计算的时候假设Gamma为1）监视器显以后，实际上都会不正确。当使用更高级的光照算法时，这个问题会变得越来越明显，你可以看看下图：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/02/gamma_correction_example.png" alt="img"></p>
<h4 id="校正"><a href="#校正" class="headerlink" title="校正"></a>校正</h4><p>Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。回头看前面的Gamma曲线图，你会有一个短划线，它是监视器Gamma曲线的翻转曲线。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。</p>
<p>我们来看另一个例子。还是那个暗红色(0.5,0.0,0.0)。在将颜色显示到监视器之前，我们先对颜色应用Gamma校正曲线。线性的颜色显示在监视器上相当于降低了2.2次幂的亮度，所以倒数就是1&#x2F;2.2次幂。Gamma校正后的暗红色就会成为(0.5,0.0,0.0)1&#x2F;2.2&#x3D;(0.5,0.0,0.0)0.45&#x3D;(0.73,0.0,0.0)。校正后的颜色接着被发送给监视器，最终显示出来的颜色是(0.73,0.0,0.0)2.2&#x3D;(0.5,0.0,0.0)。你会发现使用了Gamma校正，监视器最终会显示出我们在应用中设置的那种线性的颜色。</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230211151316995.png" alt="image-20230211151316995"></p>
<p>有两种在你的场景中应用gamma校正的方式：</p>
<p><strong>使用OpenGL内建的sRGB帧缓冲。 自己在像素着色器中进行gamma校正。</strong> 第一个选项也许是最简单的方式，但是我们也会丧失一些控制权。开启GL_FRAMEBUFFER_SRGB，可以告诉OpenGL每个后续的绘制命令里，在颜色储存到颜色缓冲之前先校正sRGB颜色。sRGB这个颜色空间大致对应于gamma2.2，它也是家用设备的一个标准。开启GL_FRAMEBUFFER_SRGB以后，每次像素着色器运行后续帧缓冲，OpenGL将自动执行gamma校正，包括默认帧缓冲。</p>
<p>开启GL_FRAMEBUFFER_SRGB简单的调用glEnable就行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glEnable</span>(GL_FRAMEBUFFER_SRGB);</span><br></pre></td></tr></table></figure>

<p>自此，你渲染的图像就被进行gamma校正处理，你不需要做任何事情硬件就帮你处理了。有时候，你应该记得这个建议：gamma校正将把线性颜色空间转变为非线性空间，所以在最后一步进行gamma校正是极其重要的。如果你在最后输出之前就进行gamma校正，所有的后续操作都是在操作不正确的颜色值。例如，如果你使用多个帧缓冲，你可能打算让两个帧缓冲之间传递的中间结果仍然保持线性空间颜色，只是给发送给监视器的最后的那个帧缓冲应用gamma校正。</p>
<p>第二个方法稍微复杂点，但同时也是我们对gamma操作有完全的控制权。我们在每个相关像素着色器运行的最后应用gamma校正，所以在发送到帧缓冲前，颜色就被校正了。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do super fancy lighting </span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// apply gamma correction</span></span><br><span class="line">    <span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line">    fragColor.rgb = <span class="built_in">pow</span>(fragColor.rgb, <span class="type">vec3</span>(<span class="number">1.0</span>/gamma));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一行代码，将fragColor的每个颜色元素应用有一个1.0&#x2F;gamma的幂运算，校正像素着色器的颜色输出。</p>
<p>这个方法有个问题就是为了保持一致，你必须在像素着色器里加上这个gamma校正，所以如果你有很多像素着色器，它们可能分别用于不同物体，那么你就必须在每个着色器里都加上gamma校正了。一个更简单的方案是在你的渲染循环中引入后处理阶段，在后处理四边形上应用gamma校正，这样你只要做一次就好了。</p>
<p>这些单行代码代表了gamma校正的实现。不太令人印象深刻，但当你进行gamma校正的时候有一些额外的事情别忘了考虑。</p>
<h4 id="sRGB纹理"><a href="#sRGB纹理" class="headerlink" title="sRGB纹理"></a>sRGB纹理</h4><p>因为监视器总是在sRGB空间中显示应用了gamma的颜色，无论什么时候当你在计算机上绘制、编辑或者画出一个图片的时候，你所选的颜色都是根据你在监视器上看到的那种。这实际意味着所有你创建或编辑的图片并不是在线性空间，而是在sRGB空间中（译注：sRGB空间定义的gamma接近于2.2），假如在你的屏幕上对暗红色翻一倍，便是根据你所感知到的亮度进行的，并不等于将红色元素加倍。</p>
<p>结果就是纹理编辑者，所创建的所有纹理都是在sRGB空间中的纹理，所以如果我们在渲染应用中使用这些纹理，我们必须考虑到这点。在我们应用gamma校正之前，这不是个问题，因为纹理在sRGB空间创建和展示，同样我们还是在sRGB空间中使用，从而不必gamma校正纹理显示也没问题。然而，现在我们是把所有东西都放在线性空间中展示的，纹理颜色就会变坏，如下图展示的那样：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/02/gamma_correction_srgbtextures.png" alt="img"></p>
<p>纹理图像实在太亮了，发生这种情况是因为，<strong>它们实际上进行了两次gamma校正</strong>！想一想，当我们基于监视器上看到的情况创建一个图像，我们就已经对颜色值进行了gamma校正，所以再次显示在监视器上就没错。由于我们在渲染中又进行了一次gamma校正，图片就实在太亮了。</p>
<p>为了修复这个问题，我们得确保纹理制作者是在线性空间中进行创作的。但是，由于大多数纹理制作者并不知道什么是gamma校正，并且在sRGB空间中进行创作更简单，这也许不是一个好办法。</p>
<p>另一个解决方案是重校，或把这些sRGB纹理在进行任何颜色值的计算前变回线性空间。我们可以这样做：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> gamma = <span class="number">2.2</span>;</span><br><span class="line"><span class="type">vec3</span> diffuseColor = <span class="built_in">pow</span>(<span class="built_in">texture</span>(diffuse, texCoords).rgb, <span class="type">vec3</span>(gamma));</span><br></pre></td></tr></table></figure>

<p>为每个sRGB空间的纹理做这件事非常烦人。幸好，OpenGL给我们提供了另一个方案来解决我们的麻烦，这就是<strong>GL_SRGB和GL_SRGB_ALPHA内部纹理格式。</strong></p>
<p>如果我们在OpenGL中创建了一个纹理，把它指定为以上两种sRGB纹理格式其中之一，OpenGL将自动把颜色校正到线性空间中，这样我们所使用的所有颜色值都是在线性空间中的了。我们可以这样把一个纹理指定为一个sRGB纹理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_SRGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, image);</span><br></pre></td></tr></table></figure>

<p>如果你还打算在你的纹理中引入alpha元素，必究必须将纹理的内部格式指定为GL_SRGB_ALPHA。</p>
<p><strong>因为不是所有纹理都是在sRGB空间中的所以当你把纹理指定为sRGB纹理时要格外小心。比如diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的</strong>。而为了获取光照参数的纹理，<strong>像specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了</strong>。指定sRGB纹理时要当心。</p>
<p>将diffuse纹理定义为sRGB纹理之后，你将获得你所期望的视觉输出，但这次每个物体都会只进行一次gamma校正。</p>
<h4 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h4><p>在使用了gamma校正之后，另一个不同之处是光照衰减(Attenuation)。真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / (<span class="built_in">distance</span> * <span class="built_in">distance</span>);</span><br></pre></td></tr></table></figure>

<p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。出于这个原因，我们使用在基本光照教程中所讨论的那种衰减方程，它给了我们更大的控制权，此外我们还可以使用双曲线函数：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / <span class="built_in">distance</span>;</span><br></pre></td></tr></table></figure>

<p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后线性衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。下图显示了其中的不同：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/02/gamma_correction_attenuation.png" alt="img"></p>
<p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在监视器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成(1.0&#x2F;distance^2)2.2。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了(1.0&#x2F;distance)2.2&#x3D;2.2&#x2F;distance。这和物理公式是很相似的。</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230211154539664.png" alt="image-20230211154539664"></p>
<p>总而言之，gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数的原因。</p>
<h3 id="阴影映射"><a href="#阴影映射" class="headerlink" title="阴影映射"></a>阴影映射</h3><p>阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系。场景和物体的深度感因此能够得到极大提升，下图展示了有阴影和没有阴影的情况下的不同：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_with_without.png" alt="img"></p>
<p>有阴影的时候你能更容易地区分出物体之间的位置关系，例如，当使用阴影的时候浮在地板上的立方体的事实更加清晰。</p>
<p>阴影还是比较不好实现的，因为当前实时渲染领域还没找到一种完美的阴影算法。目前有几种近似阴影技术，但它们都有自己的弱点和不足，这点我们必须要考虑到。</p>
<p>游戏中较多使用的一种技术是阴影贴图（shadow mapping），效果不错，而且相对容易实现。阴影贴图并不难以理解，性能也不会太低，而且非常容易扩展成更高级的算法（比如 <a target="_blank" rel="noopener" href="http://learnopengl.com/#!Advanced-Lighting/Shadows/Point-Shadows">Omnidirectional Shadow Maps</a>和 <a target="_blank" rel="noopener" href="http://learnopengl.com/#!Advanced-Lighting/Shadows/CSM">Cascaded Shadow Maps</a>）。</p>
<p>**阴影映射(Shadow Mapping)**背后的思路非常简单：我们以光的位置为视角进行渲染，我们能看到的东西都将被点亮，看不见的一定是在阴影之中了。假设有一个地板，在光源和它之间有一个大盒子。由于光源处向光线方向看去，可以看到这个盒子，但看不到地板的一部分，这部分就应该在阴影中了。</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_theory.png" alt="img"></p>
<p>这里的所有蓝线代表光源可以看到的fragment。黑线代表被遮挡的fragment：它们应该渲染为带阴影的。如果我们绘制一条从光源出发，到达最右边盒子上的一个片段上的线段或射线，那么射线将先击中悬浮的盒子，随后才会到达最右侧的盒子。结果就是悬浮的盒子被照亮，而最右侧的盒子将处于阴影之中。</p>
<p>我们希望得到射线第一次击中的那个物体，然后用这个最近点和射线上其他点进行对比。然后我们将测试一下看看射线上的其他点是否比最近点更远，如果是的话，这个点就在阴影中。<strong>对从光源发出的射线上的成千上万个点进行遍历是个极端消耗性能的举措，实时渲染上基本不可取。我们可以采取相似举措，不用投射出光的射线。我们所使用的是非常熟悉的东西：深度缓冲。</strong></p>
<p>在深度缓冲里的一个值是摄像机视角下，对应于一个片段的一个0到1之间的深度值。如果我们从光源的透视图来渲染场景，并把深度值的结果储存到纹理中会怎样？通过这种方式，我们就能对光源的透视图所见的最近的深度值进行采样。最终，深度值就会显示从光源的透视图下见到的第一个片段了。<strong>我们管储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。</strong></p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_theory_spaces.png" alt="img"></p>
<p>左侧的图片展示了一个定向光源（所有光线都是平行的）在立方体下的表面投射的阴影。通过储存到深度贴图中的深度值，我们就能找到最近点，用以决定片段是否在阴影中。我们使用一个来自光源的视图和投影矩阵来渲染场景就能创建一个深度贴图。这个投影和视图矩阵结合在一起成为一个T变换，它可以将任何三维位置转变到光源的可见坐标空间。</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230212180948801.png" alt="image-20230212180948801"></p>
<p>在右边的图中我们显示出同样的平行光和观察者。我们渲染一个点P处的片段，需要决定它是否在阴影中。我们先得使用T把P变换到光源的坐标空间里。既然点P是从光的透视图中看到的，它的z坐标就对应于它的深度，例子中这个值是0.9。使用点P在光源的坐标空间的坐标，我们可以索引深度贴图，来获得从光的视角中最近的可见深度，结果是点C，最近的深度是0.4。因为索引深度贴图的结果是一个小于点P的深度，我们可以断定P被挡住了，它在阴影中了。</p>
<p>阴影映射由两个步骤组成：首先，我们渲染深度贴图，然后我们像往常一样渲染场景，使用生成的深度贴图来计算片段是否在阴影之中。</p>
<h4 id="深度贴图"><a href="#深度贴图" class="headerlink" title="深度贴图"></a>深度贴图</h4><p>第一步我们需要生成一张深度贴图(Depth Map)。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，我们将再次需要帧缓冲。</p>
<p>首先，我们要为渲染的深度贴图创建一个帧缓冲对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthMapFBO;</span><br><span class="line"><span class="built_in">glGenFramebuffers</span>(<span class="number">1</span>, &amp;depthMapFBO);</span><br></pre></td></tr></table></figure>

<p>然后，创建一个2D纹理，提供给帧缓冲的深度缓冲使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">GLuint depthMap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthMap);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); </span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br></pre></td></tr></table></figure>

<p>生成深度贴图不太复杂。因为我们只关心深度值，我们要把纹理格式指定为GL_DEPTH_COMPONENT。我们还要把纹理的高宽设置为1024：这是深度贴图的分辨率。</p>
<p>把我们把生成的深度纹理作为帧缓冲的深度缓冲：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。然而，不包含颜色缓冲的帧缓冲对象是不完整的，所以我们需要<strong>显式告诉OpenGL我们不适用任何颜色数据进行渲染。我们通过将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE</strong>来做这件事。</p>
<p>合理配置将深度值渲染到纹理的帧缓冲后，我们就可以开始第一步了：生成深度贴图。两个步骤的完整的渲染阶段，看起来有点像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首选渲染深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. 像往常一样渲染场景，但这次使用深度贴图</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, depthMap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这段代码隐去了一些细节，但它表达了阴影映射的基本思路。这里一定要记得调用glViewport。因为<strong>阴影贴图经常和我们原来渲染的场景（通常是窗口分辨率）有着不同的分辨率，我们需要改变视口（viewport）的参数以适应阴影贴图的尺寸</strong>。如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</p>
<h4 id="光源空间的变换"><a href="#光源空间的变换" class="headerlink" title="光源空间的变换"></a>光源空间的变换</h4><p>一个不清楚的函数是<code>ConfigureShaderAndMatrices</code>。它是用来在第二个步骤确保为每个物体设置了合适的投影和视图矩阵，以及相关的模型矩阵。然而，第一个步骤中，我们从光的位置的视野下使用了不同的投影和视图矩阵来渲染的场景。</p>
<p>因为我们使用的是一个所有光线都平行的定向光。出于这个原因，我们将为光源使用正交投影矩阵，透视图将没有任何变形：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLfloat near_plane = <span class="number">1.0f</span>, far_plane = <span class="number">7.5f</span>;</span><br><span class="line">glm::mat4 lightProjection = glm::<span class="built_in">ortho</span>(<span class="number">-10.0f</span>, <span class="number">10.0f</span>, <span class="number">-10.0f</span>, <span class="number">10.0f</span>, near_plane, far_plane);</span><br><span class="line"><span class="comment">//这里使用正交投影矩阵</span></span><br></pre></td></tr></table></figure>

<p>为了创建一个视图矩阵来变换每个物体，把它们变换到从光源视角可见的空间中，我们将使用glm::lookAt函数；这次从光源的位置看向场景中央。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::<span class="type">mat4</span> lightView = glm::lookAt(glm::vec(<span class="number">-2.0</span>f, <span class="number">4.0</span>f, <span class="number">-1.0</span>f), glm::<span class="type">vec3</span>(<span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="number">0.0</span>f), glm::<span class="type">vec3</span>(<span class="number">0.0</span>f, <span class="number">1.0</span>f, <span class="number">0.0</span>f));</span><br></pre></td></tr></table></figure>

<p>二者相结合为我们提供了一个<strong>光空间的变换矩阵，它将每个世界空间坐标变换到光源处所见到的那个空间</strong>；这正是我们渲染深度贴图所需要的。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::<span class="type">mat4</span> lightSpaceMatrix = lightProjection * lightView;</span><br></pre></td></tr></table></figure>

<p>这个lightSpaceMatrix正是前面我们称为T的那个变换矩阵。<strong>有了lightSpaceMatrix只要给shader提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。然而，我们只关心深度值，并非所有片段计算都在我们的着色器中进行。为了提升性能，我们将使用一个与之不同但更为简单的着色器来渲染出深度贴图。</strong></p>
<h4 id="渲染至深度贴图"><a href="#渲染至深度贴图" class="headerlink" title="渲染至深度贴图"></a>渲染至深度贴图</h4><p>当我们以光的透视图进行场景渲染的时候，我们会用一个比较简单的着色器，这个着色器除了把顶点变换到光空间以外，不会做得更多了。这个简单的着色器叫做<code>simpleDepthShader</code>，就是使用下面的这个着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> lightSpaceMatrix;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = lightSpaceMatrix * model * <span class="type">vec4</span>(position, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个顶点着色器将一个单独模型的一个顶点，使用lightSpaceMatrix变换到光空间中。</p>
<p>由于我们没有颜色缓冲，最后的片段不需要任何处理，所以我们可以简单地使用一个空片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    <span class="comment">// gl_FragDepth = gl_FragCoord.z;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个空片段着色器什么也不干，运行完后，深度缓冲会被更新。我们可以取消那行的注释，来显式设置深度，但是这个（指注释掉那行之后）是更有效率的，因为底层无论如何都会默认去设置深度缓冲。</p>
<p>渲染深度缓冲现在成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">simpleDepthShader.<span class="built_in">Use</span>();</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(lightSpaceMatrixLocation, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(lightSpaceMatrix));</span><br><span class="line"></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">RenderScene</span>(simpleDepthShader);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这里的RenderScene函数的参数是一个着色器程序（shader program），它调用所有相关的绘制函数，并在需要的地方设置相应的模型矩阵。</p>
<p>要注意的是<strong>当用透视投影矩阵取代正交投影矩阵来显示深度时，有一些轻微的改动，因为使用透视投影时，深度是非线性的。</strong>本节教程的最后，我们会讨论这些不同之处。</p>
<h4 id="渲染阴影"><a href="#渲染阴影" class="headerlink" title="渲染阴影"></a>渲染阴影</h4><p>正确地生成深度贴图以后我们就可以开始生成阴影了。这段代码在片段着色器中执行，用来检验一个片段是否在阴影之中，不过我们在顶点着色器中进行光空间的变换：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> normal;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec3</span> Normal;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">    <span class="type">vec4</span> FragPosLightSpace;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> lightSpaceMatrix;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(position, <span class="number">1.0</span>f);</span><br><span class="line">    vs_out.FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="type">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">    vs_out.FragPosLightSpace = lightSpaceMatrix * <span class="type">vec4</span>(vs_out.FragPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这儿的新的地方是FragPosLightSpace这个输出向量。我们用同一个lightSpaceMatrix，把世界空间顶点位置转换为光空间。顶点着色器传递一个普通的经变换的世界空间顶点位置vs_out.FragPos和一个光空间的vs_out.FragPosLightSpace给片段着色器。</p>
<p>片段着色器使用Blinn-Phong光照模型渲染场景。我们接着计算出一个shadow值，当fragment在阴影中时是1.0，在阴影外是0.0。然后，diffuse和specular颜色会乘以这个阴影元素。由于阴影不会是全黑的（由于散射），我们把ambient分量从乘法中剔除。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec3</span> Normal;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">    <span class="type">vec4</span> FragPosLightSpace;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> diffuseTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> shadowMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ShadowCalculation(<span class="type">vec4</span> fragPosLightSpace)</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;           </span><br><span class="line">    <span class="type">vec3</span> color = <span class="built_in">texture</span>(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class="line">    <span class="type">vec3</span> normal = <span class="built_in">normalize</span>(fs_in.Normal);</span><br><span class="line">    <span class="type">vec3</span> lightColor = <span class="type">vec3</span>(<span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// Ambient</span></span><br><span class="line">    <span class="type">vec3</span> ambient = <span class="number">0.15</span> * color;</span><br><span class="line">    <span class="comment">// Diffuse</span></span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(lightDir, normal), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = diff * lightColor;</span><br><span class="line">    <span class="comment">// Specular</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">vec3</span> halfwayDir = <span class="built_in">normalize</span>(lightDir + viewDir);  </span><br><span class="line">    spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(normal, halfwayDir), <span class="number">0.0</span>), <span class="number">64.0</span>);</span><br><span class="line">    <span class="type">vec3</span> specular = spec * lightColor;    </span><br><span class="line">    <span class="comment">// 计算阴影</span></span><br><span class="line">    <span class="type">float</span> shadow = ShadowCalculation(fs_in.FragPosLightSpace);       </span><br><span class="line">    <span class="type">vec3</span> lighting = (ambient + (<span class="number">1.0</span> - shadow) * (diffuse + specular)) * color;    </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(lighting, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们声明一个shadowCalculation函数，用它计算阴影。片段着色器的最后，我们我们把diffuse和specular乘以(1-阴影元素)，这表示这个片段有多大成分不在阴影中。这个片段着色器还需要两个额外输入，一个是光空间的片段位置和第一个渲染阶段得到的深度贴图。</p>
<p>首先要检查一个片段是否在阴影中，把光空间片段位置转换为裁切空间的标准化设备坐标。当我们在顶点着色器输出一个裁切空间顶点位置到gl_Position时，OpenGL自动进行一个透视除法，将裁切空间坐标的范围-w到w转为-1到1，这要将x、y、z元素除以向量的w元素来实现。由于裁切空间的FragPosLightSpace并不会通过gl_Position传到片段着色器里，我们必须自己做透视除法：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> ShadowCalculation(<span class="type">vec4</span> fragPosLightSpace)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回了片段在光空间的-1到1的范围。</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230213170144263.png" alt="image-20230213170144263"></p>
<p>因为来自深度贴图的深度在0到1的范围，我们也打算使用projCoords从深度贴图中去采样，所以我们将NDC坐标变换为0到1的范围。 （译者注：这里的意思是，上面的projCoords的xyz分量都是[-1,1]（下面会指出这对于远平面之类的点才成立），而为了和深度贴图的深度相比较，z分量需要变换到[0,1]；为了作为从深度贴图中采样的坐标，xy分量也需要变换到[0,1]。所以整个projCoords向量都需要变换到[0,1]范围。）</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>

<p>有了这些投影坐标，我们就能从深度贴图中采样得到0到1的结果，从第一个渲染阶段的projCoords坐标直接对应于变换过的NDC坐标。我们将得到光的位置视野下最近的深度：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r;</span><br></pre></td></tr></table></figure>

<p>为了得到片段的当前深度，我们简单获取投影向量的z坐标，它等于来自光的透视视角的片段的深度。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> currentDepth = projCoords.z;</span><br></pre></td></tr></table></figure>

<p>实际的对比就是简单检查currentDepth是否高于closetDepth，如果是，那么片段就在阴影中。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>完整的shadowCalculation函数是这样的：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> ShadowCalculation(<span class="type">vec4</span> fragPosLightSpace)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行透视除法</span></span><br><span class="line">    <span class="type">vec3</span> projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;</span><br><span class="line">    <span class="comment">// 变换到[0,1]的范围</span></span><br><span class="line">    projCoords = projCoords * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">// 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(shadowMap, projCoords.xy).r; </span><br><span class="line">    <span class="comment">// 取得当前片段在光源视角下的深度</span></span><br><span class="line">    <span class="type">float</span> currentDepth = projCoords.z;</span><br><span class="line">    <span class="comment">// 检查当前片段是否在阴影中</span></span><br><span class="line">    <span class="type">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>激活这个着色器，绑定合适的纹理，激活第二个渲染阶段默认的投影以及视图矩阵，结果如下图所示：</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230213173851887.png" alt="image-20230213173851887"></p>
<h4 id="改进阴影贴图"><a href="#改进阴影贴图" class="headerlink" title="改进阴影贴图"></a>改进阴影贴图</h4><p><strong>阴影失真</strong></p>
<p>前面的图片中明显有不对的地方。放大看会发现明显的线条样式：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne.png" alt="img"></p>
<p>我们可以看到地板四边形渲染出很大一块交替黑线。这种阴影贴图的不真实感叫做**阴影失真(Shadow Acne)**，下图解释了成因：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne_diagram.png" alt="img"></p>
<p>因为阴影贴图受限于分辨率，在距离光源比较远的情况下，<strong>多个片段可能从深度贴图的同一个值中去采样。图片每个斜坡代表深度贴图一个单独的纹理像素。</strong>你可以看到，多个片段从同一个深度值进行采样。</p>
<p>虽然很多时候没问题，但是当光源以一个角度朝向表面的时候就会出问题，这种情况下深度贴图也是从一个角度下进行渲染的。<strong>多个片段就会从同一个斜坡的深度纹理像素中采样，有些在地板上面，有些在地板下面；这样我们所得到的阴影就有了差异。因为这个，有些片段被认为是在阴影之中，有些不在，由此产生了图片中的条纹样式。</strong></p>
<p>我们可以用一个叫做<strong>阴影偏移</strong>（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片段就不会被错误地认为在表面之下了。</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_acne_bias.png" alt="img"></p>
<p>使用了偏移量后，所有采样点都获得了比表面深度更小的深度值，这样整个表面就正确地被照亮，没有任何阴影。我们可以这样实现这个偏移：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="number">0.005</span>;</span><br><span class="line"><span class="type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>

<p>一个0.005的偏移就能帮到很大的忙，但是有些表面坡度很大，仍然会产生阴影失真。有一个更加可靠的办法能够根据表面朝向光线的角度更改偏移量：使用点乘：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> bias = <span class="built_in">max</span>(<span class="number">0.05</span> * (<span class="number">1.0</span> - <span class="built_in">dot</span>(normal, lightDir)), <span class="number">0.005</span>);</span><br></pre></td></tr></table></figure>

<p>这里我们有一个偏移量的最大值0.05，和一个最小值0.005，它们是基于表面法线和光照方向的。这样像地板这样的表面几乎与光源垂直，得到的偏移就很小，而比如立方体的侧面这种表面得到的偏移就更大。下图展示了同一个场景，但使用了阴影偏移，效果的确更好：</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230213174256371.png" alt="image-20230213174256371"></p>
<p><strong>悬浮</strong></p>
<p>使用阴影偏移的一个缺点是你对物体的实际深度应用了平移。偏移有可能足够大，以至于可以看出阴影相对实际物体位置的偏移，你可以从下图看到这个现象（这是一个夸张的偏移值）：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_peter_panning.png" alt="img"></p>
<p>这个阴影失真叫做悬浮(Peter Panning)，因为物体看起来轻轻悬浮在表面之上（译注：Peter Pan就是童话彼得潘，而panning有平移、悬浮之意，而且彼得潘是个会飞的男孩…）。我们可以使用一个叫技巧解决大部分的Peter panning问题：当渲染深度贴图时候使用正面剔除（front face culling）你也许记得在面剔除教程中OpenGL默认是背面剔除。我们要告诉OpenGL我们要剔除正面。</p>
<p>因为我们只需要深度贴图的深度值，对于实体物体无论我们用它们的正面还是背面都没问题。使用背面深度不会有错误，因为阴影在物体内部有错误我们也看不见。</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_culling.png" alt="img"></p>
<p>为了修复peter游移，我们要进行正面剔除，先必须开启GL_CULL_FACE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCullFace</span>(GL_FRONT);</span><br><span class="line"><span class="built_in">RenderSceneToDepthMap</span>();</span><br><span class="line"><span class="built_in">glCullFace</span>(GL_BACK); <span class="comment">// 不要忘记设回原先的culling face</span></span><br></pre></td></tr></table></figure>

<p>这十分有效地解决了peter panning的问题，但只对内部不会对外开口的实体物体有效。我们的场景中，在立方体上工作的很好，但在地板上无效，因为正面剔除完全移除了地板。地面是一个单独的平面，不会被完全剔除。如果有人打算使用这个技巧解决peter panning必须考虑到只有剔除物体的正面才有意义。</p>
<p><strong>另一个要考虑到的地方是接近阴影的物体仍然会出现不正确的效果。必须考虑到何时使用正面剔除对物体才有意义。不过使用普通的偏移值通常就能避免peter panning。</strong></p>
<p><strong>采样过多</strong></p>
<p>无论你喜不喜欢还有一个视觉差异，<strong>就是光的视锥不可见的区域一律被认为是处于阴影中，不管它真的处于阴影之中。</strong>出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围<strong>。根据纹理环绕方式，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。</strong></p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_outside_frustum.png" alt="img"></p>
<p>你可以在图中看到，光照有一个区域，超出该区域就成为了阴影；这个区域实际上代表着深度贴图的大小，这个贴图投影到了地板上。<strong>发生这种情况的原因是我们之前将深度贴图的环绕方式设置成了GL_REPEAT。</strong></p>
<p>我们宁可让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">GLfloat borderColor[] = &#123; <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span> &#125;;</span><br><span class="line"><span class="built_in">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure>

<p>现在如果我们采样深度贴图0到1坐标范围以外的区域，纹理函数总会返回一个1.0的深度值，阴影值为0.0。结果看起来会更真实：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_clamp_edge.png" alt="img"></p>
<p>仍有一部分是黑暗区域。那里的坐标超出了光的正交视锥的远平面。你可以看到这片黑色区域总是出现在光源视锥的极远处。</p>
<h4 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h4><p>阴影现在已经附着到场景中了，不过这仍不是我们想要的。如果你放大看阴影，阴影映射对分辨率的依赖很快变得很明显。</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_zoom.png" alt="img"></p>
<p>因为深度贴图有一个固定的分辨率，多个片段对应于一个纹理像素。结果就是多个片段会从深度贴图的同一个深度值进行采样，这几个片段便得到的是同一个阴影，这就会产生锯齿边。</p>
<p>你可以通过增加深度贴图的分辨率的方式来降低锯齿块，也可以尝试尽可能的让光的视锥接近场景。</p>
<p>另一个（并不完整的）解决方案叫做PCF（percentage-closer filtering），这是一种多个不同过滤方式的组合，它产生柔和阴影，使它们出现更少的锯齿块和硬边。核心思想是<strong>从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影：</strong></p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230213180711547.png" alt="image-20230213180711547"></p>
<h4 id="正交-vs-投影"><a href="#正交-vs-投影" class="headerlink" title="正交 vs 投影"></a>正交 vs 投影</h4><p>在渲染深度贴图的时候，正交(Orthographic)和投影(Projection)矩阵之间有所不同。正交投影矩阵并不会将场景用透视图进行变形，所有视线&#x2F;光线都是平行的，这使它对于定向光来说是个很好的投影矩阵。然而透视投影矩阵，会将所有顶点根据透视关系进行变形，结果因此而不同。下图展示了两种投影方式所产生的不同阴影区域：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/01/shadow_mapping_projection.png" alt="img"></p>
<p>透视投影对于光源来说更合理，不像定向光，它是有自己的位置的。<strong>透视投影因此更经常用在点光源和聚光灯上，而正交投影经常用在定向光上。</strong></p>
<p>另一个细微差别是，透视投影矩阵，将深度缓冲视觉化经常会得到一个几乎全白的结果。发生这个是因为<strong>透视投影下，深度变成了非线性的深度值，它的大多数可辨范围都位于近平面附近。为了可以像使用正交投影一样合适地观察深度值，你必须先将非线性深度值转变为线性的</strong>，如我们在深度测试教程中已经讨论过的那样。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> depthMap;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> near_plane;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> LinearizeDepth(<span class="type">float</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> z = depth * <span class="number">2.0</span> - <span class="number">1.0</span>; <span class="comment">// Back to NDC </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2.0</span> * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> depthValue = <span class="built_in">texture</span>(depthMap, TexCoords).r;</span><br><span class="line">    color = <span class="type">vec4</span>(<span class="type">vec3</span>(LinearizeDepth(depthValue) / far_plane), <span class="number">1.0</span>); <span class="comment">// perspective</span></span><br><span class="line">    <span class="comment">// color = vec4(vec3(depthValue), 1.0); // orthographic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个深度值与我们见到的用正交投影的很相似。需要注意的是，这个只适用于调试；正交或投影矩阵的深度检查仍然保持原样，因为相关的深度并没有改变。</p>
<h3 id="点阴影"><a href="#点阴影" class="headerlink" title="点阴影"></a>点阴影</h3><p>上一节中我们使用阴影映射创建了阴影，但是仅适合定向光；因为阴影只是在单一定向光源下生成的。所以它也叫定向阴影映射，深度（阴影）贴图生成自定向光的视角。</p>
<p>本节的焦点是在各种方向生成动态阴影。这个技术可以适用于点光源，生成所有方向上的阴影。</p>
<p>这个技术叫做点光阴影，过去的名字是万向阴影贴图（omnidirectional shadow maps）技术。</p>
<p>算法和定向阴影映射差不多：我们从光的透视图生成一个深度贴图，基于当前fragment位置来对深度贴图采样，然后用储存的深度值和每个fragment进行对比，看看它是否在阴影中。定向阴影映射和万向阴影映射的主要不同在于深度贴图的使用上。</p>
<p>对于深度贴图，我们需要从一个点光源的所有渲染场景，普通2D深度贴图不能工作；如果我们使用立方体贴图会怎样？因为立方体贴图可以储存6个面的环境数据，它可以将整个场景渲染到立方体贴图的每个面上，把它们当作点光源四周的深度值来采样。</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/02/point_shadows_diagram.png" alt="img"></p>
<p>生成后的深度立方体贴图被传递到光照像素着色器，它会用一个方向向量来采样立方体贴图，从而得到当前的fragment的深度（从光的透视图）。大部分复杂的事情已经在阴影映射教程中讨论过了。算法只是在深度立方体贴图生成上稍微复杂一点。</p>
<h4 id="生成深度立方体贴图"><a href="#生成深度立方体贴图" class="headerlink" title="生成深度立方体贴图"></a>生成深度立方体贴图</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    GLuint face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;</span><br><span class="line">    <span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">BindViewMatrix</span>(lightViewMatrices[i]);</span><br><span class="line">    <span class="built_in">RenderScene</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会很耗费性能因为一个深度贴图下需要进行很多渲染调用。这个教程中我们将转而使用另外的一个小技巧来做这件事，几何着色器允许我们使用一次渲染过程来建立深度立方体贴图。</p>
<p>首先，我们需要创建一个立方体贴图：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLuint depthCubemap;</span><br><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;depthCubemap);</span><br></pre></td></tr></table></figure>

<p>然后生成立方体贴图的每个面，将它们作为2D深度值纹理图像：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> GLuint SHADOW_WIDTH = <span class="number">1024</span>, SHADOW_HEIGHT = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="keyword">for</span> (GLuint i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">     <span class="built_in">glTexImage2D</span>(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="number">0</span>, GL_DEPTH_COMPONENT, </span><br><span class="line">                SHADOW_WIDTH, SHADOW_HEIGHT, <span class="number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>不要忘记设置合适的纹理参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);</span><br></pre></td></tr></table></figure>

<p>正常情况下，我们把立方体贴图纹理的一个面附加到帧缓冲对象上，渲染场景6次，每次将帧缓冲的深度缓冲目标改成不同立方体贴图面。<strong>由于我们将使用一个几何着色器，它允许我们把所有面在一个过程渲染，我们可以使用glFramebufferTexture直接把立方体贴图附加成帧缓冲的深度附件</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glReadBuffer</span>(GL_NONE);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>还要记得调用glDrawBuffer和glReadBuffer：当生成一个深度立方体贴图时我们只关心深度值，所以我们必须显式告诉OpenGL这个帧缓冲对象不会渲染到一个颜色缓冲里。</strong></p>
<p>万向阴影贴图有两个渲染阶段：首先我们生成深度贴图，然后我们正常使用深度贴图渲染，在场景中创建阴影。帧缓冲对象和立方体贴图的处理看起是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. first render to depth cubemap</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, depthMapFBO);</span><br><span class="line"><span class="built_in">glClear</span>(GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br><span class="line"><span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2. then render scene as normal with shadow mapping (using depth cubemap)</span></span><br><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"><span class="built_in">ConfigureShaderAndMatrices</span>();</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这个过程和默认的阴影映射一样，尽管这次我们渲染和使用的是一个立方体贴图深度纹理，而不是2D深度纹理。在我们实际开始从光的视角的所有方向渲染场景之前，我们先得计算出合适的变换矩阵。</p>
<h4 id="光空间的变换"><a href="#光空间的变换" class="headerlink" title="光空间的变换"></a>光空间的变换</h4><p>设置了帧缓冲和立方体贴图，我们需要一些方法来讲场景的所有几何体变换到6个光的方向中相应的光空间。与阴影映射教程类似，我们将需要一个光空间的变换矩阵T，但是这次是每个面都有一个。</p>
<p>每个光空间的变换矩阵包含了投影和视图矩阵。对于投影矩阵来说，我们将使用一个透视投影矩阵；光源代表一个空间中的点，所以透视投影矩阵更有意义。每个光空间变换矩阵使用同样的投影矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GLfloat aspect = (GLfloat)SHADOW_WIDTH/(GLfloat)SHADOW_HEIGHT;</span><br><span class="line">GLfloat near = <span class="number">1.0f</span>;</span><br><span class="line">GLfloat far = <span class="number">25.0f</span>;</span><br><span class="line">glm::mat4 shadowProj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), aspect, near, far);</span><br></pre></td></tr></table></figure>

<p>非常重要的一点是，这里glm::perspective的视野参数，设置为90度。90度我们才能保证视野足够大到可以合适地填满立方体贴图的一个面，立方体贴图的所有面都能与其他面在边缘对齐。</p>
<p>因为投影矩阵在每个方向上并不会改变，我们可以在6个变换矩阵中重复使用。我们要为每个方向提供一个不同的视图矩阵。用glm::lookAt创建6个观察方向，每个都按顺序注视着立方体贴图的的一个方向：右、左、上、下、近、远：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;glm::mat4&gt; shadowTransforms;</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">-1.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">1.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">1.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>));</span><br><span class="line">shadowTransforms.<span class="built_in">push_back</span>(shadowProj * </span><br><span class="line">                 glm::<span class="built_in">lookAt</span>(lightPos, lightPos + glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0</span>));</span><br></pre></td></tr></table></figure>

<p><strong>这里我们创建了6个视图矩阵，把它们乘以投影矩阵，来得到6个不同的光空间变换矩阵。glm::lookAt的target参数是它注视的立方体贴图的面的一个方向。</strong></p>
<p>这些变换矩阵发送到着色器渲染到立方体贴图里。</p>
<h4 id="深度着色器"><a href="#深度着色器" class="headerlink" title="深度着色器"></a>深度着色器</h4><p>为了把值渲染到深度立方体贴图，我们将需要3个着色器：顶点和像素着色器，以及一个它们之间的几何着色器。</p>
<p>几何着色器是负责将所有世界空间的顶点变换到6个不同的光空间的着色器。因此顶点着色器简单地将顶点变换到世界空间，然后直接发送到几何着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = model * <span class="type">vec4</span>(position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几何着色器以3个三角形的顶点作为输入，它还有一个光空间变换矩阵的uniform数组。几何着色器接下来会负责将顶点变换到光空间；这里它开始变得有趣了。</p>
<p>几何着色器有一个内建变量叫做gl_Layer，它指定发散出基本图形送到立方体贴图的哪个面。当不管它时，几何着色器就会像往常一样把它的基本图形发送到输送管道的下一阶段，但当我们更新这个变量就能控制每个基本图形将渲染到立方体贴图的哪一个面。当然这只有当我们有了一个附加到激活的帧缓冲的立方体贴图纹理才有效：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangles</span>) <span class="keyword">in</span>;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">triangle_strip</span>, <span class="keyword">max_vertices</span>=<span class="number">18</span>) <span class="keyword">out</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> shadowMatrices[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragPos; <span class="comment">// FragPos from GS (output per emitvertex)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> face = <span class="number">0</span>; face &lt; <span class="number">6</span>; ++face)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">gl_Layer</span> = face; <span class="comment">// built-in variable that specifies to which face we render.</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) <span class="comment">// for each triangle&#x27;s vertices</span></span><br><span class="line">        &#123;</span><br><span class="line">            FragPos = <span class="built_in">gl_in</span>[i].<span class="built_in">gl_Position</span>;</span><br><span class="line">            <span class="built_in">gl_Position</span> = shadowMatrices[face] * FragPos;</span><br><span class="line">            <span class="built_in">EmitVertex</span>();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">EndPrimitive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几何着色器相对简单。我们输入一个三角形，输出总共6个三角形（6*3顶点，所以总共18个顶点）。在main函数中，我们遍历立方体贴图的6个面，我们每个面指定为一个输出面，把这个面的interger（整数）存到gl_Layer。然后，我们通过把面的光空间变换矩阵乘以FragPos，将每个世界空间顶点变换到相关的光空间，生成每个三角形。注意，我们还要将最后的FragPos变量发送给像素着色器，我们需要计算一个深度值。</p>
<p>上个教程，我们使用的是一个空的像素着色器，让OpenGL配置深度贴图的深度值。这次我们将计算自己的深度，这个深度就是每个fragment位置和光源位置之间的线性距离。计算自己的深度值使得之后的阴影计算更加直观。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get distance between fragment and light source</span></span><br><span class="line">    <span class="type">float</span> lightDistance = <span class="built_in">length</span>(FragPos.xyz - lightPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map to [0;1] range by dividing by far_plane</span></span><br><span class="line">    lightDistance = lightDistance / far_plane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write this as modified depth</span></span><br><span class="line">    <span class="built_in">gl_FragDepth</span> = lightDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像素着色器将来自几何着色器的FragPos、光的位置向量和视锥的远平面值作为输入。这里我们把fragment和光源之间的距离，映射到0到1的范围，把它写入为fragment的深度值。</p>
<p>使用这些着色器渲染场景，立方体贴图附加的帧缓冲对象激活以后，你会得到一个完全填充的深度立方体贴图，以便于进行第二阶段的阴影计算。</p>
<h4 id="万向阴影贴图"><a href="#万向阴影贴图" class="headerlink" title="万向阴影贴图"></a>万向阴影贴图</h4><p>所有事情都做好了，是时候来渲染万向阴影(Omnidirectional Shadow)了。这个过程和定向阴影映射教程相似，尽管这次我们绑定的深度贴图是一个立方体贴图，而不是2D纹理，并且将光的投影的远平面发送给了着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, SCR_WIDTH, SCR_HEIGHT);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">shader.<span class="built_in">Use</span>();  </span><br><span class="line"><span class="comment">// ... send uniforms to shader (including light&#x27;s far_plane value)</span></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_CUBE_MAP, depthCubemap);</span><br><span class="line"><span class="comment">// ... bind other textures</span></span><br><span class="line"><span class="built_in">RenderScene</span>();</span><br></pre></td></tr></table></figure>

<p>这里的renderScene函数在一个大立方体房间中渲染一些立方体，它们散落在大立方体各处，光源在场景中央。</p>
<p>顶点着色器和像素着色器和原来的阴影映射着色器大部分都一样：不同之处是在光空间中像素着色器不再需要一个fragment位置，现在我们可以使用一个方向向量采样深度值。</p>
<p>因为这个顶点着色器不再需要将他的位置向量变换到光空间，所以我们可以去掉FragPosLightSpace变量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> normal;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec3</span> Normal;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(position, <span class="number">1.0</span>f);</span><br><span class="line">    vs_out.FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(position, <span class="number">1.0</span>));</span><br><span class="line">    vs_out.Normal = <span class="built_in">transpose</span>(<span class="built_in">inverse</span>(<span class="type">mat3</span>(model))) * normal;</span><br><span class="line">    vs_out.TexCoords = texCoords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段着色器的Blinn-Phong光照代码和我们之前阴影相乘的结尾部分一样：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec3</span> Normal;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> diffuseTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">samplerCube</span> depthMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> far_plane;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ShadowCalculation(<span class="type">vec3</span> fragPos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec3</span> fragToLight = fragPos - lightPos; <span class="comment">//得到片元和光源位置之间的方向向量</span></span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight).r;<span class="comment">//使用这个向量采样立方体贴图</span></span><br><span class="line">    closestDepth *= far_plane;<span class="comment">//closestDepth值现在在0到1的范围内了，所以我们先将其转换回0到far_plane的范围，这需要把他乘以far_plane：(因为我们在处理深度值时将它映射到了[0,1]的范围里)</span></span><br><span class="line">    <span class="type">float</span> currentDepth = <span class="built_in">length</span>(fragToLight);<span class="comment">//当前片元和光源之间的距离(深度)可以直接获取；</span></span><br><span class="line">    <span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line">	<span class="type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shadow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一些细微的不同：光照代码一样，但我们现在有了一个uniform变量samplerCube，shadowCalculation函数用fragment的位置作为它的参数，取代了光空间的fragment位置。我们现在还要引入光的视锥的远平面值，后面我们会需要它。像素着色器的最后，我们计算出阴影元素，当fragment在阴影中时它是1.0，不在阴影中时是0.0。我们使用计算出来的阴影元素去影响光照的diffuse和specular元素。</p>
<h4 id="显示立方体贴图深度缓冲"><a href="#显示立方体贴图深度缓冲" class="headerlink" title="显示立方体贴图深度缓冲"></a>显示立方体贴图深度缓冲</h4><p>如果你想我一样第一次并没有做对，那么就要进行调试排错，将深度贴图显示出来以检查其是否正确。因为我们不再用2D深度贴图纹理，深度贴图的显示不会那么显而易见。</p>
<p>一个简单的把深度缓冲显示出来的技巧是，在ShadowCalculation函数中计算标准化的closestDepth变量，把变量显示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FragColor = vec4(vec3(closestDepth / far_plane), 1.0);</span><br></pre></td></tr></table></figure>

<p>结果是一个灰度场景，每个颜色代表着场景的线性深度值：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/02/point_shadows_depth_cubemap.png" alt="img"></p>
<p>你可能也注意到了带阴影部分在墙外。如果看起来和这个差不多，你就知道深度立方体贴图生成的没错。否则你可能做错了什么，也许是closestDepth仍然还在0到far_plane的范围。</p>
<h4 id="PCF-1"><a href="#PCF-1" class="headerlink" title="PCF"></a>PCF</h4><p>由于万向阴影贴图基于传统阴影映射的原则，它便也继承了由解析度产生的非真实感。如果你放大就会看到锯齿边了。PCF或称Percentage-closer filtering允许我们通过对fragment位置周围过滤多个样本，并对结果平均化。</p>
<p>如果我们用和前面教程同样的那个简单的PCF过滤器，并加入第三个维度，就是这样的：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> bias = <span class="number">0.05</span>; </span><br><span class="line"><span class="type">float</span> samples = <span class="number">4.0</span>;</span><br><span class="line"><span class="type">float</span> <span class="keyword">offset</span> = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">float</span> x = -<span class="keyword">offset</span>; x &lt; <span class="keyword">offset</span>; x += <span class="keyword">offset</span> / (samples * <span class="number">0.5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">float</span> y = -<span class="keyword">offset</span>; y &lt; <span class="keyword">offset</span>; y += <span class="keyword">offset</span> / (samples * <span class="number">0.5</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">float</span> z = -<span class="keyword">offset</span>; z &lt; <span class="keyword">offset</span>; z += <span class="keyword">offset</span> / (samples * <span class="number">0.5</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + <span class="type">vec3</span>(x, y, z)).r; </span><br><span class="line">            closestDepth *= far_plane;   <span class="comment">// Undo mapping [0;1]</span></span><br><span class="line">            <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">                shadow += <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= (samples * samples * samples);</span><br></pre></td></tr></table></figure>

<p>这段代码和我们传统的阴影映射没有多少不同。这里我们根据样本的数量动态计算了纹理偏移量，我们在三个轴向采样三次，最后对子样本进行平均化。</p>
<p>现在阴影看起来更加柔和平滑了，由此得到更加真实的效果：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/02/point_shadows_soft.png" alt="img"></p>
<p>然而，samples设置为4.0，每个fragment我们会得到总共64个样本，这太多了！</p>
<p>大多数这些采样都是多余的，与其在原始方向向量附近处采样，不如在采样方向向量的垂直方向进行采样更有意义。可是，没有（简单的）方式能够指出哪一个子方向是多余的，这就难了。有个技巧可以使用，用一个偏移量方向数组，它们差不多都是分开的，每一个指向完全不同的方向，剔除彼此接近的那些子方向。下面就是一个有着20个偏移方向的数组：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> sampleOffsetDirections[<span class="number">20</span>] = <span class="type">vec3</span>[]</span><br><span class="line">(</span><br><span class="line">   <span class="type">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="type">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="type">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="type">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">1</span>), </span><br><span class="line">   <span class="type">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>, <span class="number">-1</span>), <span class="type">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="type">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="type">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="type">vec3</span>( <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>), <span class="type">vec3</span>( <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="type">vec3</span>(<span class="number">-1</span>, <span class="number">-1</span>,  <span class="number">0</span>), <span class="type">vec3</span>(<span class="number">-1</span>,  <span class="number">1</span>,  <span class="number">0</span>),</span><br><span class="line">   <span class="type">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="type">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">1</span>), <span class="type">vec3</span>( <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>), <span class="type">vec3</span>(<span class="number">-1</span>,  <span class="number">0</span>, <span class="number">-1</span>),</span><br><span class="line">   <span class="type">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">1</span>), <span class="type">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>,  <span class="number">1</span>), <span class="type">vec3</span>( <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>), <span class="type">vec3</span>( <span class="number">0</span>,  <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>然后我们把PCF算法与从sampleOffsetDirections得到的样本数量进行适配，使用它们从立方体贴图里采样。这么做的好处是与之前的PCF算法相比，我们需要的样本数量变少了。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> bias = <span class="number">0.15</span>;</span><br><span class="line"><span class="type">int</span> samples = <span class="number">20</span>;</span><br><span class="line"><span class="type">float</span> viewDistance = <span class="built_in">length</span>(viewPos - fragPos);</span><br><span class="line"><span class="type">float</span> diskRadius = <span class="number">0.05</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; samples; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> closestDepth = <span class="built_in">texture</span>(depthMap, fragToLight + sampleOffsetDirections[i] * diskRadius).r;</span><br><span class="line">    closestDepth *= far_plane;   <span class="comment">// Undo mapping [0;1]</span></span><br><span class="line">    <span class="keyword">if</span>(currentDepth - bias &gt; closestDepth)</span><br><span class="line">        shadow += <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">shadow /= <span class="type">float</span>(samples);</span><br></pre></td></tr></table></figure>

<p>这里我们把一个偏移量添加到指定的diskRadius中，它在fragToLight方向向量周围从立方体贴图里采样。</p>
<p>另一个在这里可以应用的有意思的技巧是，我们可以基于观察者里一个fragment的距离来改变diskRadius；这样我们就能根据观察者的距离来增加偏移半径了，当距离更远的时候阴影更柔和，更近了就更锐利。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> diskRadius = (<span class="number">1.0</span> + (viewDistance / far_plane)) / <span class="number">25.0</span>;</span><br></pre></td></tr></table></figure>

<p>PCF算法的结果如果没有变得更好，也是非常不错的，这是柔和的阴影效果：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/03/02/point_shadows_soft_better.png" alt="img"></p>
<p>当然了，我们添加到每个样本的bias（偏移）高度依赖于上下文，总是要根据场景进行微调的。试试这些值，看看怎样影响了场景。 这里是最终版本的顶点和像素着色器。</p>
<p>我还要提醒一下使用几何着色器来生成深度贴图不会一定比每个面渲染场景6次更快。使用几何着色器有它自己的性能局限，在第一个阶段使用它可能获得更好的性能表现。这取决于环境的类型，以及特定的显卡驱动等等，所以如果你很关心性能，就要确保对两种方法有大致了解，然后选择对你场景来说更高效的那个。我个人还是喜欢使用几何着色器来进行阴影映射，原因很简单，因为它们使用起来更简单。</p>
<h3 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h3><p>我们以向三角形上附加纹理的方式来增加额外细节，提升真实感，隐藏多边形几何体是由无数三角形组成的事实。纹理确有助益，然而当你近看它们时，这个事实便隐藏不住了。现实中的物体表面并非是平坦的，而是表现出无数（凹凸不平的）细节。</p>
<p>例如，砖块的表面。砖块的表面非常粗糙，显然不是完全平坦的：它包含着接缝处水泥凹痕，以及非常多的细小的空洞。如果我们在一个有光的场景中看这样一个砖块的表面，问题就出来了。下图中我们可以看到砖块纹理应用到了平坦的表面，并被一个点光源照亮。</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_flat.png" alt="img"></p>
<p>光照并没有呈现出任何裂痕和孔洞，完全忽略了砖块之间凹进去的线条；表面看起来完全就是平的。我们可以使用specular贴图根据深度或其他细节阻止部分表面被照的更亮，以此部分地解决问题，但这并不是一个好方案。我们需要的是某种可以告知光照系统给所有有关物体表面类似深度这样的细节的方式。</p>
<p>如果我们以光的视角来看这个问题：是什么使表面被视为完全平坦的表面来照亮？答案会是表面的法线向量。以光照算法的视角考虑的话，只有一件事决定物体的形状，这就是垂直于它的法线向量。砖块表面只有一个法线向量，表面完全根据这个法线向量被以一致的方式照亮。如果每个fragment都是用自己的不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_surfaces.png" alt="img"></p>
<p>每个fragment使用了自己的法线，我们就可以让光照相信一个表面由很多微小的（垂直于法线向量的）平面所组成，物体表面的细节将会得到极大提升。这种每个fragment使用各自的法线，替代一个面上所有fragment使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。应用到砖墙上，效果像这样：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_compare.png" alt="img"></p>
<p>你可以看到细节获得了极大提升，开销却不大。因为我们只需要改变每个fragment的法线向量，并不需要改变所有光照公式。现在我们是为每个fragment传递一个法线，不再使用插值表面法线。这样光照使表面拥有了自己的细节。</p>
<p>为使法线贴图工作，我们需要为每个fragment提供一个法线。像diffuse贴图和specular贴图一样，我们可以使用一个2D纹理来储存法线数据。2D纹理不仅可以储存颜色和光照数据，还可以储存法线向量。这样我们可以从2D纹理中采样得到特定纹理的法线向量。</p>
<p>由于法线向量是个几何工具，而纹理通常只用于储存颜色信息，用纹理储存法线向量不是非常直接。如果你想一想，就会知道纹理中的颜色向量用r、g、b元素代表一个3D向量。类似的我们也可以将法线向量的x、y、z元素储存到纹理中，代替颜色的r、g、b元素。法线向量的范围在-1到1之间，所以我们先要将其映射到0到1的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 rgb_normal = normal * 0.5 + 0.5; // 从 [-1,1] 转换至 [0,1]</span><br></pre></td></tr></table></figure>

<p>将法线向量变换为像这样的RGB颜色元素，我们就能把根据表面的形状的fragment的法线保存在2D纹理中。教程开头展示的那个砖块的例子的法线贴图如下所示：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_normal_map.png" alt="img"></p>
<p>这会是一种偏蓝色调的纹理（你在网上找到的几乎所有法线贴图都是这样的）。这是因为所有法线的指向都偏向z轴（0, 0, 1）这是一种偏蓝的颜色。法线向量从z轴方向也向其他方向轻微偏移，颜色也就发生了轻微变化，这样看起来便有了一种深度。例如，你可以看到在每个砖块的顶部，颜色倾向于偏绿，这是因为砖块的顶部的法线偏向于指向正y轴方向（0, 1, 0），这样它就是绿色的了。</p>
<p>使用下面的改变了的像素着色器来渲染一个平面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D normalMap;  </span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;           </span><br><span class="line">    // 从法线贴图范围[0,1]获取法线</span><br><span class="line">    normal = texture(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">    // 将法线向量转换为范围[-1,1]</span><br><span class="line">    normal = normalize(normal * 2.0 - 1.0);   </span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">    // 像往常那样处理光照</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将被采样的法线颜色从0到1重新映射回-1到1，便能将RGB颜色重新处理成法线，然后使用采样出的法线向量应用于光照的计算。在例子中我们使用的是Blinn-Phong着色器。</p>
<p>通过慢慢随着时间慢慢移动光源，你就能明白法线贴图是什么意思了。运行这个例子你就能得到本教程开始的那个效果：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_correct.png" alt="img"></p>
<p>然而有个问题限制了刚才讲的那种法线贴图的使用。<strong>我们使用的那个法线贴图里面的所有法线向量都是指向正z方向的。上面的例子能用，是因为那个平面的表面法线也是指向正z方向的</strong>。可是，如果我们在表面法线指向正y方向的平面上使用同一个法线贴图会发生什么？</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_ground.png" alt="img"></p>
<p>光照看起来完全不对！发生这种情况是平面的表面法线现在指向了y，而采样得到的法线仍然指向的是z。结果就是光照仍然认为表面法线和之前朝向正z方向时一样；这样光照就不对了。下面的图片展示了这个表面上采样的法线的近似情况：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_ground_normals.png" alt="img"></p>
<p>你可以看到所有法线都指向z方向，它们本该朝着表面法线指向y方向的。一个可行方案是为每个表面制作一个单独的法线贴图。如果是一个立方体的话我们就需要6个法线贴图，但是如果模型上有无数的朝向不同方向的表面，这就不可行了（译注：实际上对于复杂模型可以把朝向各个方向的法线储存在同一张贴图上，你可能看到过不只是蓝色的法线贴图，不过用那样的法线贴图有个问题是你必须记住模型的起始朝向，如果模型运动了还要记录模型的变换，这是非常不方便的；此外就像作者所说的，如果把一个diffuse纹理应用在同一个物体的不同表面上，就像立方体那样的，就需要做6个法线贴图，这也不可取）。</p>
<p>另一个稍微有点难的解决方案是，<strong>在一个不同的坐标空间中进行光照，这个坐标空间里，法线贴图向量总是指向这个坐标空间的正z方向；所有的光照向量都相对与这个正z方向进行变换。这样我们就能始终使用同样的法线贴图，不管朝向问题。这个坐标空间叫做切线空间（tangent space）。</strong></p>
<h4 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h4><p><strong>法线贴图中的法线向量定义在切线空间中，在切线空间中，法线永远指着正z方向。</strong>切线空间是位于三角形表面之上的空间：法线相对于单个三角形的本地参考框架。<strong>它就像法线贴图向量的本地空间；它们都被定义为指向正z方向，无论最终变换到什么方向。使用一个特定的矩阵我们就能将本地&#x2F;切线空间中的法线向量转成世界或视图空间下，使它们转向到最终的贴图表面的方向。</strong></p>
<p>我们可以说，上个部分那个朝向正y的法线贴图错误的贴到了表面上。法线贴图被定义在切线空间中，所以一种解决问题的方式是计算出一种矩阵，把法线从切线空间变换到一个不同的空间，这样它们就能和表面法线方向对齐了：法线向量都会指向正y方向。切线空间的一大好处是我们可以为任何类型的表面计算出一个这样的矩阵，由此我们可以把切线空间的z方向和表面的法线方向对齐。</p>
<p>这种矩阵叫做TBN矩阵，这三个字母分别代表tangent、bitangent和normal向量。这是建构这个矩阵所需的向量。要建构这样一个<strong>把切线空间转变为不同空间的变异矩阵，我们需要三个相互垂直的向量，它们沿一个表面的法线贴图对齐于：上、右、前；</strong></p>
<p>已知上向量是表面的法线向量。右和前向量是切线(Tagent)和副切线(Bitangent)向量。下面的图片展示了一个表面的三个向量：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_tbn_vectors.png" alt="img"></p>
<p>计算出切线和副切线并不像法线向量那么容易。从图中可以看到法线贴图的切线和副切线与纹理坐标的两个方向对齐。我们就是用到这个特性计算每个表面的切线和副切线的。需要用到一些数学才能得到它们；请看下图：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_surface_edges.png" alt="img"></p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230215154019862.png" alt="image-20230215154019862"></p>
<p>如果你对这些数学内容不理解也不用担心。当你知道我们<strong>可以用一个三角形的顶点和纹理坐标（因为纹理坐标和切线向量在同一空间中）计算出切线和副切线</strong>你就已经部分地达到目的了；</p>
<p>假设平面使用下面的向量建立起来（1、2、3和1、3、4，它们是两个三角形）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// positions</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos1</span><span class="params">(<span class="number">-1.0</span>,  <span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos2</span><span class="params">(<span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos3</span><span class="params">(<span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">pos4</span><span class="params">(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// texture coordinates</span></span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv1</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv2</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv3</span><span class="params">(<span class="number">1.0</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec2 <span class="title">uv4</span><span class="params">(<span class="number">1.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// normal vector</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">nm</span><span class="params">(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们先计算第一个三角形的边和deltaUV坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 edge1 = pos2 - pos1;</span><br><span class="line">glm::vec3 edge2 = pos3 - pos1;</span><br><span class="line">glm::vec2 deltaUV1 = uv2 - uv1;</span><br><span class="line">glm::vec2 deltaUV2 = uv3 - uv1;</span><br></pre></td></tr></table></figure>

<p>有了计算切线和副切线的必备数据，我们就可以开始写出来自于前面部分中的下列等式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GLfloat f = <span class="number">1.0f</span> / (deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y);</span><br><span class="line"></span><br><span class="line">tangent1.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);</span><br><span class="line">tangent1.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);</span><br><span class="line">tangent1.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);</span><br><span class="line">tangent1 = glm::<span class="built_in">normalize</span>(tangent1);</span><br><span class="line"></span><br><span class="line">bitangent1.x = f * (-deltaUV2.x * edge1.x + deltaUV1.x * edge2.x);</span><br><span class="line">bitangent1.y = f * (-deltaUV2.x * edge1.y + deltaUV1.x * edge2.y);</span><br><span class="line">bitangent1.z = f * (-deltaUV2.x * edge1.z + deltaUV1.x * edge2.z);</span><br><span class="line">bitangent1 = glm::<span class="built_in">normalize</span>(bitangent1);  </span><br><span class="line"></span><br><span class="line">[...] <span class="comment">// 对平面的第二个三角形采用类似步骤计算切线和副切线</span></span><br></pre></td></tr></table></figure>

<p>我们预先计算出等式的分数部分<code>f</code>，然后把它和每个向量的元素进行相应矩阵乘法。如果你把代码和最终的等式对比你会发现，这就是直接套用。最后我们还要进行标准化，来确保切线&#x2F;副切线向量最后是单位向量。</p>
<p>因为一个三角形永远是平坦的形状，我们只需为每个三角形计算一个切线&#x2F;副切线，它们对于每个三角形上的顶点都是一样的。要注意的是大多数实现通常三角形和三角形之间都会共享顶点。这种情况下开发者通常将每个顶点的法线和切线&#x2F;副切线等顶点属性平均化，以获得更加柔和的效果。我们的平面的三角形之间分享了一些顶点，但是因为两个三角形相互并行，因此并不需要将结果平均化，但无论何时只要你遇到这种情况记住它就是件好事。</p>
<p>最后的切线和副切线向量的值应该是(1, 0, 0)和(0, 1, 0)，它们和法线(0, 0, 1)组成相互垂直的TBN矩阵。在平面上显示出来TBN应该是这样的：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_tbn_shown.png" alt="img"></p>
<p>每个顶点定义了切线和副切线向量，我们就可以开始实现正确的法线贴图了。</p>
<h4 id="切线空间法线贴图"><a href="#切线空间法线贴图" class="headerlink" title="切线空间法线贴图"></a>切线空间法线贴图</h4><p>为让法线贴图工作，我们先得在着色器中创建一个TBN矩阵。我们先将前面计算出来的切线和副切线向量传给顶点着色器，作为它的属性：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> normal;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoords;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">3</span>) <span class="keyword">in</span> <span class="type">vec3</span> tangent;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">4</span>) <span class="keyword">in</span> <span class="type">vec3</span> bitangent;</span><br></pre></td></tr></table></figure>

<p>在顶点着色器的main函数中我们创建TBN矩阵：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">   [...]</span><br><span class="line">   <span class="type">vec3</span> T = <span class="built_in">normalize</span>(<span class="type">vec3</span>(model * <span class="type">vec4</span>(tangent,   <span class="number">0.0</span>)));</span><br><span class="line">   <span class="type">vec3</span> B = <span class="built_in">normalize</span>(<span class="type">vec3</span>(model * <span class="type">vec4</span>(bitangent, <span class="number">0.0</span>)));</span><br><span class="line">   <span class="type">vec3</span> N = <span class="built_in">normalize</span>(<span class="type">vec3</span>(model * <span class="type">vec4</span>(normal,    <span class="number">0.0</span>)));</span><br><span class="line">   <span class="type">mat3</span> TBN = <span class="type">mat3</span>(T, B, N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先将所有TBN向量变换到我们所操作的坐标系中，现在是世界空间，我们可以乘以model矩阵。然后我们创建实际的TBN矩阵，直接把相应的向量应用到mat3构造器就行。注意，<strong>如果我们希望更精确的话就不要将TBN向量乘以model矩阵，而是使用法线矩阵，因为我们只关心向量的方向，不关心平移和缩放。</strong></p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230215155648077.png" alt="image-20230215155648077"></p>
<p>现在我们有了TBN矩阵，如果来使用它呢？通常来说有两种方式使用它，我们会把这两种方式都说明一下：</p>
<ol>
<li>我们直接使用TBN矩阵，这个矩阵可以把切线坐标空间的向量转换到世界坐标空间。因此我们把它传给片段着色器中，把通过采样得到的法线坐标左乘上TBN矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。</li>
<li>我们也可以使用TBN矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照变量，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。</li>
</ol>
<p><strong>第一种情况：</strong>我们从法线贴图采样得来的法线向量，是在切线空间表示的，尽管其他光照向量都是在世界空间表示的。把TBN传给像素着色器，我们就能将采样得来的切线空间的法线乘以这个TBN矩阵，将法线向量变换到和其他光照向量一样的参考空间中。这种方式随后所有光照计算都可以简单的理解。</p>
<p>把TBN矩阵发给像素着色器很简单：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">    <span class="type">mat3</span> TBN;</span><br><span class="line">&#125; vs_out;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    vs_out.TBN = <span class="type">mat3</span>(T, B, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在像素着色器中我们用mat3作为输入变量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">    <span class="type">mat3</span> TBN;</span><br><span class="line">&#125; fs_in;</span><br></pre></td></tr></table></figure>

<p>有了TBN矩阵我们现在就可以更新法线贴图代码，引入切线到世界空间变换：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normal = <span class="built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line">normal = <span class="built_in">normalize</span>(fs_in.TBN * normal);</span><br></pre></td></tr></table></figure>

<p>因为最后的normal现在在世界空间中了，就不用改变其他像素着色器的代码了，因为光照代码就是假设法线向量在世界空间中。</p>
<p><strong>第二种情况：</strong>我们用TBN矩阵的逆矩阵将所有相关的世界空间向量转变到采样所得法线向量的空间：切线空间。TBN的建构还是一样，但我们在将其发送给像素着色器之前先要求逆矩阵：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs_out.TBN = <span class="built_in">transpose</span>(<span class="type">mat3</span>(T, B, N));</span><br></pre></td></tr></table></figure>

<p><strong>注意，这里我们使用transpose函数，而不是inverse函数。正交矩阵（每个轴既是单位向量同时相互垂直）的一大属性是一个正交矩阵的置换矩阵与它的逆矩阵相等。这个属性很重要因为逆矩阵的求得比求置换开销大；结果却是一样的。</strong></p>
<p>在像素着色器中我们不用对法线向量变换，但我们要把其他相关向量转换到切线空间，它们是lightDir和viewDir。这样每个向量还是在同一个空间（切线空间）中了。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;           </span><br><span class="line">    <span class="type">vec3</span> normal = <span class="built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;</span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> lightDir = fs_in.TBN * <span class="built_in">normalize</span>(lightPos - fs_in.FragPos);</span><br><span class="line">    <span class="type">vec3</span> viewDir  = fs_in.TBN * <span class="built_in">normalize</span>(viewPos - fs_in.FragPos);    </span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法看似要做的更多，它还需要在像素着色器中进行更多的乘法操作，所以为何还用第二种方法呢？</p>
<p>将向量从世界空间转换到切线空间有个额外好处，我们可以把所有相关向量在顶点着色器中转换到切线空间，不用在像素着色器中做这件事。这是可行的，因为lightPos和viewPos不是每个fragment运行都要改变，对于fs_in.FragPos，我们也可以在顶点着色器计算它的切线空间位置。基本上，不需要把任何向量在像素着色器中进行变换，而第一种方法中就是必须的，因为采样出来的法线向量对于每个像素着色器都不一样。</p>
<p>所以现在<strong>不是把TBN矩阵的逆矩阵发送给像素着色器，而是将切线空间的光源位置，观察位置以及顶点位置发送给像素着色器。这样我们就不用在像素着色器里进行矩阵乘法了。这是一个极佳的优化，因为顶点着色器通常比像素着色器运行的少。</strong>这也是为什么这种方法是一种更好的实现方式的原因。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">    <span class="type">vec3</span> TangentLightPos;</span><br><span class="line">    <span class="type">vec3</span> TangentViewPos;</span><br><span class="line">    <span class="type">vec3</span> TangentFragPos;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;    </span><br><span class="line">    [...]</span><br><span class="line">    <span class="type">mat3</span> TBN = <span class="built_in">transpose</span>(<span class="type">mat3</span>(T, B, N));</span><br><span class="line">    vs_out.TangentLightPos = TBN * lightPos;</span><br><span class="line">    vs_out.TangentViewPos  = TBN * viewPos;</span><br><span class="line">    vs_out.TangentFragPos  = TBN * <span class="type">vec3</span>(model * <span class="type">vec4</span>(position, <span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在像素着色器中我们使用这些新的输入变量来计算切线空间的光照。因为法线向量已经在切线空间中了，光照就有意义了。</p>
<p>将法线贴图应用到切线空间上，我们会得到混合教程一开始那个例子相似的结果，但这次我们可以将平面朝向各个方向，光照一直都会是正确的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model;</span><br><span class="line">model = glm::<span class="built_in">rotate</span>(model, (GLfloat)<span class="built_in">glfwGetTime</span>() * <span class="number">-1</span>, glm::<span class="built_in">normalize</span>(glm::<span class="built_in">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)));</span><br><span class="line"><span class="built_in">glUniformMatrix4fv</span>(modelLoc <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(model));</span><br><span class="line"><span class="built_in">RenderQuad</span>();</span><br></pre></td></tr></table></figure>

<p>看起来是正确的法线贴图：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_correct_tangent.png" alt="img"></p>
<h4 id="复杂物体"><a href="#复杂物体" class="headerlink" title="复杂物体"></a>复杂物体</h4><p>我们已经说明了如何通过手工计算切线和副切线向量，来使用切线空间和法线贴图。幸运的是，计算这些切线和副切线向量对于你来说不是经常能遇到的事；大多数时候，在模型加载器中实现了一次就行了，我们是在使用了Assimp的那个加载器中实现的。</p>
<p>Assimp有个很有用的配置，在我们加载模型的时候调用aiProcess_CalcTangentSpace。当aiProcess_CalcTangentSpace应用到Assimp的ReadFile函数时，Assimp会为每个加载的顶点计算出柔和的切线和副切线向量，它所使用的方法和我们本教程使用的类似。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aiScene* scene = importer.ReadFile(</span><br><span class="line">    path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的代码用Assimp获取计算出来的切线空间：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector.x = mesh-&gt;mTangents[i].x;</span><br><span class="line">vector.y = mesh-&gt;mTangents[i].y;</span><br><span class="line">vector.z = mesh-&gt;mTangents[i].z;</span><br><span class="line">vertex.Tangent = vector;</span><br></pre></td></tr></table></figure>

<p>然后，你还必须更新模型加载器，用以从带纹理模型中加载法线贴图。wavefront的模型格式（.obj）导出的法线贴图有点不一样，Assimp的aiTextureType_NORMAL并不会加载它的法线贴图，而aiTextureType_HEIGHT却能，所以我们经常这样加载它们：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Texture&gt; specularMaps = this-&gt;loadMaterialTextures(</span><br><span class="line">    material, aiTextureType_HEIGHT, &quot;texture_normal&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>当然，对于每个模型的类型和文件格式来说都是不同的。同样了解aiProcess_CalcTangentSpace并不能总是很好的工作也很重要。计算切线是需要根据纹理坐标的，有些模型制作者使用一些纹理小技巧比如镜像一个模型上的纹理表面时也镜像了另一半的纹理坐标；这样当不考虑这个镜像的特别操作的时候（Assimp就不考虑）结果就不对了。</strong></p>
<p>使用法线贴图也是一种提升你的场景的表现的重要方式。在使用法线贴图之前你不得不使用相当多的顶点才能表现出一个更精细的网格，但使用了法线贴图我们可以使用更少的顶点表现出同样丰富的细节。下图来自Paolo Cignoni，图中对比了两种方式：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/04/normal_mapping_comparison.png" alt="img"></p>
<p>高精度网格和使用法线贴图的低精度网格几乎区分不出来。所以法线贴图不仅看起来漂亮，它也是一个将高精度多边形转换为低精度多边形而不失细节的重要工具。</p>
<h4 id="最后一件事"><a href="#最后一件事" class="headerlink" title="最后一件事"></a>最后一件事</h4><p>关于法线贴图还有最后一个技巧要讨论，它可以在不必花费太多性能开销的情况下稍稍提升画质表现。</p>
<p>当在更大的网格上计算切线向量的时候，<strong>它们往往有很大数量的共享顶点，当法向贴图应用到这些表面时将切线向量平均化通常能获得更好更平滑的结果。这样做有个问题，就是TBN向量可能会不能互相垂直，这意味着TBN矩阵不再是正交矩阵了。法线贴图可能会稍稍偏移</strong>，但这仍然可以改进。</p>
<p><strong>使用叫做<em>格拉姆-施密特</em>正交化过程（Gram-Schmidt process）的数学技巧，我们可以对TBN向量进行重正交化，这样每个向量就又会重新垂直了。</strong>在顶点着色器中我们这样做：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> T = <span class="built_in">normalize</span>(<span class="type">vec3</span>(model * <span class="type">vec4</span>(tangent, <span class="number">0.0</span>)));</span><br><span class="line"><span class="type">vec3</span> N = <span class="built_in">normalize</span>(<span class="type">vec3</span>(model * <span class="type">vec4</span>(normal, <span class="number">0.0</span>)));</span><br><span class="line"><span class="comment">// re-orthogonalize T with respect to N</span></span><br><span class="line">T = <span class="built_in">normalize</span>(T - <span class="built_in">dot</span>(T, N) * N);</span><br><span class="line"><span class="comment">// then retrieve perpendicular vector B with the cross product of T and N</span></span><br><span class="line"><span class="type">vec3</span> B = <span class="built_in">cross</span>(T, N);</span><br><span class="line"></span><br><span class="line"><span class="type">mat3</span> TBN = <span class="type">mat3</span>(T, B, N)</span><br></pre></td></tr></table></figure>

<p>这样稍微花费一些性能开销就能对法线贴图进行一点提升。看看最后的那个附加资源： <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=4FaWLgsctqY">Normal Mapping Mathematics</a>视频，里面有对这个过程的解释。</p>
<h3 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h3><p>视差贴图(Parallax Mapping)技术和法线贴图差不多，但它有着不同的原则。和法线贴图一样视差贴图能够极大提升表面细节，使之具有深度感。它也是利用了视错觉，然而对深度有着更好的表达，与法线贴图一起用能够产生难以置信的效果。视差贴图和光照无关，在这里是作为法线贴图的技术延续来讨论它的。</p>
<p>视差贴图属于位移贴图(Displacement Mapping)技术的一种，它对根据储存在纹理中的几何信息对顶点进行位移或偏移。一种实现的方式是比如有1000个顶点，根据纹理中的数据对平面特定区域的顶点的高度进行位移。这样的每个纹理像素包含了高度值纹理叫做高度贴图。一张简单的砖块表面的高度贴图如下所示：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_height_map.png" alt="img"></p>
<p>整个平面上的每个顶点都根据从高度贴图采样出来的高度值进行位移，根据材质的几何属性平坦的平面变换成凹凸不平的表面。例如一个平坦的平面利用上面的高度贴图进行置换能得到以下结果：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_plane_heightmap.png" alt="img"></p>
<p>置换顶点有一个问题就是平面必须由很多顶点组成才能获得具有真实感的效果，否则看起来效果并不会很好。一个平坦的表面上有1000个顶点计算量太大了。我们能否不用这么多的顶点就能取得相似的效果呢？事实上，上面的表面就是用6个顶点渲染出来的（两个三角形）。上面的那个表面使用视差贴图技术渲染，位移贴图技术不需要额外的顶点数据来表达深度，它像法线贴图一样采用一种聪明的手段欺骗用户的眼睛。</p>
<p>视差贴图背后的思想是修改纹理坐标使一个fragment的表面看起来比实际的更高或者更低，所有这些都根据观察方向和高度贴图。为了理解它如何工作，看看下面砖块表面的图片：</p>
<p><img src="https://img-blog.csdnimg.cn/9d53304e19f94e29a53471c0c0becb05.png" alt="在这里插入图片描述"></p>
<p>这里粗糙的红线代表高度贴图中的数值的立体表达，向量<em>V</em>代表观察方向。如果平面进行实际位移，观察者会在点<em>B</em>看到表面。然而我们的平面没有实际上进行位移，观察方向将在点<em>A</em>与平面接触。视差贴图的目的是，在<em>A</em>位置上的fragment不再使用点<em>A</em>的纹理坐标而是使用点<em>B</em>的。随后我们用点<em>B</em>的纹理坐标采样，观察者就像看到了点<em>B</em>一样。</p>
<p>这个技巧就是描述如何从点<em>A</em>得到点<em>B</em>的纹理坐标。视差贴图尝试通过对从fragment到观察者的方向向量<em>V</em>进行缩放的方式解决这个问题，缩放的大小是<em>A</em>处fragment的高度。所以我们将<em>V</em>的长度缩放为高度贴图在点<em>A</em>处<em>H(A)<em>采样得来的值。下图展示了经缩放得到的向量</em>P</em>：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_scaled_height.png" alt="img"></p>
<p>我们随后选出P以及这个向量与平面对齐的坐标作为纹理坐标的偏移量。这能工作是因为向量P是使用从高度贴图得到的高度值计算出来的，所以一个fragment的高度越高位移的量越大。</p>
<p>这个技巧在大多数时候都没问题，但点B是粗略估算得到的。当表面的高度变化很快的时候，看起来就不会真实，因为向量P最终不会和B接近，就像下图这样：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_incorrect_p.png" alt="img"></p>
<p>视差贴图的另一个问题是，当表面被任意旋转以后很难指出从P获取哪一个坐标。我们在视差贴图中使用了另一个坐标空间，这个空间P向量的x和y元素总是与纹理表面对齐。如果你看了法线贴图教程，你也许猜到了，我们实现它的方法，是的，我们还是<strong>在切线空间中实现视差贴图</strong>。</p>
<p>将fragment到观察者的向量V转换到切线空间中，经变换的P向量的x和y元素将于表面的切线和副切线向量对齐。由于切线和副切线向量与表面纹理坐标的方向相同，我们可以用P的x和y元素作为纹理坐标的偏移量，这样就不用考虑表面的方向了。</p>
<p>我们将使用一个简单的2D平面，在把它发送给GPU之前我们先计算它的切线和副切线向量；和法线贴图教程做的差不多。这个例子中我们将视差贴图和法线贴图连用。因为视差贴图生成表面位移了的幻觉，当光照不匹配时这种幻觉就被破坏了。法线贴图通常根据高度贴图生成，法线贴图和高度贴图一起用能保证光照能和位移想匹配。</p>
<p>你可能已经注意到，上面链接上的那个位移贴图和教程一开始的那个高度贴图相比是颜色是相反的。这是因为使用反色高度贴图（也叫深度贴图）去模拟深度比模拟高度更容易。下图反映了这个轻微的改变：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_depth.png" alt="img"></p>
<p>我们再次获得A和B，但是这次我们用向量V减去点A的纹理坐标得到P。我们<strong>通过在着色器中用1.0减去采样得到的高度贴图中的值来取得深度值，而不再是高度值，或者简单地在图片编辑软件中把这个纹理进行反色操作</strong>，就像我们对连接中的那个深度贴图所做的一样。<br>位移贴图是在像素着色器中实现的，因为三角形表面的所有位移效果都不同。在像素着色器中我们将需要计算fragment到观察者到方向向量V所以我们需要观察者位置和在切线空间中的fragment位置。法线贴图教程中我们已经有了一个顶点着色器，它把这些向量发送到切线空间，所以我们可以复制那个顶点着色器：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> position;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> normal;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> texCoords;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">3</span>) <span class="keyword">in</span> <span class="type">vec3</span> tangent;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">4</span>) <span class="keyword">in</span> <span class="type">vec3</span> bitangent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">    <span class="type">vec3</span> TangentLightPos;</span><br><span class="line">    <span class="type">vec3</span> TangentViewPos;</span><br><span class="line">    <span class="type">vec3</span> TangentFragPos;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightPos;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span>      = projection * view * model * <span class="type">vec4</span>(position, <span class="number">1.0</span>f);</span><br><span class="line">    vs_out.FragPos   = <span class="type">vec3</span>(model * <span class="type">vec4</span>(position, <span class="number">1.0</span>));   </span><br><span class="line">    vs_out.TexCoords = texCoords;    </span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> T   = <span class="built_in">normalize</span>(<span class="type">mat3</span>(model) * tangent);</span><br><span class="line">    <span class="type">vec3</span> B   = <span class="built_in">normalize</span>(<span class="type">mat3</span>(model) * bitangent);</span><br><span class="line">    <span class="type">vec3</span> N   = <span class="built_in">normalize</span>(<span class="type">mat3</span>(model) * normal);</span><br><span class="line">    <span class="type">mat3</span> TBN = <span class="built_in">transpose</span>(<span class="type">mat3</span>(T, B, N));</span><br><span class="line"></span><br><span class="line">    vs_out.TangentLightPos = TBN * lightPos;</span><br><span class="line">    vs_out.TangentViewPos  = TBN * viewPos;</span><br><span class="line">    vs_out.TangentFragPos  = TBN * vs_out.FragPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里有件事很重要，我们需要把position和在切线空间中的观察者的位置viewPos发送给像素着色器。</p>
<p>在像素着色器中，我们实现视差贴图的逻辑。像素着色器看起来会是这样的：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT &#123;</span><br><span class="line">    <span class="type">vec3</span> FragPos;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">    <span class="type">vec3</span> TangentLightPos;</span><br><span class="line">    <span class="type">vec3</span> TangentViewPos;</span><br><span class="line">    <span class="type">vec3</span> TangentFragPos;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> diffuseMap;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> normalMap;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> depthMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> height_scale;</span><br><span class="line"></span><br><span class="line"><span class="type">vec2</span> ParallaxMapping(<span class="type">vec2</span> texCoords, <span class="type">vec3</span> viewDir);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;           </span><br><span class="line">    <span class="comment">// Offset texture coordinates with Parallax Mapping</span></span><br><span class="line">    <span class="type">vec3</span> viewDir   = <span class="built_in">normalize</span>(fs_in.TangentViewPos - fs_in.TangentFragPos);</span><br><span class="line">    <span class="type">vec2</span> texCoords = ParallaxMapping(fs_in.TexCoords,  viewDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// then sample textures with new texture coords</span></span><br><span class="line">    <span class="type">vec3</span> diffuse = <span class="built_in">texture</span>(diffuseMap, texCoords);</span><br><span class="line">    <span class="type">vec3</span> normal  = <span class="built_in">texture</span>(normalMap, texCoords);</span><br><span class="line">    normal = <span class="built_in">normalize</span>(normal * <span class="number">2.0</span> - <span class="number">1.0</span>);</span><br><span class="line">    <span class="comment">// proceed with lighting code</span></span><br><span class="line">    [...]    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了一个叫做ParallaxMapping的函数，它把fragment的纹理坐标和切线空间中的fragment到观察者的方向向量为输入。这个函数返回经位移的纹理坐标。然后我们使用这些经位移的纹理坐标进行diffuse和法线贴图的采样。最后fragment的diffuse颜色和法线向量就正确的对应于表面的经位移的位置上了。</p>
<p>我们来看看ParallaxMapping函数的内部：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> ParallaxMapping(<span class="type">vec2</span> texCoords, <span class="type">vec3</span> viewDir)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">float</span> height =  <span class="built_in">texture</span>(depthMap, texCoords).r;<span class="comment">//用本来的纹理坐标texCoords从高度贴图中来采样得到H(A)</span></span><br><span class="line">    <span class="type">vec2</span> p = viewDir.xy / viewDir.z * (height * height_scale);<span class="comment">//除以z轴得到uv平面上的向量</span></span><br><span class="line">    <span class="keyword">return</span> texCoords - p;<span class="comment">//对采样坐标沿着视野方向进行近似控制量(p)的偏移  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个相对简单的函数是我们所讨论过的内容的直接表述。我们用本来的纹理坐标texCoords从高度贴图中来采样，得到当前fragment的高度H(A)。然后计算出P，x和y元素在切线空间中，viewDir向量除以它的z元素，用fragment的高度对它进行缩放。我们同时引入额一个height_scale的uniform，来进行一些额外的控制，因为视差效果如果没有一个缩放参数通常会过于强烈。然后我们用P减去纹理坐标来获得最终的经过位移纹理坐标。<br>有一个地方需要注意，就是viewDir.xy除以viewDir.z那里。因为viewDir向量是经过了标准化的，viewDir.z会在0.0到1.0之间的某处。当viewDir大致平行于表面时，它的z元素接近于0.0，除法会返回比viewDir垂直于表面的时候更大的P向量。所以，从本质上，相比正朝向表面，当带有角度地看向平面时，我们会更大程度地缩放P的大小，从而增加纹理坐标的偏移；这样做在视角上会获得更大的真实度。<br>有些人更喜欢不在等式中使用viewDir.z，因为普通的视差贴图会在角度上产生不尽如人意的结果；这个技术叫做有偏移量限制的视差贴图（Parallax Mapping with Offset Limiting）。</p>
<p>最后的纹理坐标随后被用来进行采样（diffuse和法线）贴图，下图所展示的位移效果中height_scale等于1：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping.png" alt="img"></p>
<p>这里你会看到只用法线贴图和与视差贴图相结合的法线贴图的不同之处。因为视差贴图尝试模拟深度，它实际上能够根据你观察它们的方向使砖块叠加到其他砖块上。</p>
<p>在视差贴图的那个平面里你仍然能看到在边上有古怪的失真。原因是在平面的边缘上，纹理坐标超出了0到1的范围进行采样，根据纹理的环绕方式导致了不真实的结果。解决的方法是当它超出默认纹理坐标范围进行采样的时候就丢弃这个fragment：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">texCoords = ParallaxMapping(fs_in.TexCoords,  viewDir);</span><br><span class="line"><span class="keyword">if</span>(texCoords.x &gt; <span class="number">1.0</span> || texCoords.y &gt; <span class="number">1.0</span> || texCoords.x &lt; <span class="number">0.0</span> || texCoords.y &lt; <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">discard</span>;</span><br></pre></td></tr></table></figure>

<p>丢弃了超出默认范围的纹理坐标的所有fragment，视差贴图的表面边缘给出了正确的结果。注意，这个技巧不能在所有类型的表面上都能工作，但是应用于平面上它还是能够是平面看起来真的进行位移了：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_edge_fix.png" alt="img"></p>
<p>但是从某些角度观察会出现问题，陡峭的地方会产生不正确的结果：</p>
<p><img src="C:\Users\HeptagramV\AppData\Roaming\Typora\typora-user-images\image-20230216152401158.png" alt="image-20230216152401158"></p>
<h4 id="陡峭视差映射"><a href="#陡峭视差映射" class="headerlink" title="陡峭视差映射"></a>陡峭视差映射</h4><p>陡峭视差映射(Steep Parallax Mapping)是视差映射的扩展，原则是一样的，但不是使用一个样本而是多个样本来确定向量P到B。即使在陡峭的高度变化的情况下，它也能得到更好的结果，原因在于该技术通过增加采样的数量提高了精确性。</p>
<p>陡峭视差映射的基本思想是将总深度范围划分为同一个深度&#x2F;高度的多个层。从每个层中我们沿着P方向移动采样纹理坐标，直到我们找到一个采样低于当前层的深度值。看看下面的图片：</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_steep_parallax_mapping_diagram.png" alt="img"></p>
<p>我们从上到下遍历深度层，我们把每个深度层和储存在深度贴图中的它的深度值进行对比。如果这个层的深度值小于深度贴图的值，就意味着这一层的P向量部分在表面之下。我们继续这个处理过程直到有一层的深度高于储存在深度贴图中的值：这个点就在（经过位移的）表面下方。</p>
<p>这个例子中我们可以看到第二层(D(2) &#x3D; 0.73)的深度贴图的值仍低于第二层的深度值0.4，所以我们继续。下一次迭代，这一层的深度值0.6大于深度贴图中采样的深度值(D(3) &#x3D; 0.37)。我们便可以假设第三层向量P¯是可用的位移几何位置。我们可以用从向量P3¯的纹理坐标偏移T3来对fragment的纹理坐标进行位移。你可以看到随着深度的增加精确度也在提高。</p>
<p>为实现这个技术，我们只需要改变ParallaxMapping函数，因为所有需要的变量都有了：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> ParallaxMapping(<span class="type">vec2</span> texCoords, <span class="type">vec3</span> viewDir)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// number of depth layers</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">float</span> numLayers = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// calculate the size of each layer</span></span><br><span class="line">    <span class="type">float</span> layerDepth = <span class="number">1.0</span> / numLayers;</span><br><span class="line">    <span class="comment">// depth of current layer</span></span><br><span class="line">    <span class="type">float</span> currentLayerDepth = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// the amount to shift the texture coordinates per layer (from vector P)</span></span><br><span class="line">    <span class="type">vec2</span> P = viewDir.xy * height_scale; </span><br><span class="line">    <span class="type">float</span> deltaTexCoords = P / numLayers;</span><br><span class="line"></span><br><span class="line">    [...]     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先定义层的数量，计算每一层的深度，最后计算纹理坐标偏移，每一层我们必须沿着<em>P</em>的方向进行移动。</p>
<p>然后我们遍历所有层，从上开始，知道找到小于这一层的深度值的深度贴图值：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get initial values</span></span><br><span class="line"><span class="type">vec2</span>  currentTexCoords     = texCoords;</span><br><span class="line"><span class="type">float</span> currentDepthMapValue = <span class="built_in">texture</span>(depthMap, currentTexCoords).r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(currentLayerDepth &lt; currentDepthMapValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// shift texture coordinates along direction of P</span></span><br><span class="line">    currentTexCoords -= deltaTexCoords;</span><br><span class="line">    <span class="comment">// get depthmap value at current texture coordinates</span></span><br><span class="line">    currentDepthMapValue = <span class="built_in">texture</span>(depthMap, currentTexCoords).r;  </span><br><span class="line">    <span class="comment">// get depth of next layer</span></span><br><span class="line">    currentLayerDepth += layerDepth;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> texCoords - currentTexCoords;</span><br></pre></td></tr></table></figure>

<p>这里我们循环每一层深度，直到沿着<em>P</em>向量找到第一个返回低于（位移）表面的深度的纹理坐标偏移量。从fragment的纹理坐标减去最后的偏移量，来得到最终的经过位移的纹理坐标向量，这次就比传统的视差映射更精确了。</p>
<p>我们可以通过对视差贴图的一个属性的利用，对算法进行一点提升。当垂直看一个表面的时候纹理时位移比以一定角度看时的小。我们可以在垂直看时使用更少的样本，以一定角度看时增加样本数量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="type">float</span> minLayers = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> maxLayers = <span class="number">32</span>;</span><br><span class="line"><span class="type">float</span> numLayers = <span class="built_in">mix</span>(maxLayers, minLayers, <span class="built_in">abs</span>(<span class="built_in">dot</span>(<span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>), viewDir)));</span><br></pre></td></tr></table></figure>

<p>这里我们得到viewDir和正z方向的点乘，使用它的结果根据我们看向表面的角度调整样本数量（注意正z方向等于切线空间中的表面的法线）。如果我们所看的方向平行于表面，我们就是用32层。</p>
<p><strong>陡峭视差贴图同样有自己的问题。因为这个技术是基于有限的样本数量的，我们会遇到锯齿效果以及图层之间有明显的断层;</strong></p>
<p>我们可以通过增加样本的方式减少这个问题，但是很快就会花费很多性能。有些旨在修复这个问题的方法：不适用低于表面的第一个位置，而是在两个接近的深度层进行插值找出更匹配的。</p>
<p>两种最流行的解决方法叫做<strong>Relief Parallax Mapping和Parallax Occlusion Mapping</strong>，Relief Parallax Mapping更精确一些，但是比Parallax Occlusion Mapping性能开销更多。因为Parallax Occlusion Mapping的效果和前者差不多但是效率更高，因此这种方式更经常使用；</p>
<h4 id="视差遮蔽映射"><a href="#视差遮蔽映射" class="headerlink" title="视差遮蔽映射"></a>视差遮蔽映射</h4><p>视差遮蔽映射(Parallax Occlusion Mapping)和陡峭视差映射的原则相同，但不是用触碰的第一个深度层的纹理坐标，而是在触碰之前和之后，在深度层之间进行线性插值。我们根据表面的高度距离啷个深度层的深度层值的距离来确定线性插值的大小。看看下面的图片就能了解它是如何工作的：</p>
<p><img src="https://i0.hdslb.com/bfs/article/40bd1aeaf9c6a3b6fca322a38339d4ff0ae0dad0.png@863w_476h_progressive.webp" alt="img"></p>
<p> 总而言之，原理就是利用了相似三角形。 </p>
<p>你可以看到大部分和陡峭视差映射一样，不一样的地方是有个额外的步骤，两个深度层的纹理坐标围绕着交叉点的线性插值。这也是近似的，但是比陡峭视差映射更精确。</p>
<p>视差遮蔽映射的代码基于陡峭视差映射，所以并不难：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[...] <span class="comment">// steep parallax mapping code here</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get texture coordinates before collision (reverse operations)</span></span><br><span class="line"><span class="type">vec2</span> prevTexCoords = currentTexCoords + deltaTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get depth after and before collision for linear interpolation</span></span><br><span class="line"><span class="type">float</span> afterDepth  = currentDepthMapValue - currentLayerDepth;</span><br><span class="line"><span class="type">float</span> beforeDepth = <span class="built_in">texture</span>(depthMap, prevTexCoords).r - currentLayerDepth + layerDepth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interpolation of texture coordinates</span></span><br><span class="line"><span class="type">float</span> weight = afterDepth / (afterDepth - beforeDepth);</span><br><span class="line"><span class="type">vec2</span> finalTexCoords = prevTexCoords * weight + currentTexCoords * (<span class="number">1.0</span> - weight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> finalTexCoords;</span><br></pre></td></tr></table></figure>

<p>在对（位移的）表面几何进行交叉，找到深度层之后，我们获取交叉前的纹理坐标。然后我们计算来自相应深度层的几何之间的深度之间的距离，并在两个值之间进行插值。线性插值的方式是在两个层的纹理坐标之间进行的基础插值。函数最后返回最终的经过插值的纹理坐标。</p>
<p>视差遮蔽映射的效果非常好，尽管有一些可以看到的轻微的不真实和锯齿的问题，这仍是一个好交易，因为除非是放得非常大或者观察角度特别陡，否则也看不到。</p>
<p><img src="https://learnopengl-cn.github.io/img/05/05/parallax_mapping_parallax_occlusion_mapping.png" alt="img"></p>
<p>视差贴图是提升场景细节非常好的技术，但是使用的时候还是要考虑到它会带来一点不自然。大多数时候视差贴图用在地面和墙壁表面，这种情况下查明表面的轮廓并不容易，同时观察角度往往趋向于垂直于表面。这样视差贴图的不自然也就很难能被注意到了，对于提升物体的细节可以起到难以置信的效果。</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://example.com">HeptagramV</a></p><p> <span>Link:  </span><a href="http://example.com/2022/10/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6-OpenGL%E5%AD%A6%E4%B9%A0/">http://example.com/2022/10/07/%E5%9B%BE%E5%BD%A2%E5%AD%A6-OpenGL%E5%AD%A6%E4%B9%A0/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2022/11/18/%E5%9F%BA%E4%BA%8EVR%E7%9A%84%E8%BD%A6%E5%BA%8A%E5%8A%A0%E5%B7%A5%E8%99%9A%E6%8B%9F%E4%BB%BF%E7%9C%9F%E6%95%99%E5%AD%A6%E7%B3%BB%E7%BB%9F/" title="基于VR的车床加工虚拟仿真教学系统"><span>< PreviousPost</span><br><span class="prevTitle">基于VR的车床加工虚拟仿真教学系统</span></a><a class="nextSlogan" href="/2022/08/30/%E8%99%9A%E6%8B%9F%E7%BA%BF%E4%B8%8A%E4%BC%9A%E8%AE%AE%E5%AE%A4/" title="虚拟线上会议室"><span>NextPost ></span><br><span class="nextTitle">虚拟线上会议室</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LearnOpenGL-CN"><span class="toc-number">1.</span> <span class="toc-text">LearnOpenGL CN</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL"><span class="toc-number">1.1.1.</span> <span class="toc-text">OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GLAD"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">GLAD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">视口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BC%93%E5%86%B2"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">双缓冲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="toc-number">1.1.2.</span> <span class="toc-text">渲染管线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">片元着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">着色器程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">链接顶点属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">顶点数组对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">绘制三角形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">元素缓冲对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">输入与输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Uniform"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">Uniform</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">更多属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86"><span class="toc-number">1.1.4.</span> <span class="toc-text">纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">纹理环绕方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E8%BF%87%E6%BB%A4"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">纹理过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E6%B8%90%E8%BF%9C%E7%BA%B9%E7%90%86"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">多级渐远纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%BA%B9%E7%90%86"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">加载与创建纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E5%8D%95%E5%85%83"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">纹理单元</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2"><span class="toc-number">1.1.5.</span> <span class="toc-text">变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GLM"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">GLM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A5%E5%BA%93%E4%B8%AD%E7%9F%A9%E9%98%B5%E6%8C%89%E5%88%97%E5%AD%98%E5%82%A8%EF%BC%81"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">该库中矩阵按列存储！</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">坐标系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA"><span class="toc-number">1.1.7.</span> <span class="toc-text">摄像机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%80%9F%E5%BA%A6"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">移动速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E8%BE%93%E5%85%A5"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">鼠标输入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%85%A7"><span class="toc-number">1.2.</span> <span class="toc-text">光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">颜色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">基础光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.2.4.</span> <span class="toc-text">光照贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">漫反射贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E9%9D%A2%E5%85%89%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">镜面光贴图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%95%E5%85%89%E7%89%A9"><span class="toc-number">1.2.5.</span> <span class="toc-text">投光物</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%8C%E5%85%89"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">平行光</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E5%85%89%E6%BA%90"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">点光源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%85%89%E7%81%AF"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">聚光灯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%85%89%E6%BA%90"><span class="toc-number">1.2.6.</span> <span class="toc-text">多光源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.3.</span> <span class="toc-text">模型加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Assimp"><span class="toc-number">1.3.1.</span> <span class="toc-text">Assimp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC"><span class="toc-number">1.3.2.</span> <span class="toc-text">网格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93"><span class="toc-number">1.3.3.</span> <span class="toc-text">渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.5.</span> <span class="toc-text">编译上的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7OpenGL"><span class="toc-number">1.4.</span> <span class="toc-text">高级OpenGL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">深度测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">深度测试函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%80%BC%E7%B2%BE%E5%BA%A6"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">深度值精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">深度缓冲的可视化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%86%B2%E7%AA%81"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">深度冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">模板测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">模板函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E4%BD%93%E8%BD%AE%E5%BB%93"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">物体轮廓</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88"><span class="toc-number">1.4.3.</span> <span class="toc-text">混合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A2%E5%BC%83%E7%89%87%E6%AE%B5"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">丢弃片段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88-1"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">混合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%8D%8A%E9%80%8F%E6%98%8E%E7%BA%B9%E7%90%86"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">渲染半透明纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">渲染顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%89%94%E9%99%A4"><span class="toc-number">1.4.4.</span> <span class="toc-text">面剔除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E7%BB%95%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">环绕顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%89%94%E9%99%A4-1"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">面剔除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E7%BC%93%E5%86%B2"><span class="toc-number">1.4.5.</span> <span class="toc-text">帧缓冲</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E9%99%84%E4%BB%B6"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">纹理附件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1%E9%99%84%E4%BB%B6"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">渲染缓冲对象附件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%88%B0%E7%BA%B9%E7%90%86"><span class="toc-number">1.4.5.4.</span> <span class="toc-text">渲染到纹理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">1.4.6.</span> <span class="toc-text">后期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%9B%B8"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">反相</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">灰度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E6%95%88%E6%9E%9C"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">核效果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.7.</span> <span class="toc-text">立方体贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">创建立方体贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A9%E7%A9%BA%E7%9B%92"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">天空盒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84"><span class="toc-number">1.4.7.4.</span> <span class="toc-text">环境映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.4.7.4.1.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%98%E5%B0%84"><span class="toc-number">1.4.7.4.2.</span> <span class="toc-text">折射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%8E%AF%E5%A2%83%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.4.7.4.3.</span> <span class="toc-text">动态环境贴图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.8.</span> <span class="toc-text">高级数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%89%B9%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">分批顶点属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%BC%93%E5%86%B2"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">复制缓冲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7GLSL"><span class="toc-number">1.4.9.</span> <span class="toc-text">高级GLSL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#glsl%E7%9A%84%E5%86%85%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">glsl的内建变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.9.1.1.</span> <span class="toc-text">顶点着色器变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.9.1.2.</span> <span class="toc-text">片元着色器变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%9D%97"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">接口块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Uniform%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.9.3.</span> <span class="toc-text">Uniform缓冲对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Uniform%E5%9D%97%E5%B8%83%E5%B1%80"><span class="toc-number">1.4.9.4.</span> <span class="toc-text">Uniform块布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Uniform%E7%BC%93%E5%86%B2"><span class="toc-number">1.4.9.5.</span> <span class="toc-text">使用Uniform缓冲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.4.10.</span> <span class="toc-text">几何着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">使用几何着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%86%E7%A0%B4%E7%89%A9%E4%BD%93"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">爆破物体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E5%90%91%E9%87%8F%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">1.4.10.3.</span> <span class="toc-text">法向量可视化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.4.11.</span> <span class="toc-text">实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.11.1.</span> <span class="toc-text">实例化数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E8%A1%8C%E6%98%9F%E5%B8%A6"><span class="toc-number">1.4.11.2.</span> <span class="toc-text">小行星带</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.11.3.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%97%E9%94%AF%E9%BD%BF"><span class="toc-number">1.4.12.</span> <span class="toc-text">抗锯齿</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7"><span class="toc-number">1.4.12.1.</span> <span class="toc-text">多重采样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenGL%E4%B8%AD%E7%9A%84MSAA"><span class="toc-number">1.4.12.2.</span> <span class="toc-text">OpenGL中的MSAA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E5%B1%8FMSAA"><span class="toc-number">1.4.12.3.</span> <span class="toc-text">离屏MSAA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E7%BA%B9%E7%90%86%E9%99%84%E4%BB%B6"><span class="toc-number">1.4.12.3.1.</span> <span class="toc-text">多重采样纹理附件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E6%B8%B2%E6%9F%93%E7%BC%93%E5%86%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.12.3.2.</span> <span class="toc-text">多重采样渲染缓冲对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%88%B0%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7%E5%B8%A7%E7%BC%93%E5%86%B2"><span class="toc-number">1.4.12.3.3.</span> <span class="toc-text">渲染到多重采样帧缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8A%97%E9%94%AF%E9%BD%BF%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.12.3.4.</span> <span class="toc-text">自定义抗锯齿算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%85%89%E7%85%A7"><span class="toc-number">1.5.</span> <span class="toc-text">高级光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Blinn-Phong"><span class="toc-number">1.5.1.</span> <span class="toc-text">Blinn-Phong</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gamma%E6%A0%A1%E6%AD%A3"><span class="toc-number">1.5.2.</span> <span class="toc-text">Gamma校正</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E6%AD%A3"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">校正</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sRGB%E7%BA%B9%E7%90%86"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">sRGB纹理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%B0%E5%87%8F"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">衰减</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.3.</span> <span class="toc-text">阴影映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">深度贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E6%BA%90%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">光源空间的变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%87%B3%E6%B7%B1%E5%BA%A6%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">渲染至深度贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">渲染阴影</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.5.3.5.</span> <span class="toc-text">改进阴影贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCF"><span class="toc-number">1.5.3.6.</span> <span class="toc-text">PCF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4-vs-%E6%8A%95%E5%BD%B1"><span class="toc-number">1.5.3.7.</span> <span class="toc-text">正交 vs 投影</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E9%98%B4%E5%BD%B1"><span class="toc-number">1.5.4.</span> <span class="toc-text">点阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%B7%B1%E5%BA%A6%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">生成深度立方体贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">光空间的变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">深度着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%87%E5%90%91%E9%98%B4%E5%BD%B1%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.5.4.4.</span> <span class="toc-text">万向阴影贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%AB%8B%E6%96%B9%E4%BD%93%E8%B4%B4%E5%9B%BE%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2"><span class="toc-number">1.5.4.5.</span> <span class="toc-text">显示立方体贴图深度缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PCF-1"><span class="toc-number">1.5.4.6.</span> <span class="toc-text">PCF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.5.5.</span> <span class="toc-text">法线贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">切线空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">切线空间法线贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%89%A9%E4%BD%93"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">复杂物体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%BB%B6%E4%BA%8B"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">最后一件事</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE"><span class="toc-number">1.5.6.</span> <span class="toc-text">视差贴图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A1%E5%B3%AD%E8%A7%86%E5%B7%AE%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">陡峭视差映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%B7%AE%E9%81%AE%E8%94%BD%E6%98%A0%E5%B0%84"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">视差遮蔽映射</span></a></li></ol></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>